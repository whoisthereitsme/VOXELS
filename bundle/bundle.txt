#Time when generated: 2026-01-31T06:59:20

### PROJECT BUNDLE ###
Root: C:\VOXELS
Files included: 42


################################################################################
# FILE 1/42: __init__.py (START)
################################################################################

import utils
import world
import bundle

__all__ = world.__all__ + utils.__all__ + bundle.__all__


################################################################################
# FILE 1/42: __init__.py (END)
################################################################################


################################################################################
# FILE 2/42: __main__.py (START)
################################################################################

from main import main

if __name__ == "__main__":
    main()

################################################################################
# FILE 2/42: __main__.py (END)
################################################################################


################################################################################
# FILE 3/42: all/__init__.py (START)
################################################################################

from bundle import *
from bundle import __all__ as allbundle

from utils import *
from utils import __all__ as allutils

from world import *
from world import __all__ as allworld

from tests import *
from tests import __all__ as alltests


__all__ = [] + allbundle + allutils + allworld + alltests

print(f"Loaded ALL with {len(__all__)} items.")
for name in __all__:
    print(f" - {name}")

################################################################################
# FILE 3/42: all/__init__.py (END)
################################################################################


################################################################################
# FILE 4/42: bundle/__init__.py (START)
################################################################################

from .bundle import *
from .github import *

__all__ = [
    "Bundle",
    "GitHub",
]

################################################################################
# FILE 4/42: bundle/__init__.py (END)
################################################################################


################################################################################
# FILE 5/42: bundle/bundle.py (START)
################################################################################

from __future__ import annotations
import atexit
import sys
import threading
import time
from pathlib import Path
from typing import Iterable, Optional, Set, TextIO, Callable


from .github import GitHub


# ============================================================
# Bundle builder with integrated output capture (no output.txt, no HTML)
# ============================================================

class Bundle:
    class _Tee(TextIO):
        def __init__(self, original: TextIO, buffer: list[str], lock: threading.Lock) -> None:
            self._original = original
            self._buffer = buffer
            self._lock = lock

            

        def write(self, s: str) -> int:
            n = self._original.write(s)
            with self._lock:
                self._buffer.append(s)
            return n

        def flush(self) -> None:
            self._original.flush()

        def isatty(self) -> bool:
            return getattr(self._original, "isatty", lambda: False)()

        @property
        def encoding(self):
            return getattr(self._original, "encoding", "utf-8")

    def __init__(
        self,
        *,
        root: Path | None = None,
        out: Path | None = None,
        exts: Set[str] | None = None,
        dirs: Set[str] | None = None,
        skip: Set[str] | None = None,
        max_bytes: int = 2_000_000,
        overwrite: bool = True,
        include_stderr: bool = True,
        marker_prefix: str = "### CAPTURE START ###",
        auto_end_on_exit: bool = True,
        auto_end_on_exception: bool = True,
    ) -> None:
        self.root = (root if root is not None else Path.cwd()).resolve()
        self.out = (out if out is not None else (self.root / "bundle" / "bundle.txt")).resolve()

        self.exts = exts if exts is not None else {
            ".py", ".pyi", ".txt", ".md", ".json", ".toml", ".yaml", ".yml", ".ini", ".cfg", ".bat", ".ps1", ".sh",
        }
        self.dirs = dirs if dirs is not None else {
            ".git", ".hg", ".svn", ".idea", ".vscode",
            "__pycache__", ".pytest_cache", ".mypy_cache", ".ruff_cache", ".tox",
            ".venv", "venv", "env",
            "node_modules", "dist", "build",
            "atlas", "_old", "__OLD",
        }
        self.skip = skip if skip is not None else {".DS_Store", "Thumbs.db"}
        self.max_bytes = int(max_bytes)
        self.overwrite = bool(overwrite)

        self.include_stderr = bool(include_stderr)
        self.marker_prefix = str(marker_prefix)

        self._lock = threading.Lock()
        self._buf_out: list[str] = []
        self._buf_err: list[str] = []

        self._orig_stdout: Optional[TextIO] = None
        self._orig_stderr: Optional[TextIO] = None
        self._orig_excepthook: Optional[Callable] = None
        self._ended = False

        self.start_capture()

        if auto_end_on_exit:
            atexit.register(self.stop_capture_and_write_bundle)

        if auto_end_on_exception:
            self._install_excepthook()

        self.github = GitHub

    def __enter__(self) -> "Bundle":
        return self

    def __exit__(self, exc_type, exc, tb) -> bool:
        self.stop_capture_and_write_bundle()
        self.github()
        return False

    def _install_excepthook(self) -> None:
        self._orig_excepthook = sys.excepthook

        def hooked(exctype, value, tb) -> None:
            if self._orig_excepthook is not None:
                self._orig_excepthook(exctype, value, tb)
            self.stop_capture_and_write_bundle()

        sys.excepthook = hooked  # type: ignore[assignment]

    def start_capture(self) -> None:
        self._orig_stdout = sys.stdout
        self._orig_stderr = sys.stderr

        sys.stdout = self._Tee(self._orig_stdout, self._buf_out, self._lock)  # type: ignore[assignment]
        if self.include_stderr:
            sys.stderr = self._Tee(self._orig_stderr, self._buf_err, self._lock)  # type: ignore[assignment]

        print(f"{self.marker_prefix} root={self.root.as_posix()}")

    def stop_capture_and_write_bundle(self) -> Path:
        captured = self._end_capture_get_text()
        return self.write_bundle_txt(captured_output=captured)

    def _end_capture_get_text(self) -> str:
        if self._ended:
            with self._lock:
                out_text = "".join(self._buf_out)
                err_text = "".join(self._buf_err)
            return self._combine_streams(out_text, err_text)

        self._ended = True

        if self._orig_stdout is not None:
            sys.stdout = self._orig_stdout  # type: ignore[assignment]
        if self.include_stderr and self._orig_stderr is not None:
            sys.stderr = self._orig_stderr  # type: ignore[assignment]

        if self._orig_excepthook is not None:
            sys.excepthook = self._orig_excepthook  # type: ignore[assignment]

        with self._lock:
            out_text = "".join(self._buf_out)
            err_text = "".join(self._buf_err)

        combined = self._combine_streams(out_text, err_text)

        marker_line = f"{self.marker_prefix} root={self.root.as_posix()}"
        combined = self._keep_after_marker(combined, marker_line)
        return combined

    def _combine_streams(self, out_text: str, err_text: str) -> str:
        combined = out_text
        if self.include_stderr and err_text:
            if combined and not combined.endswith("\n"):
                combined += "\n"
            combined += err_text
        return combined

    @staticmethod
    def _keep_after_marker(text: str, marker_line: str) -> str:
        idx = text.rfind(marker_line)
        if idx == -1:
            return text
        nl = text.find("\n", idx)
        if nl == -1:
            return ""
        return text[nl + 1 :]

    def write_bundle_txt(self, *, captured_output: str) -> Path:
        self.out.parent.mkdir(parents=True, exist_ok=True)
        if self.overwrite and self.out.exists():
            self.out.unlink()

        generated_at = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime())
        files = sorted(self._iter_files(self.root), key=lambda p: str(p.relative_to(self.root)).lower())

        lines: list[str] = []
        lines.append(f"#Time when generated: {generated_at}\n\n")
        lines.append("### PROJECT BUNDLE ###\n")
        lines.append(f"Root: {self.root}\n")
        lines.append(f"Files included: {len(files)}\n\n")

        for i, p in enumerate(files, start=1):
            rel = p.relative_to(self.root).as_posix()

            lines.append("\n" + "#" * 80 + "\n")
            lines.append(f"# FILE {i}/{len(files)}: {rel} (START)\n")
            lines.append("#" * 80 + "\n\n")

            content = self._safe_read_text_lossy(p)
            if content and not content.endswith("\n"):
                content += "\n"
            lines.append(content)

            lines.append("\n" + "#" * 80 + "\n")
            lines.append(f"# FILE {i}/{len(files)}: {rel} (END)\n")
            lines.append("#" * 80 + "\n\n")

        if captured_output.strip():
            lines.append("\n" + "################################################################################\n")
            lines.append("### CAPTURED OUTPUT (STDOUT/STDERR) ###\n")
            lines.append("################################################################################\n\n")
            lines.append(captured_output if captured_output.endswith("\n") else captured_output + "\n")
            lines.append("\n################################################################################\n")
            lines.append("### END OF CAPTURED OUTPUT ###\n")
            lines.append("################################################################################\n")

        final_text = "".join(lines)
        if not final_text.endswith("\n"):
            final_text += "\n"

        total_lines = final_text.count("\n")
        final_text += f"# Total lines in bundle: {total_lines}\n"
        final_text += f"# Total files in bundle: {len(files)}\n"
        final_text += f"# Generated at the time: {time.strftime('%Y-%m-%dT%H:%M:%S', time.localtime())}\n"
        final_text += "--- END OF FILE ---\n"

        self.out.write_text(final_text, encoding="utf-8")
        return self.out

    def _iter_files(self, root: Path) -> Iterable[Path]:
        for p in root.rglob("*"):
            if p.is_dir():
                continue

            parts = set(p.parts)
            if any(d in parts for d in self.dirs):
                continue
            if p.name in self.skip:
                continue
            if p.suffix.lower() not in self.exts:
                continue

            try:
                if p.stat().st_size > self.max_bytes:
                    continue
            except OSError:
                continue

            yield p

    @staticmethod
    def _safe_read_text_lossy(path: Path) -> str:
        try:
            return path.read_text(encoding="utf-8")
        except UnicodeDecodeError:
            return path.read_text(encoding="utf-8", errors="replace")
        except OSError as e:
            return f"<<ERROR READING FILE: {e}>>\n"






################################################################################
# FILE 5/42: bundle/bundle.py (END)
################################################################################


################################################################################
# FILE 6/42: bundle/github.py (START)
################################################################################

import base64
import json
import threading
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Optional, Set

from credentials import *
from utils import Request




@dataclass(frozen=True)
class FileJob:
    local_path: Path
    repo_path: str


class GitHub:
    def __init__(
        self,
        root: Path = Path.cwd(),
        verbose: bool = False,
        workers: int = 12,
        message: str = "Publish project snapshot",
        exts: Optional[Set[str]] = None,
        dirs: Optional[Set[str]] = None,
        files: Optional[Set[str]] = None,
        bytes: int = 2_000_000,
        binary: bool = True,
    ) -> None:
        self.owner = Environ.githublogin
        self.token = Environ.githubtoken
        self.repo = "VOXELS"
        self.branch = "main"
        self.root = root.resolve()
        
        self.verbose = verbose
        self.workers = workers
        self.message = message

        self.exts = exts
        self.dirs = dirs or {
            ".git", ".hg", ".svn",
            ".idea", ".vscode",
            "__pycache__", ".pytest_cache", ".mypy_cache", ".ruff_cache", ".tox",
            ".venv", "venv", "env",
            "node_modules", "dist", "build",
            ".gradle", ".terraform",
            "atlas", "_old", "__OLD",
        }
        self.files = files or {".DS_Store", "Thumbs.db"}
        self.bytes = bytes
        self.binary = binary

        self.lock = threading.Lock()

        self.publish()

    def publish(self) -> None:
        t0 = time.perf_counter()
        if not self.token:
            raise SystemExit(f"Missing environment variable GITHUB_TOKEN.\n", f"Create a fine-grained PAT (Contents: read+write) for repo {self.owner}/{self.repo}.")

        if not self.root.exists() or not self.root.is_dir():
            raise SystemExit(f"root does not exist or is not a directory: {self.root}")

        jobs = self._build_jobs()
        self._log(f"[GITHUB] single-commit publish: {len(jobs)} files from {self.root} -> {self.owner}/{self.repo}@{self.branch}")

        head_commit_sha = self._get_branch_head_commit_sha(self.token)
        base_tree_sha = self._get_commit_tree_sha(self.token, head_commit_sha)

        path_to_blob_sha = self._create_blobs_parallel(self.token, jobs)
        new_tree_sha = self._create_tree(self.token, base_tree_sha, path_to_blob_sha)
        new_commit_sha = self._create_commit(self.token, new_tree_sha, head_commit_sha)
        self._update_branch_ref(self.token, new_commit_sha)

        dt = time.perf_counter() - t0
        self._log(f"[GITHUB] done: 1 commit, {len(jobs)} files, elapsed {dt:.2f}s. files/sec: {len(jobs)/dt:.1f}")

    def _build_jobs(self) -> list[FileJob]:
        files = sorted(self._iter_project_files(self.root), key=lambda p: str(p).lower())
        return [FileJob(p, p.relative_to(self.root).as_posix()) for p in files]

    def _iter_project_files(self, root: Path) -> Iterable[Path]:
        for p in root.rglob("*"):
            if p.is_dir():
                continue

            parts = set(p.parts)
            if any(d in parts for d in self.dirs):
                continue
            if p.name in self.files:
                continue
            if self.exts is not None and p.suffix.lower() not in self.exts:
                continue

            try:
                if p.stat().st_size > self.bytes:
                    continue
            except OSError:
                continue

            if self.binary:
                try:
                    data = p.read_bytes()
                except OSError:
                    continue
                if self._looks_binary(data):
                    continue

            yield p

    @staticmethod
    def _looks_binary(data: bytes) -> bool:
        if b"\x00" in data:
            return True
        sample = data[:8192]
        if not sample:
            return False
        bad = 0
        for b in sample:
            if b in (9, 10, 13) or 32 <= b <= 126:
                continue
            bad += 1
        return (bad / len(sample)) > 0.20

    # -----------------------------
    # GitHub API core
    # -----------------------------
    def _api_request(self, method: str, url: str, token: str, body: Optional[dict] = None) -> dict:
        data = None
        if body is not None:
            data = json.dumps(body).encode("utf-8")

        req = Request(url=url, data=data, method=method, timeout=600, retries=3)
        req.header("Authorization", f"Bearer {token}")
        req.header("Accept", "application/vnd.github+json")
        req.header("X-GitHub-Api-Version", "2022-11-28")
        if data is not None:
            req.header("Content-Type", "application/json; charset=utf-8")

        return req.open()

    def _get_branch_head_commit_sha(self, token: str) -> str:
        url = f"https://api.github.com/repos/{self.owner}/{self.repo}/git/ref/heads/{self.branch}"
        j = self._api_request("GET", url, token)
        return j["object"]["sha"]

    def _get_commit_tree_sha(self, token: str, commit_sha: str) -> str:
        url = f"https://api.github.com/repos/{self.owner}/{self.repo}/git/commits/{commit_sha}"
        j = self._api_request("GET", url, token)
        return j["tree"]["sha"]

    def _create_blob(self, token: str, content_bytes: bytes) -> str:
        url = f"https://api.github.com/repos/{self.owner}/{self.repo}/git/blobs"
        body = {"content": base64.b64encode(content_bytes).decode("ascii"), "encoding": "base64"}
        j = self._api_request("POST", url, token, body=body)
        return j["sha"]

    def _create_blobs_parallel(self, token: str, jobs: list[FileJob]) -> dict[str, str]:
        out: dict[str, str] = {}
        lock = threading.Lock()

        def worker(job: FileJob) -> None:
            data = job.local_path.read_bytes()
            sha = self._create_blob(token, data)
            with lock:
                out[job.repo_path] = sha
            if self.verbose:
                self._log(f"    [blob] {job.repo_path}")

        with ThreadPoolExecutor(max_workers=self.workers) as ex:
            futures = [ex.submit(worker, j) for j in jobs]
            for fut in as_completed(futures):
                fut.result()

        return out

    def _create_tree(self, token: str, base_tree_sha: str, path_to_blob_sha: dict[str, str]) -> str:
        url = f"https://api.github.com/repos/{self.owner}/{self.repo}/git/trees"
        tree_entries = [
            {"path": path, "mode": "100644", "type": "blob", "sha": blob_sha}
            for path, blob_sha in path_to_blob_sha.items()
        ]
        body = {"base_tree": base_tree_sha, "tree": tree_entries}
        j = self._api_request("POST", url, token, body=body)
        return j["sha"]

    def _create_commit(self, token: str, tree_sha: str, parent_commit_sha: str) -> str:
        url = f"https://api.github.com/repos/{self.owner}/{self.repo}/git/commits"
        body = {"message": self.message, "tree": tree_sha, "parents": [parent_commit_sha]}
        j = self._api_request("POST", url, token, body=body)
        return j["sha"]

    def _update_branch_ref(self, token: str, new_commit_sha: str) -> None:
        url = f"https://api.github.com/repos/{self.owner}/{self.repo}/git/refs/heads/{self.branch}"
        body = {"sha": new_commit_sha, "force": False}
        self._api_request("PATCH", url, token, body=body)

    def _log(self, msg: str) -> None:
        with self.lock:
            print(msg)


################################################################################
# FILE 6/42: bundle/github.py (END)
################################################################################


################################################################################
# FILE 7/42: credentials/__init__.py (START)
################################################################################

from .environ import Environ

__all__ = [
    "Environ"
]   

################################################################################
# FILE 7/42: credentials/__init__.py (END)
################################################################################


################################################################################
# FILE 8/42: credentials/environ.py (START)
################################################################################




import os



class Environ:
    githublogin = os.getenv("GITHUB_LOGIN")
    githubtoken = os.getenv("GITHUB_TOKEN")
    mailadress  = os.getenv("MAIL_ADRESS")
    phonenumber = os.getenv("PHONE_NUMBER")
    ippublic    = os.getenv("IP_PUBLIC")
    ipprivate   = os.getenv("IP_PRIVATE")
    sshkey      = os.getenv("SSH_KEY")


################################################################################
# FILE 8/42: credentials/environ.py (END)
################################################################################


################################################################################
# FILE 9/42: main.py (START)
################################################################################

from all import *





if __name__ == "__main__":
    tests(tests=[test6])

################################################################################
# FILE 9/42: main.py (END)
################################################################################


################################################################################
# FILE 10/42: tests/__init__.py (START)
################################################################################


from .test1 import test1
from .test2 import test2
from .test3 import test3
from .test4 import test4
from .test5 import test5
from .test6 import test6
from .test7 import test7
from .test8 import test8
from .test9 import test9
from .test10 import test10
from .tests import tests

__all__ = [
    "test1",
    "test2",
    "test3",
    "test4",
    "test5",
    "test6",
    "test7",
    "test8",
    "test9",
    "test10",
    "tests",
]

################################################################################
# FILE 10/42: tests/__init__.py (END)
################################################################################


################################################################################
# FILE 11/42: tests/test1.py (START)
################################################################################

# tests/test1.py

from utils import *
from world import *
from bundle import *


def test1() -> None:
    """
    test1:
    Build a dense 3D grid of STONE AABBs, then verify BVH partition integrity by:
    - random point lookups must always find a row
    - found row must CONTAIN the queried point
    Then delete a chunk of rows, rebuild a different grid, and re-run the same checks.
    """
    rows = ROWS()

    # remove the default huge row (STONE rid=0)
    rows.remove(row=rows.get(mat="STONE", rid=0))

    # STEP 1 grid
    cell = 20
    nx = 40
    ny = 40
    nz = 40

    timer.lap()
    for ix in range(nx):
        x0 = ix * cell
        x1 = x0 + cell
        for iy in range(ny):
            y0 = iy * cell
            y1 = y0 + cell
            for iz in range(nz):
                z0 = iz * cell
                z1 = z0 + cell
                rows.insert(p0=(x0, y0, z0), p1=(x1, y1, z1), mat="STONE")
    timer.print(msg="STEP 1 : 3D grid partition built")

    max_x = nx * cell - 1
    max_y = ny * cell - 1
    max_z = nz * cell - 1

    succes = 0
    fails = 0
    for _ in range(1000):
        pos = (
            random.randint(0, max_x),
            random.randint(0, max_y),
            random.randint(0, max_z),
        )
        try:
            mat, rid, row = rows.search(pos=pos)
            assert ROW.CONTAINS(row=row, pos=pos), (
                f"pos={pos} not contained (mat={mat}, rid={rid}) "
                f"p0={ROW.P0(row=row)} p1={ROW.P1(row=row)}"
            )
            succes += 1
        except Exception:
            fails += 1
            raise

    assert fails == 0, f"BVH/grid lookup failures in STEP 1: {fails} (success={succes})"
    print(f" - STEP 1 lookup checks OK: {succes} successes, {fails} fails, {succes/timer.delta[-1]:.2f} lookups/sec")
    timer.print(msg=" - STEP 1 lookups completed in")

    # delete some rows (stress BVH remove/swap)
    print(" - Now deleting 10000 rows...")
    for _ in range(10000):
        rid_last = rows.nrows(mat="STONE") - 1
        rows.remove(row=rows.get(mat="STONE", rid=rid_last))
    timer.print(msg=" - Deleted 10000 rows in")

    # STEP 2 grid â€” rebuild from scratch for clean bounds
    while rows.nrows(mat="STONE") > 0:
        rid_last = rows.nrows(mat="STONE") - 1
        rows.remove(row=rows.get(mat="STONE", rid=rid_last))

    print("STEP 2 : Rebuilding rows after deletion...")
    cell = 40
    nx = 20
    ny = 20
    nz = 20

    timer.lap()
    for ix in range(nx):
        x0 = ix * cell
        x1 = x0 + cell
        for iy in range(ny):
            y0 = iy * cell
            y1 = y0 + cell
            for iz in range(nz):
                z0 = iz * cell
                z1 = z0 + cell
                rows.insert(p0=(x0, y0, z0), p1=(x1, y1, z1), mat="STONE")
    timer.print(msg=" - STEP 2 grid partition built")

    max_x = nx * cell - 1
    max_y = ny * cell - 1
    max_z = nz * cell - 1

    succes = 0
    fails = 0
    for _ in range(1000):
        pos = (
            random.randint(0, max_x),
            random.randint(0, max_y),
            random.randint(0, max_z),
        )
        mat, rid, row = rows.search(pos=pos)
        assert ROW.CONTAINS(row=row, pos=pos), (
            f"pos={pos} not contained (mat={mat}, rid={rid}) "
            f"p0={ROW.P0(row=row)} p1={ROW.P1(row=row)}"
        )
        succes += 1

    assert fails == 0, f"BVH/grid lookup failures in STEP 2: {fails} (success={succes})"
    print(f" - STEP 2 lookup checks OK: {succes} successes, {fails} fails, {succes/timer.delta[-1]:.2f} lookups/sec")
    timer.print(msg=" - STEP 2 lookups completed in")

################################################################################
# FILE 11/42: tests/test1.py (END)
################################################################################


################################################################################
# FILE 12/42: tests/test10.py (START)
################################################################################



def test10() -> None:
    pass

################################################################################
# FILE 12/42: tests/test10.py (END)
################################################################################


################################################################################
# FILE 13/42: tests/test2.py (START)
################################################################################

# tests/test2.py

from utils import *
from world import *
from bundle import *


def test2() -> None:
    """
    test2:
    Random single-point splits into AIR inside the default big STONE row.
    Verifies:
    - world volume invariant
    - each split point becomes AIR
    - merge() does not break invariants
    """
    rows = ROWS()
    v0 = rows.volume()
    print("WORLD VOLUME BEFORE:", v0)

    points: list[POS] = []
    for i in range(10):
        x = random.randint(a=1000, b=999000)
        y = random.randint(a=1000, b=999000)
        z = random.randint(a=1000, b=64000)
        pos = (x, y, z)
        points.append(pos)
        rows.split(pos=pos, mat="AIR")
        print(f" - SPLIT test {i+1}/10 passed.")

    v1 = rows.volume()
    print("WORLD VOLUME AFTER:", v1)
    assert v1 == v0, f"volume changed after splits: before={v0}, after={v1}"

    for pos in points:
        mat, rid, row = rows.search(pos=pos)
        assert mat == "AIR", f"expected AIR at {pos}, got {mat}"

    timer.print(msg="STARTING STEP : Now testing MERGE functionality...")
    rows.merge()
    timer.print(msg=" - MERGE completed in")

    v2 = rows.volume()
    print("WORLD VOLUME AFTER MERGE:", v2)
    assert v2 == v0, f"volume changed after merge: before={v0}, after={v2}"

    for pos in points:
        mat, rid, row = rows.search(pos=pos)
        assert mat == "AIR", f"expected AIR at {pos} after merge, got {mat}"

    for mid in range(len(rows.array)):
        name = Materials.mid2name[mid]
        n = rows.nrows(mat=name)
        print(f"Material {name} has {n} rows after MERGE tests.")

################################################################################
# FILE 13/42: tests/test2.py (END)
################################################################################


################################################################################
# FILE 14/42: tests/test3.py (START)
################################################################################

# tests/test3.py

from utils import *
from world import *
from bundle import *


def test3() -> None:
    """
    test3:
    Create multiple 5x5x5 "mines" (AIR blocks) at random places and run merge attempts.
    Verifies:
    - world volume invariant
    - all mine points remain AIR
    """
    rows = ROWS()
    v0 = rows.volume()

    mines: list[POS] = []
    for _ in range(10):
        x = random.randint(a=1000, b=999000)
        y = random.randint(a=1000, b=999000)
        z = random.randint(a=1000, b=64000)
        mines.append((x, y, z))
    print(len(mines), "mines to be created at random positions.")

    mine_points: list[POS] = []
    for mine in mines:
        for dx in range(5):
            for dy in range(5):
                for dz in range(5):
                    pos = (mine[0] + dx, mine[1] + dy, mine[2] + dz)
                    mine_points.append(pos)
                    rows.split(pos=pos, mat="AIR")

    # merge attempts
    rowsbefore = rows.nrows(mat="AIR")
    for i in range(10):
        print("Performing MERGE to consolidate AIR rows... AIR rows before:", rows.nrows(mat="AIR"), "in merge iteration:", i + 1)
        rows.merge()
        rowsafter = rows.nrows(mat="AIR")
        if rowsafter == rowsbefore:
            print(" No more AIR rows could be consolidated. Stopping MERGE.")
            break
        rowsbefore = rowsafter

    v1 = rows.volume()
    assert v1 == v0, f"volume changed: before={v0}, after={v1}"

    # verify all mine points still AIR
    for pos in random.sample(mine_points, k=min(2000, len(mine_points))):
        mat, rid, row = rows.search(pos=pos)
        assert mat == "AIR", f"expected AIR at {pos}, got {mat}"

    for mid in range(len(rows.array)):
        name = Materials.mid2name[mid]
        n = rows.nrows(mat=name)
        print(f"Material {name} has {n} rows after MERGE tests.")
        if name == "AIR":
            for rid in range(n):
                r = rows.get(mat="AIR", rid=rid)
                print(f"  AIR row {rid}: p0={ROW.P0(row=r)}, p1={ROW.P1(row=r)}")

    print(f"air rows= {rows.nrows(mat='AIR')}", f"stone rows= {rows.nrows(mat='STONE')}")

################################################################################
# FILE 14/42: tests/test3.py (END)
################################################################################


################################################################################
# FILE 15/42: tests/test4.py (START)
################################################################################

# tests/test4.py

from utils import *
from world import *
from bundle import *


def test4() -> None:
    """
    test4:
    Split off multiple *single-row-contained* regions (disjoint by construction) inside default big STONE row.
    Verifies:
    - world volume invariant
    - AIR volume equals sum of carved boxes (valid because we keep them disjoint)
    - random points inside carved boxes are AIR
    - random points far away are NOT AIR
    """
    rows = ROWS()
    v0 = rows.volume()
    print("WORLD VOLUME BEFORE:", v0)

    boxes: list[tuple[POS, POS]] = []
    total_air_vol = 0

    slot = 64
    for i in range(50):
        gx = random.randint(50, 2000) * slot
        gy = random.randint(50, 2000) * slot
        gz = random.randint(10, 900) * slot

        dx = random.randint(4, 48)
        dy = random.randint(4, 48)
        dz = random.randint(4, 32)

        x0 = gx + 1
        y0 = gy + 1
        z0 = gz + 1
        p0 = (x0, y0, z0)
        p1 = (x0 + dx, y0 + dy, z0 + dz)
        p0, p1 = ROW.SORT(p0=p0, p1=p1)

        rows.split(pos=p0, pos1=p1, mat="AIR")
        boxes.append((p0, p1))
        total_air_vol += (p1[0] - p0[0]) * (p1[1] - p0[1]) * (p1[2] - p0[2])

        if (i + 1) % 10 == 0:
            print(f" - carved {i+1}/50 boxes")

    rows.merge()

    v1 = rows.volume()
    print("WORLD VOLUME AFTER:", v1)
    assert v1 == v0, f"volume changed: before={v0}, after={v1}"

    air_vol = rows.volume(mat="AIR")
    print("AIR VOLUME:", air_vol, "EXPECTED (sum boxes):", total_air_vol)
    assert air_vol == total_air_vol, f"AIR volume mismatch: got={air_vol}, expected={total_air_vol}"

    for _ in range(500):
        p0, p1 = random.choice(boxes)
        x = random.randint(p0[0], p1[0] - 1)
        y = random.randint(p0[1], p1[1] - 1)
        z = random.randint(p0[2], p1[2] - 1)
        mat, rid, row = rows.search(pos=(x, y, z))
        assert mat == "AIR", f"expected AIR at {(x,y,z)}, got {mat}"

    for _ in range(500):
        x = random.randint(10, 900)
        y = random.randint(10, 900)
        z = random.randint(10, 900)
        mat, rid, row = rows.search(pos=(x, y, z))
        assert mat != "AIR", f"unexpected AIR at {(x,y,z)}"

    print("test4 OK:", f"air_rows={rows.nrows(mat='AIR')}", f"stone_rows={rows.nrows(mat='STONE')}")

################################################################################
# FILE 15/42: tests/test4.py (END)
################################################################################


################################################################################
# FILE 16/42: tests/test5.py (START)
################################################################################

# tests/test5.py

from utils import *
from world import *
from bundle import *


def test5() -> None:
    """
    test5:
    Split off regions that span multiple rows (overlapping allowed).
    Verifies:
    - world volume invariant
    - AIR volume computed via rows.volume(mat="AIR")
    - random points inside carved regions are AIR
    """
    rows = ROWS()

    # remove default huge STONE row
    rows.remove(row=rows.get(mat="STONE", rid=0))

    cell = 64
    nx = 20
    ny = 20
    nz = 8

    for ix in range(nx):
        x0 = ix * cell
        x1 = x0 + cell
        for iy in range(ny):
            y0 = iy * cell
            y1 = y0 + cell
            for iz in range(nz):
                z0 = iz * cell
                z1 = z0 + cell
                rows.insert(p0=(x0, y0, z0), p1=(x1, y1, z1), mat="STONE")

    rows.merge()

    max_x = nx * cell
    max_y = ny * cell
    max_z = nz * cell

    v0 = rows.volume()
    print("WORLD VOLUME BEFORE:", v0)
    print("Initial rows:", f"stone_rows={rows.nrows(mat='STONE')}", f"air_rows={rows.nrows(mat='AIR')}")

    carved_boxes: list[tuple[POS, POS]] = []

    for i in range(30):
        dx = random.randint(cell + 5, cell * 3)
        dy = random.randint(cell + 5, cell * 3)
        dz = random.randint(cell + 5, cell * 2)

        ox = random.randint(1, cell - 2)
        oy = random.randint(1, cell - 2)
        oz = random.randint(1, cell - 2)

        x0_base = random.randint(0, max_x - dx - ox)
        y0_base = random.randint(0, max_y - dy - oy)
        z0_base = random.randint(0, max_z - dz - oz)

        x0 = x0_base + ox
        y0 = y0_base + oy
        z0 = z0_base + oz

        x1 = min(x0 + dx, max_x)
        y1 = min(y0 + dy, max_y)
        z1 = min(z0 + dz, max_z)

        p0, p1 = ROW.SORT(p0=(x0, y0, z0), p1=(x1, y1, z1))
        if p0[0] >= p1[0] or p0[1] >= p1[1] or p0[2] >= p1[2]:
            continue

        rows.split(pos=p0, pos1=p1, mat="AIR")
        carved_boxes.append((p0, p1))

        if (i + 1) % 10 == 0:
            print(f" - carved {i+1}/30 boxes")

    rows.merge()

    v1 = rows.volume()
    print("WORLD VOLUME AFTER:", v1)
    assert v1 == v0, f"world volume changed: before={v0}, after={v1}"

    air_vol = rows.volume(mat="AIR")
    print("AIR VOLUME:", air_vol)

    for _ in range(1000):
        p0, p1 = random.choice(carved_boxes)
        x = random.randint(p0[0], p1[0] - 1)
        y = random.randint(p0[1], p1[1] - 1)
        z = random.randint(p0[2], p1[2] - 1)
        mat, rid, row = rows.search(pos=(x, y, z))
        assert mat == "AIR", f"expected AIR at {(x,y,z)}, got {mat}"

    print("test5 OK:", f"air_rows={rows.nrows(mat='AIR')}", f"stone_rows={rows.nrows(mat='STONE')}")

################################################################################
# FILE 16/42: tests/test5.py (END)
################################################################################


################################################################################
# FILE 17/42: tests/test6.py (START)
################################################################################

# tests/test6.py

from utils import *
from world import *
from bundle import *


def test6() -> None:
    """
    test6:
    Timing benchmark: 100 calls per operation category.
    IMPORTANT: each category runs on a fresh baseline world so timings stay comparable.
    """
    print("=== TEST6: TIMING BENCHMARK (100 calls per op, fresh world per op) ===")
    ntests = 10

    def make_world() -> tuple[ROWS, int, int, int, int]:
        rows = ROWS()

        # remove default huge STONE row
        rows.remove(row=rows.get(mat="STONE", rid=0))

        cell = 64
        nx, ny, nz = 20, 20, 8
        for ix in range(nx):
            for iy in range(ny):
                for iz in range(nz):
                    x0 = ix * cell
                    y0 = iy * cell
                    z0 = iz * cell
                    rows.insert(
                        p0=(x0, y0, z0),
                        p1=(x0 + cell, y0 + cell, z0 + cell),
                        mat="STONE",
                    )

        rows.merge()
        max_x = nx * cell - 1
        max_y = ny * cell - 1
        max_z = nz * cell - 1
        return rows, cell, max_x, max_y, max_z

    # 1) SEARCH
    rows, cell, max_x, max_y, max_z = make_world()
    timer.lap()
    for _ in range(ntests):
        pos = (random.randint(0, max_x), random.randint(0, max_y), random.randint(0, max_z))
        rows.search(pos=pos)
    timer.print(msg=f"test6: search() [tests={ntests}]")

    # 2) SPLIT1
    rows, cell, max_x, max_y, max_z = make_world()
    timer.lap()
    for _ in range(ntests):
        pos = (random.randint(10, max_x - 10), random.randint(10, max_y - 10), random.randint(10, max_z - 10))
        rows.split(pos=pos, mat="AIR")
    timer.print(msg=f"test6: split1 (point split) [tests={ntests}]")

    # 3) SPLIT2
    rows, cell, max_x, max_y, max_z = make_world()
    timer.lap()
    for _ in range(ntests):
        dx = random.randint(cell + 5, cell * 3)
        dy = random.randint(cell + 5, cell * 3)
        dz = random.randint(cell + 5, cell * 2)

        x0 = random.randint(0, max_x - dx)
        y0 = random.randint(0, max_y - dy)
        z0 = random.randint(0, max_z - dz)

        p0, p1 = ROW.SORT(p0=(x0, y0, z0), p1=(x0 + dx, y0 + dy, z0 + dz))
        rows.split(pos=p0, pos1=p1, mat="AIR")
    timer.print(msg=f"test6: split2 (region split) [tests={ntests}]")

    # 4) MERGE (meaningful merge: first fragment it a bit)
    rows, cell, max_x, max_y, max_z = make_world()
    for _ in range(200):
        pos = (random.randint(10, max_x - 10), random.randint(10, max_y - 10), random.randint(10, max_z - 10))
        rows.split(pos=pos, mat="AIR")
    timer.lap()
    for _ in range(ntests):
        rows.merge()
    timer.print(msg=f"test6: merge() [tests={ntests}]")

    # 5) REMOVE (remove from STONE preferentially)
    rows, cell, max_x, max_y, max_z = make_world()
    timer.lap()
    for _ in range(ntests):
        if rows.nrows(mat="STONE") <= 0:
            break
        rid_last = rows.nrows(mat="STONE") - 1
        rows.remove(row=rows.get(mat="STONE", rid=rid_last))
    timer.print(msg=f"test6: remove() [tests={ntests}]")

    # 6) INSERT (small inserts)
    rows, cell, max_x, max_y, max_z = make_world()
    timer.lap()
    for _ in range(ntests):
        x0 = random.randint(0, max_x - 2)
        y0 = random.randint(0, max_y - 2)
        z0 = random.randint(0, max_z - 2)
        rows.insert(p0=(x0, y0, z0), p1=(x0 + 1, y0 + 1, z0 + 1), mat="STONE")
    timer.print(msg=f"test6: insert() [tests={ntests}]")

    print("=== TEST6 DONE ===")

################################################################################
# FILE 17/42: tests/test6.py (END)
################################################################################


################################################################################
# FILE 18/42: tests/test7.py (START)
################################################################################

# tests/test7.py

from utils import *
from world import *


def test7() -> None:
    """
    test7:
    Bulletproof Resource/Resources/Warehouse invariants.
    """
    print("=== TEST7: RESOURCE / WAREHOUSE INVARIANTS ===")

    # 1) Resource.split() invariants
    for _ in range(1000):
        amount = random.randint(0, 10_000)
        value = random.randint(0, 12_000)

        r = Resource(mat="STONE", amount=amount)
        original = r.copy()

        part1, leftover = r.split(value=value)  # [taken, leftover]

        assert part1.mat == original.mat
        assert leftover.mat == original.mat

        assert 0 <= part1.amount <= original.amount
        assert 0 <= leftover.amount <= original.amount

        assert part1.amount == min(value, original.amount)
        assert part1.amount + leftover.amount == original.amount

    print(" - split() invariants OK (1000 cases)")

    # 2) Resource arithmetic semantics (mutating)
    a = Resource(mat="STONE", amount=50)
    b = Resource(mat="STONE", amount=20)

    a0 = a.amount
    b0 = b.amount
    a + b
    assert a.amount == a0 + b0
    assert b.amount == b0

    a = Resource(mat="STONE", amount=50)
    b = Resource(mat="STONE", amount=20)
    a += b
    assert a.amount == 70
    assert b.amount == 0

    a = Resource(mat="STONE", amount=50)
    b = Resource(mat="STONE", amount=20)
    a0 = a.amount
    b0 = b.amount
    a - b
    assert a.amount == a0 - b0
    assert b.amount == b0

    a = Resource(mat="STONE", amount=10)
    b = Resource(mat="STONE", amount=20)
    a0 = a.amount
    b0 = b.amount
    a - b
    assert a.amount == 0
    assert b.amount == b0

    a = Resource(mat="STONE", amount=10)
    b = Resource(mat="STONE", amount=20)
    a -= b
    assert a.amount == 0
    assert b.amount == 10

    print(" - Resource +/- semantics OK")

    # 3) Resources ingest/transfer semantics
    inv = Resources(rez=[])
    r1 = Resource(mat="STONE", amount=10)
    r2 = Resource(mat="STONE", amount=5)

    inv + r1
    assert inv.get(mat="STONE").amount == 10
    assert r1.amount == 10

    inv += r2
    assert inv.get(mat="STONE").amount == 15
    assert r2.amount == 0

    print(" - Resources ingest/transfer OK")

    # 4) Warehouse.give()/take() invariants
    wh = Warehouse(rows=None, pos=(0, 0, 0), size=(2, 2, 2))  # cap = 512
    assert wh.cap == 512
    assert wh.total() == 0
    assert wh.free() == 512

    incoming = Resource(mat="STONE", amount=600)
    leftover = wh.give(incoming=incoming)

    assert wh.get(mat="STONE").amount == 512
    assert leftover.mat == "STONE"
    assert leftover.amount == 88

    req = Resource(mat="STONE", amount=200)
    taken = wh.take(requested=req)

    assert taken.mat == "STONE"
    assert taken.amount == 200
    assert wh.get(mat="STONE").amount == 312

    req2 = Resource(mat="STONE", amount=9999)
    taken2 = wh.take(requested=req2)

    assert taken2.amount == 312
    assert wh.get(mat="STONE").amount == 0

    print(" - Warehouse give/take invariants OK")
    print("=== TEST7 DONE ===")

################################################################################
# FILE 18/42: tests/test7.py (END)
################################################################################


################################################################################
# FILE 19/42: tests/test8.py (START)
################################################################################






def test8() -> None:
    pass

################################################################################
# FILE 19/42: tests/test8.py (END)
################################################################################


################################################################################
# FILE 20/42: tests/test9.py (START)
################################################################################






def test9() -> None:
    pass

################################################################################
# FILE 20/42: tests/test9.py (END)
################################################################################


################################################################################
# FILE 21/42: tests/tests.py (START)
################################################################################

from utils import *
from world import *
from bundle import *
from tests import *



def tests(tests:list=None) -> None:
    if tests is None:
        tests = [test1, test2, test3, test4, test5, test6]

    
    with Bundle():
        try:
            for i, test in enumerate(tests):
                
                print(f"\n=== RUNNING TEST {i+1}/{len(tests)}: {test.__name__} ===")
                timer.lap()
                test()
                print(f"=== TEST {i+1}/{len(tests)}: {test.__name__} PASSED in {timer.lap():.3f} seconds ===\n")

        except Exception:
            traceback.print_exc()
        finally:
            pass

################################################################################
# FILE 21/42: tests/tests.py (END)
################################################################################


################################################################################
# FILE 22/42: TODO.md (START)
################################################################################




# ! ROWS
# TODO:

# ! UTILS
# TODO: 

# ! BUNDLE
# TODO: 

################################################################################
# FILE 22/42: TODO.md (END)
################################################################################


################################################################################
# FILE 23/42: utils/__init__.py (START)
################################################################################

from .request import Request

from .includes import *
from .includes import __all__ as inc

__all__ = [
    "Request",
]

__all__.extend(inc)

################################################################################
# FILE 23/42: utils/__init__.py (END)
################################################################################


################################################################################
# FILE 24/42: utils/bvh.py (START)
################################################################################

# utils/bvh.py
from __future__ import annotations
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from world.rows import ROWS

from world.row import ROW
from utils.types import POS, Row


class BVH:
    __slots__ = (
        "rows",
        "root",
        "x0","y0","z0","x1","y1","z1",
        "left","right","parent",
        "lmid","lrid",
        "lidx"
    )

    def __init__(self, rows: "ROWS" = None) -> None:
        self.rows = rows
        self.root = -1

        self.x0 = []
        self.y0 = []
        self.z0 = []
        self.x1 = []
        self.y1 = []
        self.z1 = []

        self.left = []
        self.right = []
        self.parent = []

        self.lmid = []
        self.lrid = []

        self.lidx: dict[tuple[int,int],int] = {}

    # ============================================================
    # node helpers
    # ============================================================

    def newnode(
        self,
        x0:int,y0:int,z0:int,
        x1:int,y1:int,z1:int,
        lmid:int=-1,lrid:int=-1,
        left:int=-1,right:int=-1,parent:int=-1
    )->int:
        idx = len(self.x0)

        self.x0.append(x0)
        self.y0.append(y0)
        self.z0.append(z0)
        self.x1.append(x1)
        self.y1.append(y1)
        self.z1.append(z1)

        self.left.append(left)
        self.right.append(right)
        self.parent.append(parent)

        self.lmid.append(lmid)
        self.lrid.append(lrid)

        return idx

    def expand(self, a:int, b:int)->None:
        self.x0[a] = min(self.x0[a], self.x0[b])
        self.y0[a] = min(self.y0[a], self.y0[b])
        self.z0[a] = min(self.z0[a], self.z0[b])
        self.x1[a] = max(self.x1[a], self.x1[b])
        self.y1[a] = max(self.y1[a], self.y1[b])
        self.z1[a] = max(self.z1[a], self.z1[b])

    def area(self, n:int)->int:
        return (
            (self.x1[n]-self.x0[n]) *
            (self.y1[n]-self.y0[n]) *
            (self.z1[n]-self.z0[n])
        )

    # ============================================================
    # insertion logic
    # ============================================================

    def insert(self, row:Row=None)->None:
        mid,rid,row = int(row.mid),int(row.rid),row.row
        x0,y0,z0 = ROW.P0(row=row)
        x1,y1,z1 = ROW.P1(row=row)

        leaf = self.newnode(
            x0,y0,z0,x1,y1,z1,
            lmid=mid,lrid=rid
        )
        self.lidx[(mid,rid)] = leaf

        if self.root == -1:
            self.root = leaf
            return

        self.root = self.insertnode(self.root, leaf)

    def insertnode(self, root:int, leaf:int)->int:
        if self.lmid[root] != -1:
            parent = self.newnode(
                min(self.x0[root], self.x0[leaf]),
                min(self.y0[root], self.y0[leaf]),
                min(self.z0[root], self.z0[leaf]),
                max(self.x1[root], self.x1[leaf]),
                max(self.y1[root], self.y1[leaf]),
                max(self.z1[root], self.z1[leaf]),
                left=root,
                right=leaf
            )
            self.parent[root] = parent
            self.parent[leaf] = parent
            return parent

        l = self.left[root]
        r = self.right[root]

        cost_l = self.area(self.merge_cost(l, leaf))
        cost_r = self.area(self.merge_cost(r, leaf))

        if cost_l <= cost_r:
            self.left[root] = self.insertnode(l, leaf)
            self.parent[self.left[root]] = root
        else:
            self.right[root] = self.insertnode(r, leaf)
            self.parent[self.right[root]] = root

        self.expand(root, leaf)
        return root

    def merge_cost(self, a:int, b:int)->int:
        return self.newnode(
            min(self.x0[a], self.x0[b]),
            min(self.y0[a], self.y0[b]),
            min(self.z0[a], self.z0[b]),
            max(self.x1[a], self.x1[b]),
            max(self.y1[a], self.y1[b]),
            max(self.z1[a], self.z1[b])
        )

    def fixupwards(self, n:int)->None:
        while n != -1:
            l = self.left[n]
            r = self.right[n]
            self.x0[n] = min(self.x0[l], self.x0[r])
            self.y0[n] = min(self.y0[l], self.y0[r])
            self.z0[n] = min(self.z0[l], self.z0[r])
            self.x1[n] = max(self.x1[l], self.x1[r])
            self.y1[n] = max(self.y1[l], self.y1[r])
            self.z1[n] = max(self.z1[l], self.z1[r])
            n = self.parent[n]

    # ============================================================
    # removal
    # ============================================================

    def remove(self, row:Row=None)->None:
        mid,rid = int(row.mid),int(row.rid)
        node = self.lidx.pop((mid,rid),None)
        if node is None:
            return

        parent = self.parent[node]
        if parent == -1:
            self.root = -1
            return

        sibling = (
            self.right[parent]
            if self.left[parent] == node
            else self.left[parent]
        )
        grand = self.parent[parent]

        if grand == -1:
            self.root = sibling
            self.parent[sibling] = -1
        else:
            if self.left[grand] == parent:
                self.left[grand] = sibling
            else:
                self.right[grand] = sibling
            self.parent[sibling] = grand
            self.fixupwards(grand)

    # ============================================================
    # search
    # ============================================================

    def search(self, pos:POS)->Row:
        if self.root == -1:
            raise LookupError("BVH empty")

        x,y,z = pos
        stack = [self.root]

        while stack:
            n = stack.pop()
            if n == -1:
                continue

            if not (
                self.x0[n] <= x < self.x1[n] and
                self.y0[n] <= y < self.y1[n] and
                self.z0[n] <= z < self.z1[n]
            ):
                continue

            if self.lmid[n] != -1:
                mid = int(self.lmid[n])
                rid = int(self.lrid[n])
                row = self.rows.array[mid][rid]
                if ROW.CONTAINS(row=row,pos=pos):
                    return Row(mid=mid,rid=rid,row=row)
                continue

            stack.append(self.left[n])
            stack.append(self.right[n])

        raise LookupError("point not found")

################################################################################
# FILE 24/42: utils/bvh.py (END)
################################################################################


################################################################################
# FILE 25/42: utils/event.py (START)
################################################################################

from __future__ import annotations
from typing import Any, Callable
from dataclasses import dataclass, field
from .event import Event
from .schedule import Schedule



@dataclass(order=True)
class Event:
    due_ns: int
    seq: int
    callback: Callable[..., Any] = field(compare=False)
    args: tuple[Any, ...] = field(default_factory=tuple, compare=False)
    kwargs: dict[str, Any] = field(default_factory=dict, compare=False)
    cancelled: bool = field(default=False, compare=False)


class Handler:
    __slots__ = ("_scheduler", "_event")

    def __init__(self, scheduler: "Schedule", event: Event) -> None:
        self._scheduler = scheduler
        self._event = event

    def cancel(self) -> bool:
        return self._scheduler.cancel(self)


################################################################################
# FILE 25/42: utils/event.py (END)
################################################################################


################################################################################
# FILE 26/42: utils/includes.py (START)
################################################################################

from __future__ import annotations  # MUST BE FIRST

# EXCEPTION IMPORTS
from .timer import Timer, time      # NON SORTED -> HERE BECAUSE Timer IS USED IMMEDIATELY
timer = Timer()

# IMPORTS FROM STANDARD LIBRARY AND THIRD-PARTY LIBRARIES
from typing import TYPE_CHECKING, Any, Iterator, TypeVar, Generic, Union, Tuple, List, Dict, Callable, Optional
from pathlib import Path
from numpy.typing import NDArray
from PIL import Image, ImageDraw, ImageFont


# SIMPLE IMPORTS
import math
import numpy as np
import torch 
import heapq
import threading
import json
import time
import pathlib
import sys
import os
import random
import shutil
import datetime
import bisect
import pygame
import moderngl
import traceback
import stat


# my own modules (utils)
from .types import POS, SIZE


# Exports
__all__ = [
    "math",
    "time",
    "np",
    "NDArray",
    "torch",
    "TYPE_CHECKING",
    "annotations",
    "Any",
    "Iterator",
    "TypeVar",
    "Generic",
    "Union",
    "Tuple",
    "List",
    "Dict",
    "Callable",
    "Optional",
    "Image",
    "ImageDraw",
    "ImageFont",
    "Timer",
    "heapq",
    "threading",
    "json",
    "Path",
    "POS",
    "SIZE",
    "pathlib",
    "sys",
    "os",
    "random",
    "shutil",
    "datetime",
    "bisect",
    "pygame",
    "moderngl",
    "timer", # include the instance timer -> can be used as utils.timer
    "traceback",
    "stat",
]

# END OF FILE

################################################################################
# FILE 26/42: utils/includes.py (END)
################################################################################


################################################################################
# FILE 27/42: utils/mdx.py (START)
################################################################################

# utils/mdx.py
from __future__ import annotations
from typing import TYPE_CHECKING, DefaultDict, Dict, Optional, Set, Tuple
from collections import defaultdict
from dataclasses import dataclass

if TYPE_CHECKING:
    from world.rows import ROWS

from world.row import ROW
from utils.types import NDARR, Row


# Location identity in the world arrays
Loc = Tuple[int, int]  # (mid, rid)

# A face key (one plane of an AABB):
# axis X: (mid, y0, y1, z0, z1, x_face)
# axis Y: (mid, x0, x1, z0, z1, y_face)
# axis Z: (mid, x0, x1, y0, y1, z_face)
FACE = Tuple[int, int, int, int, int, int]

BUCK = DefaultDict[FACE, Set[Loc]]  # face_key -> set of Locs
FACES = Tuple[FACE, FACE]           # (pos_face, neg_face) for search order
BUCKS = Tuple[BUCK, BUCK]           # (neg_bucket, pos_bucket)


@dataclass(slots=True)
class RowFaces:
    x0: FACE
    x1: FACE
    y0: FACE
    y1: FACE
    z0: FACE
    z1: FACE

    def faces_for_axis(self, ax: int) -> FACES:
        # Return in "search order": try +face first then -face,
        # matching merge logic that usually wants touching faces.
        if ax == 0:
            return (self.x1, self.x0)
        if ax == 1:
            return (self.y1, self.y0)
        if ax == 2:
            return (self.z1, self.z0)
        raise ValueError("axis must be 0,1,2")


class MDX:
    AX_X = 0
    AX_Y = 1
    AX_Z = 2
    ALLAXIS = (AX_X, AX_Y, AX_Z)

    def __init__(self, rows: "ROWS" = None) -> None:
        self.rows = rows
        self.init()

    def init(self) -> None:
        self.neg: Tuple[BUCK, BUCK, BUCK] = (defaultdict(set), defaultdict(set), defaultdict(set))
        self.pos: Tuple[BUCK, BUCK, BUCK] = (defaultdict(set), defaultdict(set), defaultdict(set))
        self._faces: Dict[Loc, RowFaces] = {}

    # ============================================================
    # face building
    # ============================================================

    def _build_faces(self, mid: int, row: NDARR) -> RowFaces:
        x0, y0, z0 = ROW.P0(row=row)
        x1, y1, z1 = ROW.P1(row=row)

        fx0: FACE = (mid, y0, y1, z0, z1, x0)
        fx1: FACE = (mid, y0, y1, z0, z1, x1)

        fy0: FACE = (mid, x0, x1, z0, z1, y0)
        fy1: FACE = (mid, x0, x1, z0, z1, y1)

        fz0: FACE = (mid, x0, x1, y0, y1, z0)
        fz1: FACE = (mid, x0, x1, y0, y1, z1)

        return RowFaces(x0=fx0, x1=fx1, y0=fy0, y1=fy1, z0=fz0, z1=fz1)

    # ============================================================
    # insert / remove
    # ============================================================

    def insert(self, row: Row=None) -> None:
        mid, rid, row = int(row.mid), int(row.rid), row.row
        loc: Loc = (mid, rid)

        faces = self._build_faces(mid=mid, row=row)
        self._faces[loc] = faces

        # X axis
        self.neg[self.AX_X][faces.x0].add(loc)
        self.pos[self.AX_X][faces.x1].add(loc)
        # Y axis
        self.neg[self.AX_Y][faces.y0].add(loc)
        self.pos[self.AX_Y][faces.y1].add(loc)
        # Z axis
        self.neg[self.AX_Z][faces.z0].add(loc)
        self.pos[self.AX_Z][faces.z1].add(loc)

    def remove(self, row: Row=None) -> None:
        mid, rid = int(row.mid), int(row.rid)
        loc: Loc = (mid, rid)

        faces = self._faces.pop(loc, None)
        if faces is None:
            return

        self._discard(self.neg[self.AX_X], faces.x0, loc)
        self._discard(self.pos[self.AX_X], faces.x1, loc)

        self._discard(self.neg[self.AX_Y], faces.y0, loc)
        self._discard(self.pos[self.AX_Y], faces.y1, loc)

        self._discard(self.neg[self.AX_Z], faces.z0, loc)
        self._discard(self.pos[self.AX_Z], faces.z1, loc)

    @staticmethod
    def _discard(m: BUCK, key: FACE, loc: Loc) -> None:
        s = m.get(key)
        if not s:
            return
        s.discard(loc)
        if not s:
            del m[key]

    # ============================================================
    # adjacency search
    # ============================================================

    def search(self, r: Row, axis: int) -> Optional[Row]:
        """
        Find ONE merge-candidate neighbor (same material) touching on `axis`.

        Returns:
            Row(mid, rid, row_view) or None
        """
        if axis not in (0, 1, 2):
            raise ValueError("axis must be 0,1,2")

        mid, rid = int(r.mid), int(r.rid)
        loc: Loc = (mid, rid)

        faces = self._faces.get(loc)
        if faces is None:
            return None

        face_pos, face_neg = faces.faces_for_axis(axis)
        bucks: BUCKS = (self.neg[axis], self.pos[axis])

        # Try +face then -face (or whatever order faces_for_axis returns)
        for face_key, bucket in ((face_pos, bucks[0]), (face_neg, bucks[1])):
            candidates = bucket.get(face_key)
            if not candidates:
                continue

            # return the first other loc
            for (pmid, prid) in candidates:
                if (pmid, prid) != loc:
                    row = self.rows.array[int(pmid)][int(prid)]
                    return Row(mid=int(pmid), rid=int(prid), row=row)

        return None

################################################################################
# FILE 27/42: utils/mdx.py (END)
################################################################################


################################################################################
# FILE 28/42: utils/request.py (START)
################################################################################

import time
import urllib.request
import urllib.error
import json


class Request:
    def __init__(self, url: str = None, timeout: int = 600, retries: int = 3, data=None, method: str = None) -> None:
        self.timeout = timeout
        self.retries = retries
        self._retries = retries
        self.url = url
        self.data = data
        self.method = method

        self.init()

    def init(self) -> None:
        self.request = urllib.request.Request(url=self.url, data=self.data, method=self.method)

    def header(self, key: str = None, value: str = None) -> None:
        self.request.add_header(key, value)

    def open(self) -> dict:
        try:
            with urllib.request.urlopen(self.request, timeout=self.timeout) as response:
                raw = response.read().decode("utf-8", errors="replace")
                try:
                    return json.loads(raw) if raw else {}
                
                except json.JSONDecodeError as e:
                    raise RuntimeError(f"[ERROR] invalid JSON response for {self.url}\n{e!r}\n---\n{raw[:200]}") from e

        except urllib.error.HTTPError as e:
            raw = e.read().decode("utf-8", errors="replace")
            retryable = (e.code == 429) or (500 <= e.code <= 599)

            if retryable and self.retries > 0:
                self.retries -= 1
                time.sleep(0.5 * (2 ** (self._retries - self.retries)))
                return self.open()
            raise RuntimeError(f"[ERROR] {e.code} for {self.url}\n{raw}") from e

        except (urllib.error.URLError, TimeoutError, OSError) as e:
            if self.retries > 0:
                self.retries -= 1
                time.sleep(0.5 * (2 ** (self._retries - self.retries)))
                return self.open()
            raise RuntimeError(f"[ERROR] request failed for {self.url}\n{e!r}") from e
        
        except Exception as e:
            raise RuntimeError(f"[ERROR] unexpected error for {self.url}\n{e!r}") from e

################################################################################
# FILE 28/42: utils/request.py (END)
################################################################################


################################################################################
# FILE 29/42: utils/schedule.py (START)
################################################################################

import threading
from typing import Any, Callable, Optional
import heapq
from .timer import Timer, now
from .event import Event, Handler



class Schedule:
    def __init__(self) -> None:
        self._timer = Timer()

        self._lock = threading.Lock()
        self._cv = threading.Condition(self._lock)
        self._pq: list[Event] = []
        self._seq = 0

        self._worker: Optional[threading.Thread] = None
        self._stop = False
        self._running = False

        self.start()

    def start(self) -> None:
        with self._lock:
            if self._running:
                return
            self._stop = False
            self._worker = threading.Thread(target=self._run, name="SchedulerWorker", daemon=True)
            self._running = True
            self._worker.start()

    def stop(self) -> None:
        with self._lock:
            if not self._running:
                return
            self._stop = True
            self._cv.notify_all()

        if self._worker:
            self._worker.join(timeout=2.0)

        with self._lock:
            self._running = False
            self._worker = None

    def schedule(self, ns: int=None, fn: Callable[..., Any]=None, *args: Any, **kwargs: Any) -> Handler:
        with self._lock:
            self._seq += 1
            ev = Event(due_ns=ns, seq=self._seq, callback=fn, args=args, kwargs=kwargs)
            heapq.heappush(self._pq, ev)
            self._cv.notify_all()
            return Handler(self, ev)

    def new(self, seconds:float=None, fn:Callable[..., Any]=None, delay=False, *args: Any, **kwargs: Any) -> Handler:
        if delay==True:
            ns = now() + int(seconds * 1e9)
        if delay==False:
            ns = int(seconds * 1e9)
        return self.schedule(ns=ns, fn=fn, *args, **kwargs)
    

    def cancel(self, handle: Handler) -> bool:
        with self._lock:
            if handle._event.cancelled:
                return False
            handle._event.cancelled = True
            self._cv.notify_all()
            return True

    def _run(self) -> None:
        while True:
            with self._lock:
                # Wait until there is work or stop requested
                while not self._pq and not self._stop:
                    self._cv.wait()

                if self._stop:
                    return

                # Drop cancelled events at head
                while self._pq and self._pq[0].cancelled:
                    heapq.heappop(self._pq)

                if not self._pq:
                    continue

                ev = self._pq[0]
                due = ev.due_ns

            # 2) Wait until deadline (no lock held)
            self._timer.waitns(due)

            # 3) Pop-and-execute if still valid
            with self._lock:
                if self._stop:
                    return

                if not self._pq:
                    continue
                if self._pq[0] is not ev:
                    continue

                heapq.heappop(self._pq)
                if ev.cancelled:
                    continue

            try:
                ev.callback(*ev.args, **ev.kwargs)
            except Exception as e:
                # Keep scheduler alive; replace with logging if desired
                print(f"[Schedule] callback error: {e!r}")






















# ============================================================
# Example usage
# ============================================================

if __name__ == "__main__":
    import time

    sched = Schedule()
    def hello(who:str=None, n:int=1) -> None:
        print(f"{time.perf_counter():.3f} hello {who} x{n}")
    def test(who:str=None,  n:int=1) -> None:
        print(who, n*n)

    h1 = sched.new(seconds=0.050, fn=test, who="A", n=2, delay=True)
    h2 = sched.new(seconds=0.120, fn=hello, who="B", n=3, delay=True)
    h3 = sched.new(seconds=0.080, fn=test, who="C", n=1, delay=True)
    h2.cancel()
    futuretime = time.perf_counter() + 0.100
    h4 = sched.new(seconds=futuretime, fn=hello, who="D", n=4, delay=False)
    h5 = sched.new(seconds=futuretime, fn=test, who="E", n=5, delay=False)
    h6 = sched.new(seconds=futuretime, fn=hello, who="F", n=6, delay=False)


    time.sleep(0.2)
    sched.stop()

################################################################################
# FILE 29/42: utils/schedule.py (END)
################################################################################


################################################################################
# FILE 30/42: utils/timer.py (START)
################################################################################

from __future__ import annotations
import time



class Timer:
    def __init__(self) -> None:
        self.coarse_ns = 2_000_000
        self.spin_ns = 1_000_000

        self.start()

    def nowns(self) -> int:  # can be used as Timer().nowns()
        return time.perf_counter_ns()
    
    @staticmethod   # can be used as Timer.now()
    def now() -> float:
        return time.perf_counter_ns()

    def start(self) -> int:
        self.started = self.nowns()
        self.t0 = self.started
        self.delta = []
        self.times = []
        return self.t0
    
    def lap(self) -> int:
        t1 = self.nowns()
        t0 = self.t0
        self.t0 = t1
        dt = round((t1 - t0) / 1e9, 6) # seconds
        self.delta.append(dt)
        self.times.append(t1)
        return dt       # time since last lap in seconds
    
    def stop(self) -> int:
        self.lap()
        first = self.started
        last = self.times[-1]
        t = round((last - first) / 1e9, 6) # seconds with 6 decimal places (microseconds) 
        return t        # total since started
    
    def print(self, msg:str=None) -> None:
        self.lap()
        txt = f"lap {len(self.delta)}: {self.delta[-1]} seconds"
        if msg is not None:
            txt = f"{msg}: {txt}"
        print(txt)

    def waitns(self, deadline_ns: int) -> None:
        coarse_ns = self.coarse_ns
        spin_ns = self.spin_ns

        while True:
            n = self.nowns()
            remaining = deadline_ns - n
            if remaining <= 0:
                return

            # FAR: sleep until within coarse_ns
            if remaining > coarse_ns:
                time.sleep((remaining - coarse_ns) / 1e9)
                continue

            # NEAR: yield until within spin_ns
            if remaining > spin_ns:
                time.sleep(0)
                continue

            # FINAL: busy-spin
            while self.nowns() < deadline_ns:
                pass
            return

    def wait(self, seconds: float) -> None:
        if seconds <= 0:
            return
        self.waitns(self.nowns() + int(seconds * 1e9))

    def reset(self) -> int:
        t = self.stop()
        self.start()
        return t  # total since started before reset


now = Timer.now # now: now() returns the current time in nanoseconds

################################################################################
# FILE 30/42: utils/timer.py (END)
################################################################################


################################################################################
# FILE 31/42: utils/types.py (START)
################################################################################

from typing import TypeAlias
from numpy.typing import NDArray
import numpy as np

POS: TypeAlias = tuple[int, int, int]
SIZE: TypeAlias = tuple[int, int, int]
NDARR = NDArray[np.uint64]
REQS = tuple[NDARR, dict[int, int]]

from dataclasses import dataclass
@dataclass(slots=True)
class Row:
    mid: int
    rid: int
    row: NDARR

__all__ = [
    "POS",
    "SIZE",
    "NDARR",
    "REQS",
    "Row",
]

################################################################################
# FILE 31/42: utils/types.py (END)
################################################################################


################################################################################
# FILE 32/42: world/__init__.py (START)
################################################################################


from .buildings import *
from .buildings import __all__ as allbuildings

from .resources import *
from .resources import __all__ as allresources

from .rows import ROWS
from .row import ROW
from .materials import MATERIALS, Materials, Material

__all__ = [
    "MATERIALS",
    "Materials",
    "Material",
    "ROW",
    "ROWS",
] 

__all__.extend(allbuildings)
__all__.extend(allresources)

################################################################################
# FILE 32/42: world/__init__.py (END)
################################################################################


################################################################################
# FILE 33/42: world/buildings/__init__.py (START)
################################################################################


from .miner import Miner
from .factory import Factory
from .warehouse import Warehouse



__all__ = [
    "Miner",    
    "Factory",
    "Warehouse",
]

################################################################################
# FILE 33/42: world/buildings/__init__.py (END)
################################################################################


################################################################################
# FILE 34/42: world/buildings/factory.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from world.rows import ROWS



from .warehouse import Warehouse
from utils.types import POS



class Recipe:
    def __init__(self, ins:dict[str,int]=None, outs:dict[str,int]=None, ticks:int=0) -> None:
        self.ins:dict[str,int] = ins if ins is not None else {}
        self.outs:dict[str,int] = outs if outs is not None else {}

        self.ticks:int = ticks

        self.init()

    def init(self) -> None:
        self.tick = 0

    def ready(self) -> Recipe|None:
        self.tick += 1
        if self.tick >= self.ticks:
            self.tick = 0
            return self
        return None    



class Factory:    
    def __init__(self, rows:ROWS=None, pos:POS=None, recipe:Recipe=None, warehouse:Warehouse=None) -> None:
        self.rows:ROWS      = rows
        self.pos:POS        = pos 
        self.recipe:Recipe  = recipe
        self.warehouse:Warehouse = warehouse

    def update(self) -> None:
        if self.canproduce():
            self.produce(self.recipe)

    def canproduce(self) -> bool:
        canproduce = False
        if self.recipe.ready():
            if self.enoughmats():
                canproduce = True
        return canproduce
    
    def enoughmats(self, mat:str=None, amount:int=None) -> bool:
        enough: bool = True
        for mat, amount in self.recipe.ins.items():
            if self.warehouse.rows.materials.get(mat, 0) < amount:
                enough = False
                break
        return enough
              
            

################################################################################
# FILE 34/42: world/buildings/factory.py (END)
################################################################################


################################################################################
# FILE 35/42: world/buildings/miner.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from world.rows import ROWS


from utils.types import POS, SIZE









class Miner:
    id = 0
    def __init__(self, rows:ROWS=None, pos:POS=None, size:SIZE=None, seconds:int=1) -> None:
        self.rows:ROWS      = rows
        self.pos:POS        = pos
        self.size:SIZE      = size
        self.seconds:int    = seconds

        self.init()

    def init(self) -> None:
        self.id:int         = self.getid()
        self.nframes:int    = self.seconds * 60
        self.frame:int      = self.getframe()

        self.minepos0:POS    = self.pos
        self.minepos1:POS    = (self.pos[0]+self.size[0]-1, self.pos[1]+self.size[1]-1, self.pos[2]+self.size[2]-1)
        self.minepos:POS     = self.minepos0

    def getid(self) -> int:
        id: int = Miner.id
        Miner.id += 1
        return id
    
    def getframe(self) -> int:
        frame:int = self.id % self.nframes
        return frame
    
    def getnext(self) -> POS:
        x0, y0, z0 = self.minepos0
        x1, y1, z1 = self.minepos1
        x, y, z = self.minepos

        pos:POS = (x, y, z) # will be returned to be mined

        x += 1
        if x > x1: 
            x, y = x0, y + 1
            if y > y1: 
                y, z = y0, z + 1
                if z > z1: 
                    z = z0

        self.minepos = (x, y, z)    # update to next position
        return pos
    
    def mine(self, frame:int=None) -> None:
        if frame is None:
            raise ValueError("frame must be specified")
        if frame % self.nframes == self.frame:
            self.rows.split(pos=self.getnext(), mat="AIR")

    

################################################################################
# FILE 35/42: world/buildings/miner.py (END)
################################################################################


################################################################################
# FILE 36/42: world/buildings/warehouse.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING, TypeAlias

if TYPE_CHECKING:
    from world.rows import ROWS
    from utils.types import SIZE, POS



from world.resources import Resource, Resources


class Warehouse:
    def __init__(self, rows:ROWS=None, pos:POS=None, size:SIZE=None) -> None:
        self.rows:ROWS = rows
        self.pos:POS = pos
        self.size:SIZE = size
        self.init()

    def init(self) -> None:
        self.cap:int = self.size[0] * self.size[1] * self.size[2] * 64
        self.rez: Resources = Resources()

    def total(self) -> int:
        return self.rez.total()

    def free(self) -> int:
        return self.cap - self.total()

    def fits(self, res:Resource=None) -> bool:
        if res is None:
            raise ValueError("[VALUE ERROR] Warehouse.fits(): res is None")
        res.validate()
        return self.free() >= res.amount
    
    def get(self, mat:str=None) -> Resource:
        if mat is None:
            raise ValueError("[VALUE ERROR] Warehouse.get(): mat is None")
        return self.rez.get(mat=mat)

    def has(self, res:Resource=None) -> tuple[Resource, Resource]:
        if res is None:
            raise ValueError("[VALUE ERROR] Warehouse.has(): res is None")
        res.validate()
        available = self.rez.rez.get(res.mat, Resource(mat=res.mat, amount=0)).copy()
        want = res.copy()
        return available, want
    
    def split(self, request:Resource=None) -> tuple[Resource, Resource]:
        if request is None:
            raise ValueError("[VALUE ERROR] Warehouse.split(): request is None")
        request.validate()
        requested, stock = self.get(mat=request.mat).split(value=request.amount) # part1 is what we give, part2 is what remains
        return requested, stock

    def give(self, incoming:Resource=None) -> Resource:
        if incoming is None:
            raise ValueError("[VALUE ERROR] Warehouse.give(): incoming is None")
        incoming.validate()
        give, notgive = incoming.split(value=self.free() if self.free() > 0 else 0)  # <-- unpack order matters!
        self.rez += give   # transfer stored into warehouse (stored becomes 0)
        return notgive      # what could NOT be stored

    def take(self, requested:Resource=None) -> Resource:
        if requested is None:
            raise ValueError("[VALUE ERROR] Warehouse.take(): requested is None")
        requested.validate()
        return self.split(request=requested)[0] # what we can provide

################################################################################
# FILE 36/42: world/buildings/warehouse.py (END)
################################################################################


################################################################################
# FILE 37/42: world/materials.py (START)
################################################################################
















class MATERIALS:
    """
    PRIVATE:
    -> Use the Materials class for lookups.
    """
    TYPES = {
        "INVIS": 0,     # start at 16384                # invisible
        "TRANS": 1,     # start at 32768                # transparent
        "SOLID": 2,     # start at 65536                # solid
        "ROCKS": 3,     # start at 4294967296           # indestructible
    }

    DATA  = {
        "AIR":      (16384+0,     TYPES["INVIS"]),    

        "WATER":    (32768+0,     TYPES["TRANS"]), 
        "LAVA":     (32768+1,     TYPES["TRANS"]),
        "GLASS":    (32768+2,     TYPES["TRANS"]),

        "STONE":    (65536+0,     TYPES["SOLID"]),
        "OBSIDIAN": (65536+1,     TYPES["SOLID"]),

        "BEDROCK":  (4294967296+0,TYPES["ROCKS"]),
    }

    MID = {name: i for i, name in enumerate(DATA.keys())}
    NUM = len(DATA)

class Material:
    """
    PRIVATE:
    -> Use the Materials class for lookups.
    """
    def __init__(self, name:str=None) -> None:
        self.idx, self.type = MATERIALS.DATA.get(name, (None, None)) 
        self.mid = MATERIALS.MID.get(name, None) 
        if self.mid is None or self.type is None or self.idx is None:
            raise ValueError(f"Invalid material name: {name}")

    def isrocks(self) -> bool:
        return self.type == MATERIALS.TYPES["ROCKS"]

    def issolid(self) -> bool:
        return self.type == MATERIALS.TYPES["SOLID"]
    
    def istrans(self) -> bool:
        return self.type == MATERIALS.TYPES["TRANS"]
    
    def isinvisible(self) -> bool:
        return self.type == MATERIALS.TYPES["INVIS"]
    
    def isindestructible(self) -> bool:
        return self.type == MATERIALS.TYPES["ROCKS"]

class Materials:
    """
    PRIVATE:
    -> Various material lookup dictionaries for name, mid, and idx.
    """
    mid2name = {idx: name for name, idx in MATERIALS.MID.items()}
    name2mid = MATERIALS.MID
    name2idx  = {name: pair[0] for name, pair in MATERIALS.DATA.items()}
    idx2name  = {pair[0]: name for name, pair in MATERIALS.DATA.items()}
    idx2mid   = {pair[0]: MATERIALS.MID[name] for name, pair in MATERIALS.DATA.items()}
    mid2idx   = {MATERIALS.MID[name]: pair[0] for name, pair in MATERIALS.DATA.items()}
    """
    PRIVATE END
    """

    def __init__(self) -> None:
        for name in MATERIALS.DATA.keys():
            setattr(self, name.lower(), Material(name=name))

    def idx(self, name:str=None, mid:int=None) -> int:
        """
        PUBLIC:
        -> Get the material index (idx) given either the material name or mid.
        -> Provide exactly one of name or mid.
        """
        if (name is None) == (mid is None):
            raise ValueError("Provide exactly one of name or mid")
        return self.name2idx[name] if name is not None else self.mid2idx[mid]

    def mid(self, name:str=None, idx:int=None) -> int:
        """
        PUBLIC:
        -> Get the material ID (mid) given either the material name or idx.
        -> Provide exactly one of name or idx.
        """
        if (name is None) == (idx is None):
            raise ValueError("Provide exactly one of name or idx")
        return self.name2mid[name] if name is not None else self.idx2mid[idx]

    def name(self, mid:int=None, idx:int=None) -> str:
        """
        PUBLIC:
        -> Get the material name given either the material ID (mid) or idx.
        -> Provide exactly one of mid or idx.
        """
        if (mid is None) == (idx is None):
            raise ValueError("Provide exactly one of mid or idx")
        return self.mid2name[mid] if mid is not None else self.idx2name[idx]
    
    def mat(self, mat:str=None, mid:int=None, idx:int=None) -> Material:
        """
        PUBLIC:
        -> Get the Material object given either the material name, mid, or idx.
        -> Provide exactly one of mat, mid, or idx.
        """
        if mid is not None:
            mat: str = self.mid2name.get(mid)
        if idx is not None:
            mat: str = self.idx2name.get(idx)
        return getattr(self, mat.lower())
        
        if name is not None:
            return Material(name=name)
        elif mid is not None:
            name = self.mid2name.get(mid, None)
            if name is None:
                raise ValueError(f"Invalid material mid: {mid}")
            return Material(name=name)
        else:  # idx is not None
            name = self.idx2name.get(idx, None)
            if name is None:
                raise ValueError(f"Invalid material idx: {idx}")
            return Material(name=name)
    
    def names(self) -> list[str]:
        """
        PUBLIC:
        -> Get a list of all material names.
        """
        return list(MATERIALS.DATA.keys())
    
    def idxs(self) -> list[int]:
        """
        PUBLIC:
        -> Get a list of all material indices (idx).
        """
        return [pair[0] for pair in MATERIALS.DATA.values()]
    
    def mids(self) -> list[int]:
        """
        PUBLIC:
        -> Get a list of all material IDs (mid).
        """
        return list(MATERIALS.MID.values())

################################################################################
# FILE 37/42: world/materials.py (END)
################################################################################


################################################################################
# FILE 38/42: world/resources/__init__.py (START)
################################################################################

from .resource import Resource, RESOURCELIKE
from .resources import Resources

__all__ = [
    "Resource",
    "Resources",
    "RESOURCELIKE",
]

################################################################################
# FILE 38/42: world/resources/__init__.py (END)
################################################################################


################################################################################
# FILE 39/42: world/resources/resource.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING, TypeAlias
if TYPE_CHECKING:
    from.resources import Resources





RESOURCELIKE: TypeAlias = "Resource | Resources | list[Resource] | tuple[Resource, ...] | set[Resource] | dict[str, Resource] | None"


class Resource:
    def __init__(self, mat:str=None, amount:int=0) -> None:
        self.mat:str = mat
        self.amount:int = amount
        self.validate()

    def validate(self) -> Resource:
        if self.mat is None:
            raise ValueError("[VALUE ERROR] Resource.validate(): mat is None")
        if self.amount < 0:
            raise ValueError(f"[VALUE ERROR] Resource.validate(): amount out of bounds: {self.amount}")
        return self

    def compatible(self, other:Resource=None) -> bool:
        if isinstance(other, Resource):
            self.validate()
            other.validate()
            if self.mat == other.mat:
                return True
        raise ValueError(f"[VALUE ERROR] Resource.compatible(): incompatible resources: {self} vs {other}")

    def copy(self) -> Resource:
        return Resource(mat=self.mat, amount=self.amount)

    def __copy__(self) -> Resource:
        return self.copy()

    def __deepcopy__(self, memo) -> Resource:
        return self.copy()

    # ------------------------------------------------------------
    # Semantics requested:
    #
    # a + b  : b does NOT mutate, a DOES mutate (adds b.amount)
    # a += b : transfer; a increases, b becomes 0
    #
    # a - b  : b does NOT mutate, a DOES mutate (subtract up to b.amount)
    # a -= b : transfer-like; a decreases, b becomes "remaining" demand
    #          (b ends up 0 if a had enough, else b keeps leftover)
    # ------------------------------------------------------------

    def __add__(self, other:Resource=None) -> Resource:
        if self.compatible(other=other):
            self.amount += other.amount
        return self.validate()

    def __iadd__(self, other:Resource=None) -> Resource:
        if self.compatible(other=other):
            self.amount += other.amount
            other.amount = 0
            other.validate()
        return self.validate()

    def __sub__(self, other:Resource=None) -> Resource:
        if self.compatible(other=other):
            take = other.amount
            if self.amount < take:
                take = self.amount
            self.amount -= take
        return self.validate()

    def __isub__(self, other:Resource=None) -> Resource:
        if self.compatible(other=other):
            take = other.amount
            if self.amount < take:
                take = self.amount
            self.amount -= take
            other.amount -= take
            other.validate()
        return self.validate()

    # ---------------- comparisons (same-material only) ----------------

    def __lt__(self, other:Resource=None) -> bool:
        if self.compatible(other=other):
            return self.amount < other.amount
        return False

    def __le__(self, other:Resource=None) -> bool:
        if self.compatible(other=other):
            return self.amount <= other.amount
        return False

    def __gt__(self, other:Resource=None) -> bool:
        if self.compatible(other=other):
            return self.amount > other.amount
        return False

    def __ge__(self, other:Resource=None) -> bool:
        if self.compatible(other=other):
            return self.amount >= other.amount
        return False

    def __eq__(self, other:object=None) -> bool:
        if not isinstance(other, Resource):
            return False
        if self.mat != other.mat:
            return False
        return self.amount == other.amount

    def __ne__(self, other:object=None) -> bool:
        return not self.__eq__(other)

    # ---------------- misc ----------------

    def __int__(self) -> int:
        return self.amount

    def __bool__(self) -> bool:
        self.validate()
        return True

    def __repr__(self) -> str:
        return f"Resource(mat={self.mat}, amount={self.amount})"

    def __str__(self) -> str:
        return self.__repr__()

    def sort(self, others:list[Resource]=None, reverse:bool=False) -> list[Resource]:
        if others is None:
            others = []
        for o in others:
            self.compatible(other=o)
        return sorted([self] + others, reverse=reverse)

    def split(self, value:int=None) -> list[Resource]:
        self.validate()
        if value is None or value < 0:
            raise ValueError(f"[VALUE ERROR] Resource.split(): invalid split value: {value}")

        take = min(value, self.amount)
        part1 = Resource(mat=self.mat, amount=take)
        self = self - part1
        return [part1, self]   # [before split, after split]
    

################################################################################
# FILE 39/42: world/resources/resource.py (END)
################################################################################


################################################################################
# FILE 40/42: world/resources/resources.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING, TypeAlias
if TYPE_CHECKING:
    pass

from .resource import Resource, RESOURCELIKE    


class Resources:
    def __init__(self, rez:RESOURCELIKE=None) -> None:
        self.rez: dict[str, Resource] = {}
        self.ingest(rez=rez)

    def tolist(self, rez:RESOURCELIKE=None) -> list[Resource]:
        if rez is None:
            return self.list()

        if isinstance(rez, Resource):
            return [rez]

        if isinstance(rez, Resources):
            return rez.list()

        if isinstance(rez, list):
            return rez

        if isinstance(rez, tuple):
            return list(rez)

        if isinstance(rez, set):
            return list(rez)

        if isinstance(rez, dict):
            # copy values into new Resources (do NOT mutate originals)
            return [Resource(mat=r.mat, amount=r.amount) for r in rez.values()]

        raise ValueError(f"[VALUE ERROR] Resources.tolist(): invalid type: {type(rez)}")

    def get(self, mat:str=None) -> Resource:
        if mat is None:
            raise ValueError("[VALUE ERROR] Resources.get(): mat is None")
        if mat not in self.rez:
            self.rez[mat] = Resource(mat=mat, amount=0)
        return self.rez[mat]

    def ingest(self, rez:RESOURCELIKE=None) -> None:
        for r in self.tolist(rez=rez):
            r.validate()
            cur = self.get(mat=r.mat)
            cur + r  # mutates cur only; r unchanged

    def transfer(self, rez:RESOURCELIKE=None) -> None:
        for r in self.tolist(rez=rez):
            r.validate()
            cur = self.get(mat=r.mat)
            cur += r  # transfer; r becomes 0

    def total(self) -> int:
        total = 0
        for r in self.tolist():
            total += r.amount
        return total

    def list(self) -> list[Resource]:
        return list(self.rez.values())

    def copy(self) -> Resources:
        return Resources(rez=[r.copy() for r in self.tolist()])

    def __copy__(self) -> Resources:
        return self.copy()

    def __deepcopy__(self, memo) -> Resources:
        return self.copy()

    # ------------------------------------------------------------
    # Semantics requested (for containers):
    #
    # a + b  : b does NOT mutate, a DOES mutate (adds)
    # a += b : transfer; a increases, b becomes 0 (per material)
    #
    # a - b  : b does NOT mutate, a DOES mutate (subtract up to b.amount)
    # a -= b : transfer-like; a decreases, b becomes remaining demand
    # ------------------------------------------------------------

    def __add__(self, other:RESOURCELIKE=None) -> Resources:
        self.ingest(rez=other)
        return self

    def __iadd__(self, other:RESOURCELIKE=None) -> Resources:
        self.transfer(rez=other)
        return self

    def __sub__(self, other:RESOURCELIKE=None) -> Resources:
        for r in self.tolist(rez=other):
            r.validate()
            cur = self.get(mat=r.mat)
            cur - r  # mutates cur only; r unchanged
        return self

    def __isub__(self, other:RESOURCELIKE=None) -> Resources:
        for r in self.tolist(rez=other):
            r.validate()
            cur = self.get(mat=r.mat)
            cur -= r  # mutates both: cur decreases, r becomes remaining demand
        return self

    def __bool__(self) -> bool:
        for r in self.list():
            bool(r)
        return True

    def __repr__(self) -> str:
        return f"Resources({self.list()})"

    def __str__(self) -> str:
        return self.__repr__()

################################################################################
# FILE 40/42: world/resources/resources.py (END)
################################################################################


################################################################################
# FILE 41/42: world/row.py (START)
################################################################################

from __future__ import annotations
import stat
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    pass

from utils.types import NDARR

import numpy as np


from utils.types import SIZE, POS
from world.materials import Material, Materials



mats = Materials()

class ROW:
    """
    PRIVATE VARIABLES!
    NOTES:
        - use the static methods to get stuff done!
        - do not acces these variables directly!
    PURPOSE:
        - defines the keys and structure of a ROW in the world ROWS array
    STRUCTURE:
        - each ROW is a 4x4 numpy uint64 array
        - row 0: min positions (x0, y0, z0)
        - row 1: max positions (x1, y1, z1)
        - row 2: dimensions (dx, dy, dz)
        - row 3: metadata (id, mid, flags)
    USAGE:
        - use the static methods to create, read, and manipulate ROWs
    """
    DTYPE = np.uint64
    SHAPE = (4, 4)
    NBITS = DTYPE(0).nbytes * 8                      # -> 64 bits

    XBITS = 20
    YBITS = 20
    ZBITS = 16
    if XBITS + YBITS + ZBITS + 1 > NBITS:
        raise ValueError("bit allocation error")

    XMIN = 0
    YMIN = 0
    ZMIN = 0
    XMAX = 2**XBITS
    YMAX = 2**YBITS
    ZMAX = 2**ZBITS
    NMAX = XMAX * YMAX * ZMAX


    # POSITIONS (MIN) â€” stored in row 0 (NOT FOR DIRECT USE)
    IDS_X0 = (0, 0)
    IDS_Y0 = (0, 1)
    IDS_Z0 = (0, 2)

    # POSITIONS (MAX) â€” stored in row 1 (NOT FOR DIRECT USE)
    IDS_X1 = (1, 0)
    IDS_Y1 = (1, 1)
    IDS_Z1 = (1, 2)

    # DIMENSIONS â€” stored in row 2 (NOT FOR DIRECT USE)
    IDS_DX = (2, 0)
    IDS_DY = (2, 1)
    IDS_DZ = (2, 2)

    # METADATA â€” stored in row 3 (NOT FOR DIRECT USE)
    IDS_RID    = (3, 0)
    IDS_MID   = (3, 1)
    IDS_FLAGS = (3, 2)

    # ENCODED FLAGS (NOT FOR DIRECT USE)
    ENCODE_DIRTY        = DTYPE(1 << 0)
    ENCODE_ALIVE        = DTYPE(1 << 1)
    ENCODE_SOLID        = DTYPE(1 << 2)
    ENCODE_DESTRUCTABLE = DTYPE(1 << 3)
    ENCODE_VISIBLE      = DTYPE(1 << 4)

    SENTINEL = np.iinfo(DTYPE).max
    ARRAY: NDARR = np.zeros(SHAPE, dtype=DTYPE)
    for i in range(4):
        for j in range(4):
            ARRAY[i, j] = SENTINEL  # initialize all to -1 -> invalid
    _ID = 0

    """
    PRIVATE VARIABLES END 
    """

    @staticmethod
    def X0(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: x0 position
        """
        return row[*ROW.IDS_X0]
    
    @staticmethod
    def Y0(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: y0 position
        """
        return row[*ROW.IDS_Y0]
    
    @staticmethod
    def Z0(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: z0 position
        """
        return row[*ROW.IDS_Z0]
    
    @staticmethod
    def X1(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: x1 position
        """
        return row[*ROW.IDS_X1]
    
    @staticmethod
    def Y1(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: y1 position
        """
        return row[*ROW.IDS_Y1]
    
    @staticmethod
    def Z1(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: z1 position
        """
        return row[*ROW.IDS_Z1]
    
    @staticmethod
    def DX(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: dx size
        """
        return row[*ROW.IDS_DX]
    
    @staticmethod
    def DY(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: dy size
        """
        return row[*ROW.IDS_DY]
    
    @staticmethod
    def DZ(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: dz size
        """
        return row[*ROW.IDS_DZ]
    
    @staticmethod # get min position (x0, y0, z0)  
    def P0(row:NDARR=None) -> POS:
        """
        PUBLIC!
        RETURN: (x0, y0, z0) == p0
        """
        return (ROW.X0(row=row), ROW.Y0(row=row), ROW.Z0(row=row))
    @staticmethod # get max position (x1, y1, z1)
    def P1(row:NDARR=None) -> POS:
        """
        PUBLIC!
        RETURN: (x1, y1, z1) == p1
        """
        return (ROW.X1(row=row), ROW.Y1(row=row), ROW.Z1(row=row))
    
    @staticmethod # get size (dx, dy, dz)
    def SIZE(row:NDARR=None) -> SIZE:
        """
        PUBLIC!
        RETURN: (dx, dy, dz) == size
        """
        return (ROW.DX(row=row), ROW.DY(row=row), ROW.DZ(row=row))
    
    @staticmethod # get material id
    def MID(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: material id integer (Material ID)
        """
        return row[*ROW.IDS_MID]
    
    @staticmethod # get material string name
    def MAT(row:NDARR=None) -> str:
        """
        PUBLIC!
        RETURN: material name string (Material Name)
        """
        return mats.name(mid=ROW.MID(row=row))
    
    @staticmethod # get row id
    def RID(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: row unique id integer (Row ID)
        """
        return row[*ROW.IDS_RID]
    
    @staticmethod # get flags
    def FLAGS(row:NDARR=None) -> tuple[bool, bool, bool, bool, bool]:
        """
        PUBLIC!
        RETURN: tuple of flags (dirty, alive, solid, destructable, visible)
        """
        flags: int = row[*ROW.IDS_FLAGS]
        dirty, alive, solid, destr, visib = ROW.DECODE(flags=flags)
        return (dirty, alive, solid, destr, visib)
    
    @staticmethod # get volume (dx * dy * dz)
    def VOLUME(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: volume (dx * dy * dz)
        """
        dx, dy, dz = ROW.SIZE(row=row)
        return dx * dy * dz

    @staticmethod
    def COPY() -> NDARR:
        """
        PUBLIC!
        RETURN: a copy of the ROW.ARRAY template
        USAGE: use this to create new rows
        """
        return np.copy(ROW.ARRAY)
    
    @staticmethod
    def CLIP(pos:POS=None) -> POS:
        """
        PUBLIC!
        RETURN: clipped position within world bounds
        USAGE: use this to ensure positions are within valid world limits
        """
        x, y, z = pos
        cx = min(max(x, ROW.XMIN), ROW.XMAX - 1)
        cy = min(max(y, ROW.YMIN), ROW.YMAX - 1)
        cz = min(max(z, ROW.ZMIN), ROW.ZMAX - 1)
        pos: POS = (cx, cy, cz)
        return pos
    
    @staticmethod
    def SORT(p0:POS=None, p1:POS=None) -> tuple[POS, POS]:
        """
        PUBLIC!
        RETURN: sorted positions (p0, p1) with p0 <= p1 for each coordinate
        """
        x0, y0, z0 = p0
        x1, y1, z1 = p1
        sx0, sx1 = (min(x0, x1), max(x0, x1))
        sy0, sy1 = (min(y0, y1), max(y0, y1))
        sz0, sz1 = (min(z0, z1), max(z0, z1))
        p0: POS = (sx0, sy0, sz0)
        p1: POS = (sx1, sy1, sz1)
        return (p0, p1)
    
    @staticmethod
    def CONTAINS(row: NDARR, pos: POS) -> bool:
        """
        PUBLIC!
        RETURN: whether the row contains the given position
        """
        x, y, z = pos
        x0, y0, z0 = ROW.P0(row=row)
        x1, y1, z1 = ROW.P1(row=row)
        return ((x0 <= x < x1) and (y0 <= y < y1) and (z0 <= z < z1))
    

    @staticmethod
    def MERGE(row0: NDARR=None, row1: NDARR=None) -> tuple[bool, bool, bool]:
        """
        PUBLIC!
        RETURN: tuple indicating if rows can be merged along each axis (x, y, z)
        """
        if row0[*ROW.IDS_MID] != row1[*ROW.IDS_MID]:
            return (False, False, False)

        x0a, y0a, z0a = ROW.P0(row=row0)
        x1a, y1a, z1a = ROW.P1(row=row0)
        x0b, y0b, z0b = ROW.P0(row=row1)
        x1b, y1b, z1b = ROW.P1(row=row1)
        p00 = (x0a, y0a, z0a)
        p01 = (x1a, y1a, z1a)
        p10 = (x0b, y0b, z0b)
        p11 = (x1b, y1b, z1b)

        def overlap(a0:int=None, a1:int=None, b0:int=None, b1:int=None) -> bool: return a0 < b1 and b0 < a1
        def touches(a0:int=None, a1:int=None, b0:int=None, b1:int=None) -> bool: return a1 == b0 or b1 == a0

        touching = [False, False, False]
        overlaps = [False, False, False]

        for i in range(3):
            if overlap(a0=p00[i], a1=p01[i], b0=p10[i], b1=p11[i]):
                overlaps[i] = True
            elif touches(a0=p00[i], a1=p01[i], b0=p10[i], b1=p11[i]):
                touching[i] = True
            else:
                return (False, False, False)  # separated on this axis
            
        if sum(touching) == 1 and sum(overlaps) == 2:
            return tuple(touching)  # (x_touch, y_touch, z_touch)

        return (False, False, False)
    

    @staticmethod
    def ENCODE(dirty:bool=None, alive:bool=None, solid:bool=None, destructable:bool=None, visible:bool=None) -> int:
        """
        PUBLIC!
        RETURN: encoded flags integer
        """
        f: int = 0
        if dirty:
            f |= int(ROW.ENCODE_DIRTY)
        if alive:
            f |= int(ROW.ENCODE_ALIVE)
        if solid:
            f |= int(ROW.ENCODE_SOLID)
        if destructable:
            f |= int(ROW.ENCODE_DESTRUCTABLE)
        if visible:
            f |= int(ROW.ENCODE_VISIBLE)
        return f
    

    @staticmethod
    def DECODE(flags) -> tuple[bool, bool, bool, bool, bool]:
        """
        PUBLIC!
        RETURN: tuple of flags (dirty, alive, solid, destructable, visible)
        """
        f: int = int(flags)

        dirty = (f & int(ROW.ENCODE_DIRTY)) != 0
        alive = (f & int(ROW.ENCODE_ALIVE)) != 0
        solid = (f & int(ROW.ENCODE_SOLID)) != 0
        destr = (f & int(ROW.ENCODE_DESTRUCTABLE)) != 0
        visib = (f & int(ROW.ENCODE_VISIBLE)) != 0
        return dirty, alive, solid, destr, visib


    @staticmethod
    def new(p0:POS=None, p1:POS=None, mat:str=None, rid:int=None, dirty:bool=True, alive:bool=True) -> NDARR:
        """
        PUBLIC!
        RETURN: a new ROW with given parameters
        """
        p0, p1 = ROW.SORT(p0=ROW.CLIP(pos=p0), p1=ROW.CLIP(pos=p1))
        
        mat: Material = mats.mat(mat=mat)
        flags: int = ROW.ENCODE(dirty=dirty, alive=alive, solid=mat.issolid(), destructable=not mat.isindestructible(), visible=not mat.isinvisible())
        copy: NDARR = ROW.COPY()

        # POS0
        copy[*ROW.IDS_X0]    = np.uint64(p0[0])
        copy[*ROW.IDS_Y0]    = np.uint64(p0[1])
        copy[*ROW.IDS_Z0]    = np.uint64(p0[2])
        # POS1
        copy[*ROW.IDS_X1]    = np.uint64(p1[0])
        copy[*ROW.IDS_Y1]    = np.uint64(p1[1])
        copy[*ROW.IDS_Z1]    = np.uint64(p1[2])
        # SIZE
        copy[*ROW.IDS_DX]    = np.uint64(p1[0] - p0[0])
        copy[*ROW.IDS_DY]    = np.uint64(p1[1] - p0[1])
        copy[*ROW.IDS_DZ]    = np.uint64(p1[2] - p0[2])
        # METADATA
        copy[*ROW.IDS_RID]    = np.uint64(rid)       # stores now the row index within material array instead of global unique id
        copy[*ROW.IDS_MID]   = np.uint64(mat.mid)  # material id
        copy[*ROW.IDS_FLAGS] = np.uint64(flags)

        if any(v < 0 for v in (copy[*ROW.IDS_DX], copy[*ROW.IDS_DY], copy[*ROW.IDS_DZ])):
            raise ValueError("p1 must be greater than or equal to p0 on all axes")
        if any(v < 0 for v in (copy[*ROW.IDS_X0], copy[*ROW.IDS_Y0], copy[*ROW.IDS_Z0])):
            raise ValueError("positions must be non-negative")
        return copy
    
    

################################################################################
# FILE 41/42: world/row.py (END)
################################################################################


################################################################################
# FILE 42/42: world/rows.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    pass

import numpy as np

from world.materials import Materials, MATERIALS
from world.row import ROW
from utils.bvh import BVH
from utils.mdx import MDX
from utils.types import POS, SIZE, NDARR, REQS, Row


class ROWS:
    """
    PUBLIC (human interface):
    - insert(p0:POS, p1:POS, mat:str, dirty:bool=True, alive:bool=True) -> Row
    - split(pos:POS, pos1:POS=None, mat:str=None) -> REQS
    - merge(rows:NDARR=None) -> REQS
    - volume(mat:str=None) -> int
    - get(mat:str, rid:int) -> Row
    - search(pos:POS) -> tuple[str,int,NDARR]   <-- matches tests

    INTERNAL:
    - remove(row:Row) -> None
    - merge2(row0:Row, row1:Row) -> REQS
    """

    SIZE = 65536

    def __init__(self)->None:
        self.mat = Materials()
        self.bvh = BVH(rows=self)
        self.mdx = MDX(rows=self)

        self.total = 0
        self.array, self.arids = self.reqs(n=ROWS.SIZE)

        self.shape = self.array.shape
        self.nbytes = self.array.nbytes
        self.gbytes = self.nbytes / (1024**3)

        self.p0 = (ROW.XMIN, ROW.YMIN, ROW.ZMIN)
        self.p1 = (ROW.XMAX, ROW.YMAX, ROW.ZMAX)

        # default world row
        self.insert(p0=self.p0, p1=self.p1, mat="STONE")

    # ============================================================
    # allocation / counters
    # ============================================================

    def reqs(self, n:int=None)->REQS:
        n = int(n) if n is not None else 0
        array = np.full(
            (MATERIALS.NUM, n, *ROW.SHAPE),
            fill_value=ROW.SENTINEL,
            dtype=ROW.DTYPE
        )
        arids:dict[int,int] = {mid: 0 for mid in range(MATERIALS.NUM)}
        return (array, arids)

    def newn(self, mat:str=None)->int:
        if mat is None:
            raise ValueError("newn requires mat")
        mid = int(self.mat.mid(name=mat))
        rid = int(self.arids[mid])
        self.arids[mid] += 1
        self.total += 1
        return rid

    def deln(self, mat:str=None)->int:
        if mat is None:
            raise ValueError("deln requires mat")
        mid = int(self.mat.mid(name=mat))
        if self.arids[mid] <= 0:
            raise ValueError("no rows to free")
        self.arids[mid] -= 1
        self.total -= 1
        return int(self.arids[mid])

    def nrows(self, mat:str=None, mid:int=None)->int:
        if mid is None:
            if mat is None:
                raise ValueError("nrows requires mat or mid")
            mid = int(self.mat.mid(name=mat))
        return int(self.arids[int(mid)])

    # ============================================================
    # Row helpers
    # ============================================================

    def get(self, mat:str=None, rid:int=None)->Row:
        if mat is None or rid is None:
            raise ValueError("get requires mat and rid")
        mid = int(self.mat.mid(name=mat))
        rid = int(rid)
        return Row(mid=mid, rid=rid, row=self.array[mid][rid])

    # ============================================================
    # core ops
    # ============================================================

    def insert(self, p0:POS=None, p1:POS=None, mat:str=None,
               dirty:bool=True, alive:bool=True)->Row:
        if mat is None:
            raise ValueError("insert requires mat")

        rid = self.newn(mat=mat)
        raw:NDARR = ROW.new(p0=p0, p1=p1, mat=mat, rid=rid, dirty=dirty, alive=alive)

        mid = int(ROW.MID(row=raw))
        rid = int(ROW.RID(row=raw))

        # IMPORTANT FIX: actually write RAW into the storage slot
        slot = self.array[mid][rid]
        slot[:] = raw

        stored = Row(mid=mid, rid=rid, row=slot)

        # index the stored row
        self.bvh.insert(row=stored)
        self.mdx.insert(row=stored)
        return stored

    def remove(self, row:Row=None)->None:
        if row is None:
            raise ValueError("remove requires row")

        mid = int(row.mid)
        rid = int(row.rid)
        mat_name = self.mat.name(mid=mid)

        n = self.nrows(mid=mid)
        last = n - 1

        # remove target from indices
        self.bvh.remove(row=row)
        self.mdx.remove(row=row)

        if rid != last:
            # remove moved's old identity from indices
            moved_old = Row(mid=mid, rid=last, row=self.array[mid][last])
            self.bvh.remove(row=moved_old)
            self.mdx.remove(row=moved_old)

            # move data
            moved_data = self.array[mid][last].copy()
            moved_data[*ROW.IDS_RID] = np.uint64(rid)   # fix payload rid
            self.array[mid][rid][:] = moved_data

            moved_new = Row(mid=mid, rid=rid, row=self.array[mid][rid])
            self.bvh.insert(row=moved_new)
            self.mdx.insert(row=moved_new)

        # invalidate last
        self.array[mid][last][:] = ROW.ARRAY
        self.deln(mat=mat_name)

    # ============================================================
    # queries
    # ============================================================

    def size(self)->SIZE:
        return (self.p1[0]-self.p0[0], self.p1[1]-self.p0[1], self.p1[2]-self.p0[2])

    def volume(self, mat:str=None)->int:
        if mat is None:
            total = 0
            for mid in range(MATERIALS.NUM):
                total += self.volume(mat=self.mat.name(mid=mid))
            return int(total)

        mid = int(self.mat.mid(name=mat))
        total = 0
        n = self.nrows(mid=mid)
        for rid in range(n):
            # cast to int so Python doesn't keep uint64 overflow semantics
            total += int(ROW.VOLUME(row=self.array[mid][rid]))
        return int(total)

    def search(self, pos:POS=None)->tuple[str,int,NDARR]:
        if pos is None:
            raise ValueError("search requires pos")
        hit:Row = self.bvh.search(pos=pos)               # BVH returns Row(mid,rid,row)
        mat = self.mat.name(mid=int(hit.mid))
        return (mat, int(hit.rid), hit.row)

    # ============================================================
    # split
    # ============================================================

    def splitrow(self, pos:POS=None, p2:POS=None, mat:str=None)->REQS:
        if pos is None or p2 is None or mat is None:
            raise ValueError("splitrow requires pos,p2,mat")

        mat0, _, hitrow = self.search(pos=pos)

        r0 = ROW.P0(row=hitrow)
        r1 = ROW.P1(row=hitrow)

        x0,y0,z0 = r0
        x3,y3,z3 = r1
        x1,y1,z1 = pos
        x2,y2,z2 = p2

        x1=max(x0,min(x1,x3)); x2=max(x0,min(x2,x3))
        y1=max(y0,min(y1,y3)); y2=max(y0,min(y2,y3))
        z1=max(z0,min(z1,z3)); z2=max(z0,min(z2,z3))

        xs=((x0,x1),(x1,x2),(x2,x3))
        ys=((y0,y1),(y1,y2),(y2,y3))
        zs=((z0,z1),(z1,z2),(z2,z3))

        array, arids = self.reqs(n=27)

        for i,(X0,X1) in enumerate(xs):
            for j,(Y0,Y1) in enumerate(ys):
                for k,(Z0,Z1) in enumerate(zs):
                    if (X1-X0)<=0 or (Y1-Y0)<=0 or (Z1-Z0)<=0:
                        continue

                    center = (i==1 and j==1 and k==1)
                    use_mat = mat if center else mat0

                    newrow = self.insert(p0=(X0,Y0,Z0), p1=(X1,Y1,Z1), mat=use_mat)
                    mid_new = int(newrow.mid)

                    array[mid_new][arids[mid_new]] = newrow.row
                    arids[mid_new] += 1

        # remove the hit row (need Row object for indices)
        hit_mid = int(ROW.MID(row=hitrow))
        hit_rid = int(ROW.RID(row=hitrow))
        self.remove(row=Row(mid=hit_mid, rid=hit_rid, row=hitrow))

        return (array, arids)

    def split1(self, pos:POS=None, mat:str=None)->REQS:
        if pos is None or mat is None:
            raise ValueError("split1 requires pos,mat")
        p2 = (pos[0]+1, pos[1]+1, pos[2]+1)
        batch, _ = self.splitrow(pos=pos, p2=p2, mat=mat)
        merged, marids = self.merge(rows=batch)
        return (merged, marids)

    def split2(self, p0:POS=None, p1:POS=None, mat:str=None)->REQS:
        def intersect(a0:POS=None,a1:POS=None,b0:POS=None,b1:POS=None)->tuple[POS,POS]|None:
            q0 = (max(a0[0],b0[0]), max(a0[1],b0[1]), max(a0[2],b0[2]))
            q1 = (min(a1[0],b1[0]), min(a1[1],b1[1]), min(a1[2],b1[2]))
            if q0[0]>=q1[0] or q0[1]>=q1[1] or q0[2]>=q1[2]:
                return None
            return (q0,q1)

        if p0 is None or p1 is None or mat is None:
            raise ValueError("split2 requires p0,p1,mat")

        p0,p1 = ROW.SORT(p0=p0, p1=p1)
        if p0[0]>=p1[0] or p0[1]>=p1[1] or p0[2]>=p1[2]:
            return self.reqs(n=0)

        acc:list[list[NDARR]] = [[] for _ in range(MATERIALS.NUM)]

        _, _, hitrow = self.search(pos=p0)
        r0 = ROW.P0(row=hitrow)
        r1 = ROW.P1(row=hitrow)

        hit = intersect(a0=p0, a1=p1, b0=r0, b1=r1)
        if hit is None:
            return self.reqs(n=0)

        q0,q1 = hit
        batch,_ = self.splitrow(pos=q0, p2=q1, mat=mat)
        merged,marids = self.merge(rows=batch)

        for mid in range(MATERIALS.NUM):
            for i in range(marids[mid]):
                acc[mid].append(merged[mid][i])

        if q1[0]<p1[0]:
            b,a = self.split2(p0=(q1[0],p0[1],p0[2]), p1=p1, mat=mat)
            for mid in range(MATERIALS.NUM):
                for i in range(a[mid]):
                    acc[mid].append(b[mid][i])

        if q1[1]<p1[1]:
            b,a = self.split2(p0=(p0[0],q1[1],p0[2]), p1=(q1[0],p1[1],p1[2]), mat=mat)
            for mid in range(MATERIALS.NUM):
                for i in range(a[mid]):
                    acc[mid].append(b[mid][i])

        if q1[2]<p1[2]:
            b,a = self.split2(p0=(p0[0],p0[1],q1[2]), p1=(q1[0],q1[1],p1[2]), mat=mat)
            for mid in range(MATERIALS.NUM):
                for i in range(a[mid]):
                    acc[mid].append(b[mid][i])

        out_arids = {mid: len(acc[mid]) for mid in range(MATERIALS.NUM)}
        n = max(out_arids.values()) if out_arids else 0
        array, arids = self.reqs(n=n)

        for mid in range(MATERIALS.NUM):
            arids[mid] = out_arids[mid]
            for i,r in enumerate(acc[mid]):
                array[mid][i] = r

        return (array, arids)

    def split(self, pos:POS=None, pos1:POS=None, mat:str=None)->REQS:
        if mat is None:
            raise ValueError("material must be specified")
        if pos is None and pos1 is None:
            raise ValueError("either pos or pos1 must be provided")

        if pos is not None and pos1 is not None:
            return self.split2(p0=pos, p1=pos1, mat=mat)
        if pos is not None:
            return self.split1(pos=pos, mat=mat)
        return self.split1(pos=pos1, mat=mat)

    # ============================================================
    # merge (FIXED to match MDX.search signature)
    # ============================================================

    def merge2(self, row0:Row=None, row1:Row=None)->REQS:
        if row0 is None or row1 is None:
            return self.reqs(n=0)

        if int(row0.mid) != int(row1.mid):
            return self.reqs(n=0)

        touch = ROW.MERGE(row0=row0.row, row1=row1.row)
        if touch == (False, False, False):
            return self.reqs(n=0)

        p0 = ROW.SORT(p0=ROW.P0(row=row0.row), p1=ROW.P0(row=row1.row))[0]
        p1 = ROW.SORT(p0=ROW.P1(row=row0.row), p1=ROW.P1(row=row1.row))[1]

        # remove bigger rid first
        if int(row0.rid) > int(row1.rid):
            hi, lo = row0, row1
        else:
            hi, lo = row1, row0

        self.remove(row=hi)
        self.remove(row=lo)

        mat_name = self.mat.name(mid=int(row0.mid))
        newrow = self.insert(p0=p0, p1=p1, mat=mat_name)

        array, arids = self.reqs(n=1)
        array[int(newrow.mid)][0] = newrow.row
        arids[int(newrow.mid)] = 1
        return (array, arids)

    def mergeax(self, mat:str=None, axis:int=None)->REQS:
        if mat is None:
            raise ValueError("mergeax requires mat")
        if axis is None:
            raise ValueError("mergeax requires axis")

        mid = int(self.mat.mid(name=mat))
        start_n = self.nrows(mid=mid)
        array, arids = self.reqs(n=start_n)

        extra = list(range(self.arids[mid]-1, -1, -1))
        seen:set[int] = set()

        while extra:
            rid = int(extra.pop())
            if rid < 0 or rid >= self.arids[mid]:
                continue
            if rid in seen:
                continue
            seen.add(rid)

            row0 = Row(mid=mid, rid=rid, row=self.array[mid][rid])
            row1 = self.mdx.search(r=row0, axis=axis)   # FIXED call
            if row1 is None:
                continue

            created, carids = self.merge2(row0=row0, row1=row1)
            if carids[mid] > 0:
                array[mid][arids[mid]] = created[mid][0]
                arids[mid] += 1

                new_rid = self.arids[mid] - 1
                extra.append(int(new_rid))
                seen.discard(rid)
                extra.append(rid)

        return (array, arids)

    def mergemat(self, mat:str=None)->REQS:
        if mat is None:
            raise ValueError("mergemat requires mat")

        mid = int(self.mat.mid(name=mat))
        array, arids = self.reqs(n=self.nrows(mid=mid))

        for ax in (0,1,2):
            while True:
                created, carids = self.mergeax(mat=mat, axis=ax)
                if carids[mid] <= 0:
                    break
                for i in range(carids[mid]):
                    array[mid][arids[mid]] = created[mid][i]
                    arids[mid] += 1

        return (array, arids)

    def mergerows(self, rows:NDARR=None)->REQS:
        if rows is None:
            return self.reqs(n=0)

        mids_present:set[int] = set()
        for mid in range(rows.shape[0]):
            for i in range(rows.shape[1]):
                if rows[mid][i][*ROW.IDS_RID] != ROW.SENTINEL:
                    mids_present.add(mid)
                    break

        worst = 0
        for mid in mids_present:
            worst += self.nrows(mid=mid)

        array, arids = self.reqs(n=worst)

        while True:
            merged_this_round = 0

            for ax in (0,1,2):
                extra:list[tuple[int,int]] = []
                for mid in mids_present:
                    for rid in range(self.arids[mid]-1, -1, -1):
                        extra.append((mid,rid))

                seen:set[tuple[int,int]] = set()

                while extra:
                    mid,rid = extra.pop()
                    if rid < 0 or rid >= self.arids[mid]:
                        continue

                    key = (mid,rid)
                    if key in seen:
                        continue
                    seen.add(key)

                    row0 = Row(mid=mid, rid=rid, row=self.array[mid][rid])
                    row1 = self.mdx.search(r=row0, axis=ax)   # FIXED call
                    if row1 is None:
                        continue

                    created, carids = self.merge2(row0=row0, row1=row1)
                    if carids[mid] > 0:
                        array[mid][arids[mid]] = created[mid][0]
                        arids[mid] += 1
                        merged_this_round += 1

                        new_rid = self.arids[mid] - 1
                        extra.append((mid, int(new_rid)))
                        seen.discard((mid,rid))
                        extra.append((mid,rid))

            if merged_this_round == 0:
                break

        return (array, arids)

    def mergeall(self)->REQS:
        array, arids = self.reqs(n=self.total)
        for mat in self.mat.names():
            created, carids = self.mergemat(mat=mat)
            for mid in range(MATERIALS.NUM):
                for i in range(carids[mid]):
                    array[mid][arids[mid]] = created[mid][i]
                    arids[mid] += 1
        return (array, arids)

    def merge(self, rows:NDARR=None)->REQS:
        if rows is None:
            return self.mergeall()
        return self.mergerows(rows=rows)

    def __repr__(self)->str:
        return self.__str__()

    def __str__(self)->str:
        return f"ROWS(shape={self.shape}, gbytes={self.gbytes:.3f}, total={self.total})"

################################################################################
# FILE 42/42: world/rows.py (END)
################################################################################


################################################################################
### CAPTURED OUTPUT (STDOUT/STDERR) ###
################################################################################


=== RUNNING TEST 1/1: test6 ===
=== TEST6: TIMING BENCHMARK (100 calls per op, fresh world per op) ===
test6: search() [tests=10]: lap 3: 0.000278 seconds
test6: split1 (point split) [tests=10]: lap 5: 0.105745 seconds
test6: split2 (region split) [tests=10]: lap 7: 0.111404 seconds
test6: merge() [tests=10]: lap 9: 0.057264 seconds
test6: remove() [tests=10]: lap 11: 2.8e-05 seconds
test6: insert() [tests=10]: lap 13: 0.000459 seconds
=== TEST6 DONE ===
=== TEST 1/1: test6 PASSED in 0.001 seconds ===


################################################################################
### END OF CAPTURED OUTPUT ###
################################################################################
# Total lines in bundle: 4068
# Total files in bundle: 42
# Generated at the time: 2026-01-31T06:59:20
--- END OF FILE ---
