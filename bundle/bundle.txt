#Time when generated: 2026-01-29T08:03:11.248931

### PROJECT BUNDLE ###
Root: C:\VOXELS
Files included: 14


################################################################################
# FILE 1/14: __init__.py (START)
################################################################################

import utils
import world
import bundle

__all__ = world.__all__ + utils.__all__ + bundle.__all__


################################################################################
# FILE 1/14: __init__.py (END)
################################################################################


################################################################################
# FILE 2/14: __main__.py (START)
################################################################################

from main import main

if __name__ == "__main__":
    main()

################################################################################
# FILE 2/14: __main__.py (END)
################################################################################


################################################################################
# FILE 3/14: main.py (START)
################################################################################


from utils import *
from world import *
from bundle import *





def main() -> None:
    rows = ROWS()

    rows.delete(index=0, mat="STONE")

    cell = 20          # cube edge length
    nx = 40            # number of cells in X  -> world X size = nx*cell
    ny = 40            # number of cells in Y
    nz = 40            # number of cells in Z
    n = nx * ny * nz  # total number of cells

    timer.lap()
    for ix in range(nx):
        x0 = ix * cell
        x1 = x0 + cell
        for iy in range(ny):
            y0 = iy * cell
            y1 = y0 + cell
            for iz in range(nz):
                z0 = iz * cell
                z1 = z0 + cell
                rows.append(p0=(x0, y0, z0), p1=(x1, y1, z1), mat="STONE")
                

    timer.print(msg="3D grid partition built")

    max_x = nx * cell - 1
    max_y = ny * cell - 1
    max_z = nz * cell - 1

    succes = 0
    fails = 0
    for _ in range(1000):
        try:
            pos = (
                random.randint(0, max_x),
                random.randint(0, max_y),
                random.randint(0, max_z),
            )
            mat, rid, row = rows.find(pos=pos)
            assert ROW.CONTAINS(row=row, pos=pos), f"pos={pos} not contained by found row (mat={mat}, rid={rid})"
            succes += 1
        except:
            fails += 1
            pass

    print("All random CONTAINS checks passed.", f"Successes: {succes}, Fails: {fails} is a succes percentage of {100-fails/(succes+fails)*100:.2f}% adn per lookup {(succes+fails)/timer.delta[-1]:.2f} lookups/second")
    timer.print(msg="Random CONTAINS checks completed in")

    print("Now deleting all rows...")
    for i in range(10000):
        rows.delete(index=n-1-i, mat="STONE")
    timer.print(msg="All 10000 rows deleted in")

    # and now test wiht a new set adn see if it still works
    print("Rebuilding rows after deletion...")
    cell = 40          # double size
    nx = 20            # half number of cells in X  -> world X size = nx*cell
    ny = 20            # half number of cells in Y
    nz = 20            # half number of cells in Z
    n = nx * ny * nz  # total number of cells (1/8th number of previous)

    for ix in range(nx):
        x0 = ix * cell
        x1 = x0 + cell
        for iy in range(ny):
            y0 = iy * cell
            y1 = y0 + cell
            for iz in range(nz):
                z0 = iz * cell
                z1 = z0 + cell
                rows.append(p0=(x0, y0, z0), p1=(x1, y1, z1), mat="STONE")
                

    timer.print(msg="second time 3D grid partition built")
    succes = 0
    fails = 0
    for _ in range(1000):
        try:
            pos = (
                random.randint(0, max_x),
                random.randint(0, max_y),
                random.randint(0, max_z),
            )
            mat, rid, row = rows.find(pos=pos)
            assert ROW.CONTAINS(row=row, pos=pos), f"pos={pos} not contained by found row (mat={mat}, rid={rid})"
            succes += 1
        except:
            fails += 1
            pass

    print("All random CONTAINS checks passed.", f"Successes: {succes}, Fails: {fails} is a succes percentage of {100-fails/(succes+fails)*100:.2f}% adn per lookup {(succes+fails)/timer.delta[-1]:.2f} lookups/second")
    timer.print(msg="Second random CONTAINS checks completed in")

    if succes == 1000 and fails == 0:
        print("ALL TESTS PASSED SUCCESSFULLY!")









if __name__ == "__main__":
    timer.lap()
    b = Bundle()
    try:
        main()
        timer.print(msg="main.py: executed in")
    except Exception:
        traceback.print_exc()
    finally:
        b.stop()   






################################################################################
# FILE 3/14: main.py (END)
################################################################################


################################################################################
# FILE 4/14: utils/__init__.py (START)
################################################################################

from .includes import *
from .includes import __all__ as inc


__all__ = [
] + inc

################################################################################
# FILE 4/14: utils/__init__.py (END)
################################################################################


################################################################################
# FILE 5/14: utils/bvh.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from numpy.typing import NDArray
    from world.rows import ROWS
    from utils.types import POS

from world.row import ROW





class BVH:
    __slots__ = (
        "rows",
        "root",
        "left",
        "right",
        "parent",
        # AABB as 6 parallel lists (SoA)
        "xmin",
        "ymin",
        "zmin",
        "xmax",
        "ymax",
        "zmax",
        # leaf as 2 parallel lists
        "leaf_mid",
        "leaf_rid",
        # fast delete index
        "leaf_index",
    )

    def __init__(self, rows: ROWS) -> None:
        self.rows = rows
        self.root: int = -1

        self.left: list[int] = []
        self.right: list[int] = []
        self.parent: list[int] = []

        self.xmin: list[int] = []
        self.ymin: list[int] = []
        self.zmin: list[int] = []
        self.xmax: list[int] = []
        self.ymax: list[int] = []
        self.zmax: list[int] = []

        self.leaf_mid: list[int] = []
        self.leaf_rid: list[int] = []

        # (mid, rid) -> node index
        self.leaf_index: dict[tuple[int, int], int] = {}

    # ------------------------------------------------------------------
    # node alloc
    # ------------------------------------------------------------------

    def _new_node(
        self,
        xmin: int,
        ymin: int,
        zmin: int,
        xmax: int,
        ymax: int,
        zmax: int,
        leaf_mid: int = -1,
        leaf_rid: int = -1,
        left: int = -1,
        right: int = -1,
        parent: int = -1,
    ) -> int:
        i = len(self.left)

        self.left.append(left)
        self.right.append(right)
        self.parent.append(parent)

        self.xmin.append(xmin)
        self.ymin.append(ymin)
        self.zmin.append(zmin)
        self.xmax.append(xmax)
        self.ymax.append(ymax)
        self.zmax.append(zmax)

        self.leaf_mid.append(leaf_mid)
        self.leaf_rid.append(leaf_rid)
        return i

    # ------------------------------------------------------------------
    # helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _volume(xmin: int, ymin: int, zmin: int, xmax: int, ymax: int, zmax: int) -> int:
        return (xmax - xmin) * (ymax - ymin) * (zmax - zmin)

    def _merged_volume_with_node(
        self,
        node: int,
        bxmin: int,
        bymin: int,
        bzmin: int,
        bxmax: int,
        bymax: int,
        bzmax: int,
    ) -> int:
        axmin = self.xmin[node]
        aymin = self.ymin[node]
        azmin = self.zmin[node]
        axmax = self.xmax[node]
        aymax = self.ymax[node]
        azmax = self.zmax[node]

        mxmin = axmin if axmin < bxmin else bxmin
        mymin = aymin if aymin < bymin else bymin
        mzmin = azmin if azmin < bzmin else bzmin
        mxmax = axmax if axmax > bxmax else bxmax
        mymax = aymax if aymax > bymax else bymax
        mzmax = azmax if azmax > bzmax else bzmax

        return self._volume(mxmin, mymin, mzmin, mxmax, mymax, mzmax)

    def _fix_upwards(self, node: int) -> None:
        while node != -1:
            l = self.left[node]
            r = self.right[node]

            self.xmin[node] = self.xmin[l] if self.xmin[l] < self.xmin[r] else self.xmin[r]
            self.ymin[node] = self.ymin[l] if self.ymin[l] < self.ymin[r] else self.ymin[r]
            self.zmin[node] = self.zmin[l] if self.zmin[l] < self.zmin[r] else self.zmin[r]
            self.xmax[node] = self.xmax[l] if self.xmax[l] > self.xmax[r] else self.xmax[r]
            self.ymax[node] = self.ymax[l] if self.ymax[l] > self.ymax[r] else self.ymax[r]
            self.zmax[node] = self.zmax[l] if self.zmax[l] > self.zmax[r] else self.zmax[r]

            node = self.parent[node]

    # ------------------------------------------------------------------
    # insertion
    # ------------------------------------------------------------------

    def insert(
        self,
        mat: str | None = None,
        rid: int | None = None,
        row: "NDArray[ROW.DTYPE] | None" = None,
    ) -> None:
        if row is None:
            mid = self.rows.mats.name2idx[mat]
            row = self.rows.array[mid][rid]
        else:
            mat_id = int(row[*ROW.MAT])
            mid = self.rows.mats.id2idx[mat_id]
            rid = int(row[*ROW.ID])

        xmin, ymin, zmin = ROW.P0(row)
        xmax, ymax, zmax = ROW.P1(row)

        leaf_node = self._new_node(
            xmin, ymin, zmin,
            xmax, ymax, zmax,
            leaf_mid=mid,
            leaf_rid=rid,
        )

        self.leaf_index[(mid, rid)] = leaf_node

        if self.root == -1:
            self.root = leaf_node
            return

        self.root = self._insert_node(self.root, leaf_node)

    def _insert_node(self, root: int, leaf_node: int) -> int:
        bxmin = self.xmin[leaf_node]; bymin = self.ymin[leaf_node]; bzmin = self.zmin[leaf_node]
        bxmax = self.xmax[leaf_node]; bymax = self.ymax[leaf_node]; bzmax = self.zmax[leaf_node]

        node = root
        while self.leaf_mid[node] == -1:
            l = self.left[node]
            r = self.right[node]
            node = (
                l if self._merged_volume_with_node(l, bxmin, bymin, bzmin, bxmax, bymax, bzmax)
                < self._merged_volume_with_node(r, bxmin, bymin, bzmin, bxmax, bymax, bzmax)
                else r
            )

        old_leaf = node
        parent = self.parent[old_leaf]

        axmin = self.xmin[old_leaf]; aymin = self.ymin[old_leaf]; azmin = self.zmin[old_leaf]
        axmax = self.xmax[old_leaf]; aymax = self.ymax[old_leaf]; azmax = self.zmax[old_leaf]

        new_parent = self._new_node(
            axmin if axmin < bxmin else bxmin,
            aymin if aymin < bymin else bymin,
            azmin if azmin < bzmin else bzmin,
            axmax if axmax > bxmax else bxmax,
            aymax if aymax > bymax else bymax,
            azmax if azmax > bzmax else bzmax,
        )

        self.left[new_parent] = old_leaf
        self.right[new_parent] = leaf_node
        self.parent[old_leaf] = new_parent
        self.parent[leaf_node] = new_parent

        if parent == -1:
            return new_parent

        if self.left[parent] == old_leaf:
            self.left[parent] = new_parent
        else:
            self.right[parent] = new_parent

        self.parent[new_parent] = parent
        self._fix_upwards(parent)
        return root

    # ------------------------------------------------------------------
    # removal (FAST)
    # ------------------------------------------------------------------

    def remove(
        self,
        mat: str | None = None,
        rid: int | None = None,
        row: "NDArray[ROW.DTYPE] | None" = None,
    ) -> None:
        if row is not None:
            mat_id = int(row[*ROW.MAT])
            mid = self.rows.mats.id2idx[mat_id]
            rid = int(row[*ROW.ID])
        else:
            mid = self.rows.mats.name2idx[mat]

        try:
            found = self.leaf_index.pop((mid, rid))
        except KeyError:
            raise KeyError("row not found in BVH")

        parent = self.parent[found]
        if parent == -1:
            self.root = -1
            return

        sibling = self.right[parent] if self.left[parent] == found else self.left[parent]
        grand = self.parent[parent]

        if grand == -1:
            self.root = sibling
            self.parent[sibling] = -1
        else:
            if self.left[grand] == parent:
                self.left[grand] = sibling
            else:
                self.right[grand] = sibling
            self.parent[sibling] = grand
            self._fix_upwards(grand)

    # ------------------------------------------------------------------
    # find
    # ------------------------------------------------------------------

    def find(self, pos: "POS") -> tuple[str, int, "NDArray[ROW.DTYPE]"]:
        if self.root == -1:
            raise LookupError("empty BVH")

        x, y, z = pos
        stack = [self.root]

        xminL = self.xmin; yminL = self.ymin; zminL = self.zmin
        xmaxL = self.xmax; ymaxL = self.ymax; zmaxL = self.zmax
        leftL = self.left; rightL = self.right
        leaf_midL = self.leaf_mid; leaf_ridL = self.leaf_rid
        rows_arr = self.rows.array
        idx2name = self.rows.mats.idx2name
        contains = ROW.CONTAINS

        while stack:
            n = stack.pop()
            if n == -1:
                continue

            if not (xminL[n] <= x < xmaxL[n] and yminL[n] <= y < ymaxL[n] and zminL[n] <= z < zmaxL[n]):
                continue

            mid = leaf_midL[n]
            if mid != -1:
                rid = leaf_ridL[n]
                row = rows_arr[mid][rid]
                if contains(row=row, pos=pos):
                    return idx2name[mid], rid, row
                continue

            l = leftL[n]
            r = rightL[n]

            if l != -1 and (xminL[l] <= x < xmaxL[l] and yminL[l] <= y < ymaxL[l] and zminL[l] <= z < zmaxL[l]):
                stack.append(l)
            if r != -1 and (xminL[r] <= x < xmaxL[r] and yminL[r] <= y < ymaxL[r] and zminL[r] <= z < zmaxL[r]):
                stack.append(r)

        raise LookupError(
            "BVH.find failed: point not found (partition invariant violated or BVH not updated)"
        )


















class BVH_:
    __slots__ = (
        "rows",
        "root",
        "left",
        "right",
        "parent",
        # AABB as 6 parallel lists (SoA)
        "xmin",
        "ymin",
        "zmin",
        "xmax",
        "ymax",
        "zmax",
        # leaf as 2 parallel lists
        "leaf_mid",
        "leaf_rid",
    )

    def __init__(self, rows: ROWS) -> None:
        self.rows = rows
        self.root: int = -1

        self.left: list[int] = []
        self.right: list[int] = []
        self.parent: list[int] = []

        self.xmin: list[int] = []
        self.ymin: list[int] = []
        self.zmin: list[int] = []
        self.xmax: list[int] = []
        self.ymax: list[int] = []
        self.zmax: list[int] = []

        self.leaf_mid: list[int] = []
        self.leaf_rid: list[int] = []

    # ------------------------------------------------------------------
    # node alloc
    # ------------------------------------------------------------------

    def _new_node(
        self,
        xmin: int,
        ymin: int,
        zmin: int,
        xmax: int,
        ymax: int,
        zmax: int,
        leaf_mid: int = -1,
        leaf_rid: int = -1,
        left: int = -1,
        right: int = -1,
        parent: int = -1,
    ) -> int:
        i = len(self.left)

        self.left.append(left)
        self.right.append(right)
        self.parent.append(parent)

        self.xmin.append(xmin)
        self.ymin.append(ymin)
        self.zmin.append(zmin)
        self.xmax.append(xmax)
        self.ymax.append(ymax)
        self.zmax.append(zmax)

        self.leaf_mid.append(leaf_mid)
        self.leaf_rid.append(leaf_rid)
        return i

    # ------------------------------------------------------------------
    # small geometry helpers (inlined patterns in hot code)
    # ------------------------------------------------------------------

    @staticmethod
    def _volume(xmin: int, ymin: int, zmin: int, xmax: int, ymax: int, zmax: int) -> int:
        return (xmax - xmin) * (ymax - ymin) * (zmax - zmin)

    def _merged_volume_with_node(
        self,
        node: int,
        bxmin: int,
        bymin: int,
        bzmin: int,
        bxmax: int,
        bymax: int,
        bzmax: int,
    ) -> int:
        axmin = self.xmin[node]
        aymin = self.ymin[node]
        azmin = self.zmin[node]
        axmax = self.xmax[node]
        aymax = self.ymax[node]
        azmax = self.zmax[node]

        mxmin = axmin if axmin < bxmin else bxmin
        mymin = aymin if aymin < bymin else bymin
        mzmin = azmin if azmin < bzmin else bzmin
        mxmax = axmax if axmax > bxmax else bxmax
        mymax = aymax if aymax > bymax else bymax
        mzmax = azmax if azmax > bzmax else bzmax

        return self._volume(mxmin, mymin, mzmin, mxmax, mymax, mzmax)

    def _fix_upwards(self, node: int) -> None:
        # Recompute AABBs up to root
        while node != -1:
            l = self.left[node]
            r = self.right[node]

            lxmin = self.xmin[l]; lymin = self.ymin[l]; lzmin = self.zmin[l]
            lxmax = self.xmax[l]; lymax = self.ymax[l]; lzmax = self.zmax[l]
            rxmin = self.xmin[r]; rymin = self.ymin[r]; rzmin = self.zmin[r]
            rxmax = self.xmax[r]; rymax = self.ymax[r]; rzmax = self.zmax[r]

            self.xmin[node] = lxmin if lxmin < rxmin else rxmin
            self.ymin[node] = lymin if lymin < rymin else rymin
            self.zmin[node] = lzmin if lzmin < rzmin else rzmin
            self.xmax[node] = lxmax if lxmax > rxmax else rxmax
            self.ymax[node] = lymax if lymax > rymax else rymax
            self.zmax[node] = lzmax if lzmax > rzmax else rzmax

            node = self.parent[node]

    # ------------------------------------------------------------------
    # insertion
    # ------------------------------------------------------------------

    def insert(
        self,
        mat: str | None = None,
        rid: int | None = None,
        row: "NDArray[ROW.DTYPE] | None" = None,
    ) -> None:
        if row is None:
            mid = self.rows.mats.name2idx[mat]
            row = self.rows.array[mid][rid]
        else:
            mat_id = int(row[*ROW.MAT])
            mid = self.rows.mats.id2idx[mat_id]
            rid = int(row[*ROW.ID])

        xmin, ymin, zmin = ROW.P0(row)
        xmax, ymax, zmax = ROW.P1(row)

        leaf_node = self._new_node(
            xmin=xmin, ymin=ymin, zmin=zmin,
            xmax=xmax, ymax=ymax, zmax=zmax,
            leaf_mid=mid, leaf_rid=rid,
        )

        if self.root == -1:
            self.root = leaf_node
            return

        self.root = self._insert_node(self.root, leaf_node)

    def _insert_node(self, root: int, leaf_node: int) -> int:
        # Cache leaf AABB locally (hot)
        bxmin = self.xmin[leaf_node]; bymin = self.ymin[leaf_node]; bzmin = self.zmin[leaf_node]
        bxmax = self.xmax[leaf_node]; bymax = self.ymax[leaf_node]; bzmax = self.zmax[leaf_node]

        node = root

        # descend until leaf
        while self.leaf_mid[node] == -1:
            l = self.left[node]
            r = self.right[node]

            cost_left = self._merged_volume_with_node(l, bxmin, bymin, bzmin, bxmax, bymax, bzmax)
            cost_right = self._merged_volume_with_node(r, bxmin, bymin, bzmin, bxmax, bymax, bzmax)

            node = l if cost_left < cost_right else r

        # node is leaf → split
        old_leaf = node
        parent = self.parent[old_leaf]

        # merged AABB of old_leaf and new leaf_node
        axmin = self.xmin[old_leaf]; aymin = self.ymin[old_leaf]; azmin = self.zmin[old_leaf]
        axmax = self.xmax[old_leaf]; aymax = self.ymax[old_leaf]; azmax = self.zmax[old_leaf]

        mxmin = axmin if axmin < bxmin else bxmin
        mymin = aymin if aymin < bymin else bymin
        mzmin = azmin if azmin < bzmin else bzmin
        mxmax = axmax if axmax > bxmax else bxmax
        mymax = aymax if aymax > bymax else bymax
        mzmax = azmax if azmax > bzmax else bzmax

        new_parent = self._new_node(
            xmin=mxmin, ymin=mymin, zmin=mzmin,
            xmax=mxmax, ymax=mymax, zmax=mzmax,
            leaf_mid=-1, leaf_rid=-1,
        )

        self.left[new_parent] = old_leaf
        self.right[new_parent] = leaf_node
        self.parent[old_leaf] = new_parent
        self.parent[leaf_node] = new_parent

        if parent == -1:
            return new_parent

        if self.left[parent] == old_leaf:
            self.left[parent] = new_parent
        else:
            self.right[parent] = new_parent

        self.parent[new_parent] = parent
        self._fix_upwards(parent)
        return root

    # ------------------------------------------------------------------
    # removal
    # ------------------------------------------------------------------

    def remove(
        self,
        mat: str | None = None,
        rid: int | None = None,
        row: "NDArray[ROW.DTYPE] | None" = None,
    ) -> None:
        if row is not None:
            mat_id = int(row[*ROW.MAT])
            mid = self.rows.mats.id2idx[mat_id]
            rid = int(row[*ROW.ID])
        else:
            mid = self.rows.mats.name2idx[mat]

        if self.root == -1:
            raise KeyError("row not found in BVH")

        target_mid = mid
        target_rid = rid

        # find leaf
        stack = [self.root]
        found = -1
        while stack:
            n = stack.pop()
            if n == -1:
                continue

            lm = self.leaf_mid[n]
            if lm == target_mid and self.leaf_rid[n] == target_rid:
                found = n
                break

            if lm == -1:  # internal
                stack.append(self.left[n])
                stack.append(self.right[n])

        if found == -1:
            raise KeyError("row not found in BVH")

        parent = self.parent[found]
        if parent == -1:
            self.root = -1
            return

        sibling = self.right[parent] if self.left[parent] == found else self.left[parent]
        grand = self.parent[parent]

        if grand == -1:
            self.root = sibling
            self.parent[sibling] = -1
        else:
            if self.left[grand] == parent:
                self.left[grand] = sibling
            else:
                self.right[grand] = sibling
            self.parent[sibling] = grand
            self._fix_upwards(grand)

    # ------------------------------------------------------------------
    # find
    # ------------------------------------------------------------------

    def find(self, pos: "POS") -> tuple[str, int, "NDArray[ROW.DTYPE]"]:
        if self.root == -1:
            raise LookupError("empty BVH")

        x, y, z = pos
        stack = [self.root]

        # local bindings (reduce attribute lookups in loop)
        xminL = self.xmin; yminL = self.ymin; zminL = self.zmin
        xmaxL = self.xmax; ymaxL = self.ymax; zmaxL = self.zmax
        leftL = self.left; rightL = self.right
        leaf_midL = self.leaf_mid; leaf_ridL = self.leaf_rid
        rows_arr = self.rows.array
        idx2name = self.rows.mats.idx2name

        while stack:
            n = stack.pop()
            if n == -1:
                continue

            # inline AABB contains check (xmin <= x < xmax etc.)
            if not (xminL[n] <= x < xmaxL[n] and yminL[n] <= y < ymaxL[n] and zminL[n] <= z < zmaxL[n]):
                continue

            mid = leaf_midL[n]

            if mid != -1:
                rid = leaf_ridL[n]
                row = rows_arr[mid][rid]
                if ROW.CONTAINS(row=row, pos=pos):
                    return idx2name[mid], rid, row
                continue

            l = leftL[n]
            r = rightL[n]

            # push both children that might contain pos (overlap-safe)
            if l != -1 and (xminL[l] <= x < xmaxL[l] and yminL[l] <= y < ymaxL[l] and zminL[l] <= z < zmaxL[l]):
                stack.append(l)
            if r != -1 and (xminL[r] <= x < xmaxL[r] and yminL[r] <= y < ymaxL[r] and zminL[r] <= z < zmaxL[r]):
                stack.append(r)

        raise LookupError(
            "BVH.find failed: point not found (partition invariant violated or BVH not updated)"
        )

################################################################################
# FILE 5/14: utils/bvh.py (END)
################################################################################


################################################################################
# FILE 6/14: utils/event.py (START)
################################################################################

from __future__ import annotations
from typing import Any, Callable
from dataclasses import dataclass, field
from .event import Event
from .schedule import Schedule



@dataclass(order=True)
class Event:
    due_ns: int
    seq: int
    callback: Callable[..., Any] = field(compare=False)
    args: tuple[Any, ...] = field(default_factory=tuple, compare=False)
    kwargs: dict[str, Any] = field(default_factory=dict, compare=False)
    cancelled: bool = field(default=False, compare=False)


class Handler:
    __slots__ = ("_scheduler", "_event")

    def __init__(self, scheduler: "Schedule", event: Event) -> None:
        self._scheduler = scheduler
        self._event = event

    def cancel(self) -> bool:
        return self._scheduler.cancel(self)


################################################################################
# FILE 6/14: utils/event.py (END)
################################################################################


################################################################################
# FILE 7/14: utils/includes.py (START)
################################################################################

from __future__ import annotations  # MUST BE FIRST

# EXCEPTION IMPORTS
from .timer import Timer, time      # NON SORTED -> HERE BECAUSE Timer IS USED IMMEDIATELY
timer = Timer()

# IMPORTS FROM STANDARD LIBRARY AND THIRD-PARTY LIBRARIES
from typing import TYPE_CHECKING, Any, Iterator, TypeVar, Generic, Union, Tuple, List, Dict, Callable, Optional
from pathlib import Path
from numpy.typing import NDArray
from PIL import Image, ImageDraw, ImageFont


# SIMPLE IMPORTS
import math
import numpy as np
import torch 
import heapq
import threading
import json
import time
import pathlib
import sys
import os
import random
import shutil
import datetime
import bisect
import pygame
import moderngl
import traceback
import stat



# my own modules (utils)
from .types import POS, SIZE


# Exports
__all__ = [
    "math",
    "time",
    "np",
    "NDArray",
    "torch",
    "TYPE_CHECKING",
    "annotations",
    "Any",
    "Iterator",
    "TypeVar",
    "Generic",
    "Union",
    "Tuple",
    "List",
    "Dict",
    "Callable",
    "Optional",
    "Image",
    "ImageDraw",
    "ImageFont",
    "Timer",
    "heapq",
    "threading",
    "json",
    "Path",
    "POS",
    "SIZE",
    "pathlib",
    "sys",
    "os",
    "random",
    "shutil",
    "datetime",
    "bisect",
    "pygame",
    "moderngl",
    "timer", # include the instance timer -> can be used as utils.timer
    "traceback",
    "stat",
]


timer.print(msg=f"utils/includes.py: {len(__all__)} modules loaded in")
timer.reset()

################################################################################
# FILE 7/14: utils/includes.py (END)
################################################################################


################################################################################
# FILE 8/14: utils/schedule.py (START)
################################################################################

import threading
from typing import Any, Callable, Optional
import heapq
from .timer import Timer, now
from .event import Event, Handler



class Schedule:
    def __init__(self) -> None:
        self._timer = Timer()

        self._lock = threading.Lock()
        self._cv = threading.Condition(self._lock)
        self._pq: list[Event] = []
        self._seq = 0

        self._worker: Optional[threading.Thread] = None
        self._stop = False
        self._running = False

        self.start()

    def start(self) -> None:
        with self._lock:
            if self._running:
                return
            self._stop = False
            self._worker = threading.Thread(target=self._run, name="SchedulerWorker", daemon=True)
            self._running = True
            self._worker.start()

    def stop(self) -> None:
        with self._lock:
            if not self._running:
                return
            self._stop = True
            self._cv.notify_all()

        if self._worker:
            self._worker.join(timeout=2.0)

        with self._lock:
            self._running = False
            self._worker = None

    def schedule(self, ns: int=None, fn: Callable[..., Any]=None, *args: Any, **kwargs: Any) -> Handler:
        with self._lock:
            self._seq += 1
            ev = Event(due_ns=ns, seq=self._seq, callback=fn, args=args, kwargs=kwargs)
            heapq.heappush(self._pq, ev)
            self._cv.notify_all()
            return Handler(self, ev)

    def new(self, seconds:float=None, fn:Callable[..., Any]=None, delay=False, *args: Any, **kwargs: Any) -> Handler:
        if delay==True:
            ns = now() + int(seconds * 1e9)
        if delay==False:
            ns = int(seconds * 1e9)
        return self.schedule(ns=ns, fn=fn, *args, **kwargs)
    

    def cancel(self, handle: Handler) -> bool:
        with self._lock:
            if handle._event.cancelled:
                return False
            handle._event.cancelled = True
            self._cv.notify_all()
            return True

    def _run(self) -> None:
        while True:
            with self._lock:
                # Wait until there is work or stop requested
                while not self._pq and not self._stop:
                    self._cv.wait()

                if self._stop:
                    return

                # Drop cancelled events at head
                while self._pq and self._pq[0].cancelled:
                    heapq.heappop(self._pq)

                if not self._pq:
                    continue

                ev = self._pq[0]
                due = ev.due_ns

            # 2) Wait until deadline (no lock held)
            self._timer.waitns(due)

            # 3) Pop-and-execute if still valid
            with self._lock:
                if self._stop:
                    return

                if not self._pq:
                    continue
                if self._pq[0] is not ev:
                    continue

                heapq.heappop(self._pq)
                if ev.cancelled:
                    continue

            try:
                ev.callback(*ev.args, **ev.kwargs)
            except Exception as e:
                # Keep scheduler alive; replace with logging if desired
                print(f"[Schedule] callback error: {e!r}")






















# ============================================================
# Example usage
# ============================================================

if __name__ == "__main__":
    import time

    sched = Schedule()
    def hello(who:str=None, n:int=1) -> None:
        print(f"{time.perf_counter():.3f} hello {who} x{n}")
    def test(who:str=None,  n:int=1) -> None:
        print(who, n*n)

    h1 = sched.new(seconds=0.050, fn=test, who="A", n=2, delay=True)
    h2 = sched.new(seconds=0.120, fn=hello, who="B", n=3, delay=True)
    h3 = sched.new(seconds=0.080, fn=test, who="C", n=1, delay=True)
    h2.cancel()
    futuretime = time.perf_counter() + 0.100
    h4 = sched.new(seconds=futuretime, fn=hello, who="D", n=4, delay=False)
    h5 = sched.new(seconds=futuretime, fn=test, who="E", n=5, delay=False)
    h6 = sched.new(seconds=futuretime, fn=hello, who="F", n=6, delay=False)


    time.sleep(0.2)
    sched.stop()

################################################################################
# FILE 8/14: utils/schedule.py (END)
################################################################################


################################################################################
# FILE 9/14: utils/timer.py (START)
################################################################################

from __future__ import annotations
import time



class Timer:
    def __init__(self) -> None:
        self.coarse_ns = 2_000_000
        self.spin_ns = 1_000_000

        self.start()

    def nowns(self) -> int:  # can be used as Timer().nowns()
        return time.perf_counter_ns()
    
    @staticmethod   # can be used as Timer.now()
    def now() -> float:
        return time.perf_counter_ns()

    def start(self) -> int:
        self.started = self.nowns()
        self.t0 = self.started
        self.delta = []
        self.times = []
        return self.t0
    
    def lap(self) -> int:
        t1 = self.nowns()
        t0 = self.t0
        self.t0 = t1
        dt = round((t1 - t0) / 1e9, 6) # seconds
        self.delta.append(dt)
        self.times.append(t1)
        return dt       # time since last lap in seconds
    
    def stop(self) -> int:
        self.lap()
        first = self.started
        last = self.times[-1]
        t = round((last - first) / 1e9, 6) # seconds with 6 decimal places (microseconds) 
        return t        # total since started
    
    def print(self, msg:str=None) -> None:
        self.lap()
        txt = f"lap {len(self.delta)}: {self.delta[-1]} seconds, total {round((self.times[-1] - self.started) / 1e9, 6)} seconds"
        if msg is not None:
            txt = f"{msg}: {txt}"
        print(txt)

    def waitns(self, deadline_ns: int) -> None:
        coarse_ns = self.coarse_ns
        spin_ns = self.spin_ns

        while True:
            n = self.nowns()
            remaining = deadline_ns - n
            if remaining <= 0:
                return

            # FAR: sleep until within coarse_ns
            if remaining > coarse_ns:
                time.sleep((remaining - coarse_ns) / 1e9)
                continue

            # NEAR: yield until within spin_ns
            if remaining > spin_ns:
                time.sleep(0)
                continue

            # FINAL: busy-spin
            while self.nowns() < deadline_ns:
                pass
            return

    def wait(self, seconds: float) -> None:
        if seconds <= 0:
            return
        self.waitns(self.nowns() + int(seconds * 1e9))

    def reset(self) -> int:
        t = self.stop()
        self.start()
        return t  # total since started before reset


now = Timer.now # now: now() returns the current time in nanoseconds

################################################################################
# FILE 9/14: utils/timer.py (END)
################################################################################


################################################################################
# FILE 10/14: utils/types.py (START)
################################################################################

from typing import TypeAlias
POS: TypeAlias = tuple[int, int, int]
SIZE: TypeAlias = tuple[int, int, int]

__all__ = [
    "POS",
    "SIZE",
]

################################################################################
# FILE 10/14: utils/types.py (END)
################################################################################


################################################################################
# FILE 11/14: world/__init__.py (START)
################################################################################

from .rows import ROWS, rows
from .row import ROW
from .materials import MATERIALS, Materials, Material

from utils import *
from world import *
from bundle import *

__all__ = [
    "MATERIALS",
    "Materials",
    "Material",
    "ROW",
    "ROWS",
    "rows",
]

################################################################################
# FILE 11/14: world/__init__.py (END)
################################################################################


################################################################################
# FILE 12/14: world/materials.py (START)
################################################################################
















class MATERIALS:
    TYPES = {
        "INVIS": 0,     # start at 16384                # invisible
        "TRANS": 1,     # start at 32768                # transparent
        "SOLID": 2,     # start at 65536                # solid
        "ROCKS": 3,     # start at 4294967296           # indestructible
    }

    DATA  = {
        "AIR":      (16384+0,     TYPES["INVIS"]),

        "WATER":    (32768+0,     TYPES["TRANS"]), 
        "LAVA":     (32768+1,     TYPES["TRANS"]),
        "GLASS":    (32768+2,     TYPES["TRANS"]),

        "STONE":    (65536+0,     TYPES["SOLID"]),
        "OBSIDIAN": (65536+1,     TYPES["SOLID"]),

        "BEDROCK":  (4294967296+0,TYPES["ROCKS"]),
    }

    IDX = {name: i for i, name in enumerate(DATA.keys())}

    NUM = len(DATA)

class Material:
    def __init__(self, name:str=None) -> None:
        self.id, self.type = MATERIALS.DATA.get(name, (None, None)) 
        self.idx = MATERIALS.IDX.get(name, None) 
        if self.id is None or self.type is None or self.idx is None:
            raise ValueError(f"Invalid material name: {name}")

    def isrocks(self) -> bool:
        return self.type == MATERIALS.TYPES["ROCKS"]

    def issolid(self) -> bool:
        return self.type == MATERIALS.TYPES["SOLID"]
    
    def istrans(self) -> bool:
        return self.type == MATERIALS.TYPES["TRANS"]
    
    def isinvisible(self) -> bool:
        return self.type == MATERIALS.TYPES["INVIS"]
    
    def isindestructible(self) -> bool:
        return self.type == MATERIALS.TYPES["ROCKS"]

class Materials:
    idx2name = {idx: name for name, idx in MATERIALS.IDX.items()}
    name2idx = MATERIALS.IDX

    name2id  = {name: pair[0] for name, pair in MATERIALS.DATA.items()}
    id2name  = {pair[0]: name for name, pair in MATERIALS.DATA.items()}

    # the one you actually need:
    id2idx   = {pair[0]: MATERIALS.IDX[name] for name, pair in MATERIALS.DATA.items()}
    idx2id   = {MATERIALS.IDX[name]: pair[0] for name, pair in MATERIALS.DATA.items()}


    def __init__(self) -> None:
        for name in MATERIALS.DATA.keys():
            setattr(self, name.lower(), Material(name=name))

    def idx(self, name: str = None, id: int = None) -> int:
        if (name is None) == (id is None):
            raise ValueError("Provide exactly one of name or id")
        return self.name2idx[name] if name is not None else self.id2idx[id]

    def id(self, name: str = None, idx: int = None) -> int:
        if (name is None) == (idx is None):
            raise ValueError("Provide exactly one of name or idx")
        return self.name2id[name] if name is not None else self.idx2id[idx]

    def name(self, id: int = None, idx: int = None) -> str:
        if (id is None) == (idx is None):
            raise ValueError("Provide exactly one of id or idx")
        return self.id2name[id] if id is not None else self.idx2name[idx]


################################################################################
# FILE 12/14: world/materials.py (END)
################################################################################


################################################################################
# FILE 13/14: world/row.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    pass



import numpy as np
from numpy.typing import NDArray


from utils.types import SIZE, POS
from world.materials import Material





class ROW:
    DTYPE = np.uint64
    SHAPE = (4, 4)
    NBITS = DTYPE(0).nbytes * 8                      # -> 64 bits

    XBITS = 20
    YBITS = 20
    ZBITS = 16
    if XBITS + YBITS + ZBITS + 1 > NBITS:
        raise ValueError("bit allocation error")

    XMIN = 0
    YMIN = 0
    ZMIN = 0
    XMAX = 2**XBITS
    YMAX = 2**YBITS
    ZMAX = 2**ZBITS
    NMAX = XMAX * YMAX * ZMAX


    # POSITIONS (MIN) — stored in row 0
    X0 = (0, 0)
    Y0 = (0, 1)
    Z0 = (0, 2)

    # POSITIONS (MAX) — stored in row 1
    X1 = (1, 0)
    Y1 = (1, 1)
    Z1 = (1, 2)

    # DIMENSIONS — stored in row 2
    DX = (2, 0)
    DY = (2, 1)
    DZ = (2, 2)

    # METADATA — stored in row 3
    ID    = (3, 0)
    MAT   = (3, 1)
    FLAGS = (3, 2)

    DIRTY        = DTYPE(1 << 0)
    ALIVE        = DTYPE(1 << 1)
    SOLID        = DTYPE(1 << 2)
    DESTRUCTABLE = DTYPE(1 << 3)
    VISIBLE      = DTYPE(1 << 4)

    SENTINEL = np.iinfo(DTYPE).max
    ARRAY: NDArray[DTYPE] = np.zeros(SHAPE, dtype=DTYPE)
    for i in range(4):
        for j in range(4):
            ARRAY[i, j] = SENTINEL  # initialize all to -1 -> invalid
    _ID = 0
    
    @staticmethod
    def P0(row:NDArray[DTYPE]=None) -> POS:
        return (int(row[*ROW.X0]), int(row[*ROW.Y0]), int(row[*ROW.Z0]))
    
    @staticmethod
    def P1(row:NDArray[DTYPE]=None) -> POS:
        return (int(row[*ROW.X1]), int(row[*ROW.Y1]), int(row[*ROW.Z1]))
    
    @staticmethod
    def SIZE(row:NDArray[DTYPE]=None) -> SIZE:
        return (int(row[*ROW.DX]), int(row[*ROW.DY]), int(row[*ROW.DZ]))
    
    @staticmethod
    def VOLUME(row:NDArray[DTYPE]=None) -> int:
        dx, dy, dz = ROW.SIZE(row=row)
        return dx * dy * dz

    @staticmethod
    def COPY() -> NDArray[DTYPE]:
        return np.copy(ROW.ARRAY)
    
    @staticmethod
    def CLIP(pos:POS=None) -> POS:
        x, y, z = pos
        cx = min(max(x, ROW.XMIN), ROW.XMAX - 1)
        cy = min(max(y, ROW.YMIN), ROW.YMAX - 1)
        cz = min(max(z, ROW.ZMIN), ROW.ZMAX - 1)
        pos: POS = (cx, cy, cz)
        return pos
    
    @staticmethod
    def SORT(p0:POS=None, p1:POS=None) -> tuple[POS, POS]:
        x0, y0, z0 = p0
        x1, y1, z1 = p1
        sx0, sx1 = (min(x0, x1), max(x0, x1))
        sy0, sy1 = (min(y0, y1), max(y0, y1))
        sz0, sz1 = (min(z0, z1), max(z0, z1))
        p0: POS = (sx0, sy0, sz0)
        p1: POS = (sx1, sy1, sz1)
        return (p0, p1)
    
    @staticmethod
    def CONTAINS(row: NDArray[DTYPE], pos: POS) -> bool:
        x, y, z = pos
        return (
            int(row[*ROW.X0]) <= x < int(row[*ROW.X1]) and
            int(row[*ROW.Y0]) <= y < int(row[*ROW.Y1]) and
            int(row[*ROW.Z0]) <= z < int(row[*ROW.Z1])
        )
    
    @staticmethod
    def MERGE(row0: NDArray[DTYPE]=None, row1: NDArray[DTYPE]=None) -> tuple[bool, bool, bool]:
        if row0[*ROW.MAT] != row1[*ROW.MAT]:
            return (False, False, False)

        p00 = (row0[*ROW.X0], row0[*ROW.Y0], row0[*ROW.Z0])
        p01 = (row0[*ROW.X1], row0[*ROW.Y1], row0[*ROW.Z1])
        p10 = (row1[*ROW.X0], row1[*ROW.Y0], row1[*ROW.Z0])
        p11 = (row1[*ROW.X1], row1[*ROW.Y1], row1[*ROW.Z1])

        def overlap(a0:int=None, a1:int=None, b0:int=None, b1:int=None) -> bool: return a0 < b1 and b0 < a1
        def touches(a0:int=None, a1:int=None, b0:int=None, b1:int=None) -> bool: return a1 == b0 or b1 == a0

        touching = [False, False, False]
        overlaps = [False, False, False]

        for i in range(3):
            if overlap(a0=p00[i], a1=p01[i], b0=p10[i], b1=p11[i]):
                overlaps[i] = True
            elif touches(a0=p00[i], a1=p01[i], b0=p10[i], b1=p11[i]):
                touching[i] = True
            else:
                return (False, False, False)  # separated on this axis

        # mergeable ⇔ exactly one touching axis and two overlapping axes
        if sum(touching) == 1 and sum(overlaps) == 2:
            return tuple(touching)  # (x_touch, y_touch, z_touch)

        return (False, False, False)
                

    @staticmethod
    def new(p0:POS=None, p1:POS=None, mat:str=None, rid:int=None, dirty:bool=True, alive:bool=True) -> NDArray[DTYPE]:
        p0, p1 = ROW.SORT(p0=ROW.CLIP(pos=p0), p1=ROW.CLIP(pos=p1))
        mat: Material = Material(name=mat)
        flags: int = ROW.encode(dirty=dirty, alive=alive, solid=mat.issolid(), destructable=not mat.isindestructible(), visible=not mat.isinvisible())
        
        copy: NDArray[ROW.DTYPE] = ROW.COPY()

        # POS0
        copy[*ROW.X0]    = np.uint64(p0[0])
        copy[*ROW.Y0]    = np.uint64(p0[1])
        copy[*ROW.Z0]    = np.uint64(p0[2])
        # POS1
        copy[*ROW.X1]    = np.uint64(p1[0])
        copy[*ROW.Y1]    = np.uint64(p1[1])
        copy[*ROW.Z1]    = np.uint64(p1[2])
        # SIZE
        copy[*ROW.DX]    = np.uint64(p1[0] - p0[0])
        copy[*ROW.DY]    = np.uint64(p1[1] - p0[1])
        copy[*ROW.DZ]    = np.uint64(p1[2] - p0[2])
        # METADATA
        copy[*ROW.ID]    = np.uint64(rid)       # stores now the row index within material array instead of global unique id
        copy[*ROW.MAT]   = np.uint64(mat.id)
        copy[*ROW.FLAGS] = np.uint64(flags)

        if any(v < 0 for v in (copy[*ROW.DX], copy[*ROW.DY], copy[*ROW.DZ])):
            raise ValueError("p1 must be greater than or equal to p0 on all axes")
        if any(v < 0 for v in (copy[*ROW.X0], copy[*ROW.Y0], copy[*ROW.Z0])):
            raise ValueError("positions must be non-negative")
        return copy
    
    @staticmethod
    def encode(dirty:bool=None, alive:bool=None, solid:bool=None, destructable:bool=None, visible:bool=None) -> int:
        f: int = 0
        if dirty:
            f |= int(ROW.DIRTY)
        if alive:
            f |= int(ROW.ALIVE)
        if solid:
            f |= int(ROW.SOLID)
        if destructable:
            f |= int(ROW.DESTRUCTABLE)
        if visible:
            f |= int(ROW.VISIBLE)
        return f
    
    @staticmethod
    def decode(flags) -> tuple[bool, bool, bool, bool, bool]:
        f: int = int(flags)

        dirty = (f & int(ROW.DIRTY)) != 0
        alive = (f & int(ROW.ALIVE)) != 0
        solid = (f & int(ROW.SOLID)) != 0
        destr = (f & int(ROW.DESTRUCTABLE)) != 0
        visib = (f & int(ROW.VISIBLE)) != 0

        return dirty, alive, solid, destr, visib








################################################################################
# FILE 13/14: world/row.py (END)
################################################################################


################################################################################
# FILE 14/14: world/rows.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    pass


import numpy as np
from numpy.typing import NDArray

from world.row import ROW
from utils.bvh import BVH
from world.materials import Materials, MATERIALS
from utils.types import POS, SIZE





class ROWS:
    SIZE = 65536  # 64K rows # for each material
    def __init__(self) -> None:
        self.size = ROWS.SIZE
        self.mats = Materials()
        self.bvh = BVH(rows=self)
        # n is a dict of n
        self.n:dict[int, int] = {mid: 0 for mid in range(MATERIALS.NUM)}  # number of valid rows per material
        self.m = 0  # for the total number of rows used

        self.array: NDArray[ROW.DTYPE] = np.full((MATERIALS.NUM, self.size, *ROW.SHAPE), fill_value=ROW.SENTINEL, dtype=ROW.DTYPE)
        self.shape = self.array.shape
        self.nbytes = self.array.nbytes
        self.gbytes = self.nbytes / (1024**3)

        mat = "STONE"
        self.append(p0=(ROW.XMIN, ROW.YMIN, ROW.ZMIN), p1=(ROW.XMAX, ROW.YMAX, ROW.ZMAX), mat=mat)  # alive and dirty by default are true so no need to specify : easier to use now!!!


    def newn(self, mat:str=None) -> int:
        mid: int = MATERIALS.IDX[mat]
        n: int = self.n[mid]
        self.n[mid] += 1
        self.m += 1
        return n
    
    def deln(self, mat: str=None) -> int:
        if mat is None:
            raise ValueError("material must be specified")
        mid = MATERIALS.IDX[mat]
        if self.n[mid] <= 0:
            raise ValueError("no rows to free")
        self.n[mid] -= 1
        self.m -= 1
        return self.n[mid]
            

    def append(self, p0:POS=None, p1:POS=None, mat:str=None, dirty:bool=True, alive:bool=True) -> ROWS:
        matid: int = MATERIALS.IDX[mat]
        rid: int = self.newn(mat=mat)
        self.array[matid][rid] = ROW.new(p0=p0, p1=p1, mat=mat, rid=rid, dirty=dirty, alive=alive) # added rid=n so that bvh can use it when i provide a row as argument
        self.bvh.insert(mat=mat, rid=rid)  # insert into bvh index
        return self
    
    def delete(self, index: int, mat: str) -> ROWS:
        matid = MATERIALS.IDX[mat]
        n = self.n[matid]
        if index < 0 or index >= n:
            raise IndexError("index out of range")
        last = n - 1
        self.bvh.remove(mat=mat, rid=index)

        if index != last:
            self.bvh.remove(mat=mat, rid=last)
            self.array[matid][index] = self.array[matid][last]
            self.array[matid][index][*ROW.ID] = np.uint64(index)
            self.bvh.insert(mat=mat, rid=index)

        self.array[matid][last] = ROW.ARRAY
        self.deln(mat=mat)
        return self
    

    def find(self, pos:POS=None) -> tuple[str, int, NDArray[ROW.DTYPE]]:
        mat, rid, row = self.bvh.find(pos=pos)
        return (mat, rid, row)

    def len(self) -> int:
        return len(self.array)
    
    def nrows(self, mat:str=None) -> int:
        return self.n[MATERIALS.IDX[mat]]

    def __repr__(self) -> str:
        return self.__str__()

    def __str__(self) -> str:
        n = self.nrows(mat="STONE")
        return f"ROWS(shape={self.shape}, nbytes={self.nbytes}, gbytes={self.gbytes:.3f} with {n} valid rows)"





rows = ROWS()

################################################################################
# FILE 14/14: world/rows.py (END)
################################################################################

# Total lines in bundle: 1736
# Total files in bundle: 14
# Generated at the time: 2026-01-29T08:03:11.252073
--- END OF FILE ---

################################################################################
### CAPTURED OUTPUT ###
################################################################################

### PROGRAM OUTPUT (CAPTURED IN-PROCESS) ###
Root: C:\VOXELS
### OUTPUT START ###

3D grid partition built: lap 3: 4.957063 seconds, total 4.983131 seconds
All random CONTAINS checks passed. Successes: 1000, Fails: 0 is a succes percentage of 100.00% adn per lookup 201.73 lookups/second
Random CONTAINS checks completed in: lap 4: 0.398972 seconds, total 5.382103 seconds
Now deleting all rows...
All 10000 rows deleted in: lap 5: 0.340338 seconds, total 5.722441 seconds
Rebuilding rows after deletion...
second time 3D grid partition built: lap 6: 0.520715 seconds, total 6.243156 seconds
All random CONTAINS checks passed. Successes: 1000, Fails: 0 is a succes percentage of 100.00% adn per lookup 1920.44 lookups/second
Second random CONTAINS checks completed in: lap 7: 0.176746 seconds, total 6.419902 seconds
ALL TESTS PASSED SUCCESSFULLY!
main.py: executed in: lap 8: 0.000161 seconds, total 6.420063 seconds

### OUTPUT END ###
################################################################################
### END OF CAPTURED OUTPUT ###
################################################################################
