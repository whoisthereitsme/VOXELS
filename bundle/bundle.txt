#Time when generated: 2026-01-31T07:43:54

### PROJECT BUNDLE ###
Root: C:\VOXELS
Files included: 42


################################################################################
# FILE 1/42: __init__.py (START)
################################################################################

import utils
import world
import bundle

__all__ = world.__all__ + utils.__all__ + bundle.__all__


################################################################################
# FILE 1/42: __init__.py (END)
################################################################################


################################################################################
# FILE 2/42: __main__.py (START)
################################################################################

from main import main

if __name__ == "__main__":
    main()

################################################################################
# FILE 2/42: __main__.py (END)
################################################################################


################################################################################
# FILE 3/42: all/__init__.py (START)
################################################################################

from bundle import *
from bundle import __all__ as allbundle

from utils import *
from utils import __all__ as allutils

from world import *
from world import __all__ as allworld

from tests import *
from tests import __all__ as alltests


__all__ = [] + allbundle + allutils + allworld + alltests

print(f"Loaded ALL with {len(__all__)} items.")
for name in __all__:
    print(f" - {name}")

################################################################################
# FILE 3/42: all/__init__.py (END)
################################################################################


################################################################################
# FILE 4/42: bundle/__init__.py (START)
################################################################################

from .bundle import *
from .github import *

__all__ = [
    "Bundle",
    "GitHub",
]

################################################################################
# FILE 4/42: bundle/__init__.py (END)
################################################################################


################################################################################
# FILE 5/42: bundle/bundle.py (START)
################################################################################

from __future__ import annotations
import atexit
import sys
import threading
import time
from pathlib import Path
from typing import Iterable, Optional, Set, TextIO, Callable


from .github import GitHub


# ============================================================
# Bundle builder with integrated output capture (no output.txt, no HTML)
# ============================================================

class Bundle:
    class _Tee(TextIO):
        def __init__(self, original: TextIO, buffer: list[str], lock: threading.Lock) -> None:
            self._original = original
            self._buffer = buffer
            self._lock = lock

            

        def write(self, s: str) -> int:
            n = self._original.write(s)
            with self._lock:
                self._buffer.append(s)
            return n

        def flush(self) -> None:
            self._original.flush()

        def isatty(self) -> bool:
            return getattr(self._original, "isatty", lambda: False)()

        @property
        def encoding(self):
            return getattr(self._original, "encoding", "utf-8")

    def __init__(
        self,
        *,
        root: Path | None = None,
        out: Path | None = None,
        exts: Set[str] | None = None,
        dirs: Set[str] | None = None,
        skip: Set[str] | None = None,
        max_bytes: int = 2_000_000,
        overwrite: bool = True,
        include_stderr: bool = True,
        marker_prefix: str = "### CAPTURE START ###",
        auto_end_on_exit: bool = True,
        auto_end_on_exception: bool = True,
    ) -> None:
        self.root = (root if root is not None else Path.cwd()).resolve()
        self.out = (out if out is not None else (self.root / "bundle" / "bundle.txt")).resolve()

        self.exts = exts if exts is not None else {
            ".py", ".pyi", ".txt", ".md", ".json", ".toml", ".yaml", ".yml", ".ini", ".cfg", ".bat", ".ps1", ".sh",
        }
        self.dirs = dirs if dirs is not None else {
            ".git", ".hg", ".svn", ".idea", ".vscode",
            "__pycache__", ".pytest_cache", ".mypy_cache", ".ruff_cache", ".tox",
            ".venv", "venv", "env",
            "node_modules", "dist", "build",
            "atlas", "_old", "__OLD",
        }
        self.skip = skip if skip is not None else {".DS_Store", "Thumbs.db"}
        self.max_bytes = int(max_bytes)
        self.overwrite = bool(overwrite)

        self.include_stderr = bool(include_stderr)
        self.marker_prefix = str(marker_prefix)

        self._lock = threading.Lock()
        self._buf_out: list[str] = []
        self._buf_err: list[str] = []

        self._orig_stdout: Optional[TextIO] = None
        self._orig_stderr: Optional[TextIO] = None
        self._orig_excepthook: Optional[Callable] = None
        self._ended = False

        self.start_capture()

        if auto_end_on_exit:
            atexit.register(self.stop_capture_and_write_bundle)

        if auto_end_on_exception:
            self._install_excepthook()

        self.github = GitHub

    def __enter__(self) -> "Bundle":
        return self

    def __exit__(self, exc_type, exc, tb) -> bool:
        self.stop_capture_and_write_bundle()
        self.github()
        return False

    def _install_excepthook(self) -> None:
        self._orig_excepthook = sys.excepthook

        def hooked(exctype, value, tb) -> None:
            if self._orig_excepthook is not None:
                self._orig_excepthook(exctype, value, tb)
            self.stop_capture_and_write_bundle()

        sys.excepthook = hooked  # type: ignore[assignment]

    def start_capture(self) -> None:
        self._orig_stdout = sys.stdout
        self._orig_stderr = sys.stderr

        sys.stdout = self._Tee(self._orig_stdout, self._buf_out, self._lock)  # type: ignore[assignment]
        if self.include_stderr:
            sys.stderr = self._Tee(self._orig_stderr, self._buf_err, self._lock)  # type: ignore[assignment]

        print(f"{self.marker_prefix} root={self.root.as_posix()}")

    def stop_capture_and_write_bundle(self) -> Path:
        captured = self._end_capture_get_text()
        return self.write_bundle_txt(captured_output=captured)

    def _end_capture_get_text(self) -> str:
        if self._ended:
            with self._lock:
                out_text = "".join(self._buf_out)
                err_text = "".join(self._buf_err)
            return self._combine_streams(out_text, err_text)

        self._ended = True

        if self._orig_stdout is not None:
            sys.stdout = self._orig_stdout  # type: ignore[assignment]
        if self.include_stderr and self._orig_stderr is not None:
            sys.stderr = self._orig_stderr  # type: ignore[assignment]

        if self._orig_excepthook is not None:
            sys.excepthook = self._orig_excepthook  # type: ignore[assignment]

        with self._lock:
            out_text = "".join(self._buf_out)
            err_text = "".join(self._buf_err)

        combined = self._combine_streams(out_text, err_text)

        marker_line = f"{self.marker_prefix} root={self.root.as_posix()}"
        combined = self._keep_after_marker(combined, marker_line)
        return combined

    def _combine_streams(self, out_text: str, err_text: str) -> str:
        combined = out_text
        if self.include_stderr and err_text:
            if combined and not combined.endswith("\n"):
                combined += "\n"
            combined += err_text
        return combined

    @staticmethod
    def _keep_after_marker(text: str, marker_line: str) -> str:
        idx = text.rfind(marker_line)
        if idx == -1:
            return text
        nl = text.find("\n", idx)
        if nl == -1:
            return ""
        return text[nl + 1 :]

    def write_bundle_txt(self, *, captured_output: str) -> Path:
        self.out.parent.mkdir(parents=True, exist_ok=True)
        if self.overwrite and self.out.exists():
            self.out.unlink()

        generated_at = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime())
        files = sorted(self._iter_files(self.root), key=lambda p: str(p.relative_to(self.root)).lower())

        lines: list[str] = []
        lines.append(f"#Time when generated: {generated_at}\n\n")
        lines.append("### PROJECT BUNDLE ###\n")
        lines.append(f"Root: {self.root}\n")
        lines.append(f"Files included: {len(files)}\n\n")

        for i, p in enumerate(files, start=1):
            rel = p.relative_to(self.root).as_posix()

            lines.append("\n" + "#" * 80 + "\n")
            lines.append(f"# FILE {i}/{len(files)}: {rel} (START)\n")
            lines.append("#" * 80 + "\n\n")

            content = self._safe_read_text_lossy(p)
            if content and not content.endswith("\n"):
                content += "\n"
            lines.append(content)

            lines.append("\n" + "#" * 80 + "\n")
            lines.append(f"# FILE {i}/{len(files)}: {rel} (END)\n")
            lines.append("#" * 80 + "\n\n")

        if captured_output.strip():
            lines.append("\n" + "################################################################################\n")
            lines.append("### CAPTURED OUTPUT (STDOUT/STDERR) ###\n")
            lines.append("################################################################################\n\n")
            lines.append(captured_output if captured_output.endswith("\n") else captured_output + "\n")
            lines.append("\n################################################################################\n")
            lines.append("### END OF CAPTURED OUTPUT ###\n")
            lines.append("################################################################################\n")

        final_text = "".join(lines)
        if not final_text.endswith("\n"):
            final_text += "\n"

        total_lines = final_text.count("\n")
        final_text += f"# Total lines in bundle: {total_lines}\n"
        final_text += f"# Total files in bundle: {len(files)}\n"
        final_text += f"# Generated at the time: {time.strftime('%Y-%m-%dT%H:%M:%S', time.localtime())}\n"
        final_text += "--- END OF FILE ---\n"

        self.out.write_text(final_text, encoding="utf-8")
        return self.out

    def _iter_files(self, root: Path) -> Iterable[Path]:
        for p in root.rglob("*"):
            if p.is_dir():
                continue

            parts = set(p.parts)
            if any(d in parts for d in self.dirs):
                continue
            if p.name in self.skip:
                continue
            if p.suffix.lower() not in self.exts:
                continue

            try:
                if p.stat().st_size > self.max_bytes:
                    continue
            except OSError:
                continue

            yield p

    @staticmethod
    def _safe_read_text_lossy(path: Path) -> str:
        try:
            return path.read_text(encoding="utf-8")
        except UnicodeDecodeError:
            return path.read_text(encoding="utf-8", errors="replace")
        except OSError as e:
            return f"<<ERROR READING FILE: {e}>>\n"






################################################################################
# FILE 5/42: bundle/bundle.py (END)
################################################################################


################################################################################
# FILE 6/42: bundle/github.py (START)
################################################################################

import base64
import json
import threading
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Optional, Set

from credentials import *
from utils import Request




@dataclass(frozen=True)
class FileJob:
    local_path: Path
    repo_path: str


class GitHub:
    def __init__(
        self,
        root: Path = Path.cwd(),
        verbose: bool = False,
        workers: int = 12,
        message: str = "Publish project snapshot",
        exts: Optional[Set[str]] = None,
        dirs: Optional[Set[str]] = None,
        files: Optional[Set[str]] = None,
        bytes: int = 2_000_000,
        binary: bool = True,
    ) -> None:
        self.owner = Environ.githublogin
        self.token = Environ.githubtoken
        self.repo = "VOXELS"
        self.branch = "main"
        self.root = root.resolve()
        
        self.verbose = verbose
        self.workers = workers
        self.message = message

        self.exts = exts
        self.dirs = dirs or {
            ".git", ".hg", ".svn",
            ".idea", ".vscode",
            "__pycache__", ".pytest_cache", ".mypy_cache", ".ruff_cache", ".tox",
            ".venv", "venv", "env",
            "node_modules", "dist", "build",
            ".gradle", ".terraform",
            "atlas", "_old", "__OLD",
        }
        self.files = files or {".DS_Store", "Thumbs.db"}
        self.bytes = bytes
        self.binary = binary

        self.lock = threading.Lock()

        self.publish()

    def publish(self) -> None:
        t0 = time.perf_counter()
        if not self.token:
            raise SystemExit(f"Missing environment variable GITHUB_TOKEN.\n", f"Create a fine-grained PAT (Contents: read+write) for repo {self.owner}/{self.repo}.")

        if not self.root.exists() or not self.root.is_dir():
            raise SystemExit(f"root does not exist or is not a directory: {self.root}")

        jobs = self._build_jobs()
        self._log(f"[GITHUB] single-commit publish: {len(jobs)} files from {self.root} -> {self.owner}/{self.repo}@{self.branch}")

        head_commit_sha = self._get_branch_head_commit_sha(self.token)
        base_tree_sha = self._get_commit_tree_sha(self.token, head_commit_sha)

        path_to_blob_sha = self._create_blobs_parallel(self.token, jobs)
        new_tree_sha = self._create_tree(self.token, base_tree_sha, path_to_blob_sha)
        new_commit_sha = self._create_commit(self.token, new_tree_sha, head_commit_sha)
        self._update_branch_ref(self.token, new_commit_sha)

        dt = time.perf_counter() - t0
        self._log(f"[GITHUB] done: 1 commit, {len(jobs)} files, elapsed {dt:.2f}s. files/sec: {len(jobs)/dt:.1f}")

    def _build_jobs(self) -> list[FileJob]:
        files = sorted(self._iter_project_files(self.root), key=lambda p: str(p).lower())
        return [FileJob(p, p.relative_to(self.root).as_posix()) for p in files]

    def _iter_project_files(self, root: Path) -> Iterable[Path]:
        for p in root.rglob("*"):
            if p.is_dir():
                continue

            parts = set(p.parts)
            if any(d in parts for d in self.dirs):
                continue
            if p.name in self.files:
                continue
            if self.exts is not None and p.suffix.lower() not in self.exts:
                continue

            try:
                if p.stat().st_size > self.bytes:
                    continue
            except OSError:
                continue

            if self.binary:
                try:
                    data = p.read_bytes()
                except OSError:
                    continue
                if self._looks_binary(data):
                    continue

            yield p

    @staticmethod
    def _looks_binary(data: bytes) -> bool:
        if b"\x00" in data:
            return True
        sample = data[:8192]
        if not sample:
            return False
        bad = 0
        for b in sample:
            if b in (9, 10, 13) or 32 <= b <= 126:
                continue
            bad += 1
        return (bad / len(sample)) > 0.20

    # -----------------------------
    # GitHub API core
    # -----------------------------
    def _api_request(self, method: str, url: str, token: str, body: Optional[dict] = None) -> dict:
        data = None
        if body is not None:
            data = json.dumps(body).encode("utf-8")

        req = Request(url=url, data=data, method=method, timeout=600, retries=3)
        req.header("Authorization", f"Bearer {token}")
        req.header("Accept", "application/vnd.github+json")
        req.header("X-GitHub-Api-Version", "2022-11-28")
        if data is not None:
            req.header("Content-Type", "application/json; charset=utf-8")

        return req.open()

    def _get_branch_head_commit_sha(self, token: str) -> str:
        url = f"https://api.github.com/repos/{self.owner}/{self.repo}/git/ref/heads/{self.branch}"
        j = self._api_request("GET", url, token)
        return j["object"]["sha"]

    def _get_commit_tree_sha(self, token: str, commit_sha: str) -> str:
        url = f"https://api.github.com/repos/{self.owner}/{self.repo}/git/commits/{commit_sha}"
        j = self._api_request("GET", url, token)
        return j["tree"]["sha"]

    def _create_blob(self, token: str, content_bytes: bytes) -> str:
        url = f"https://api.github.com/repos/{self.owner}/{self.repo}/git/blobs"
        body = {"content": base64.b64encode(content_bytes).decode("ascii"), "encoding": "base64"}
        j = self._api_request("POST", url, token, body=body)
        return j["sha"]

    def _create_blobs_parallel(self, token: str, jobs: list[FileJob]) -> dict[str, str]:
        out: dict[str, str] = {}
        lock = threading.Lock()

        def worker(job: FileJob) -> None:
            data = job.local_path.read_bytes()
            sha = self._create_blob(token, data)
            with lock:
                out[job.repo_path] = sha
            if self.verbose:
                self._log(f"    [blob] {job.repo_path}")

        with ThreadPoolExecutor(max_workers=self.workers) as ex:
            futures = [ex.submit(worker, j) for j in jobs]
            for fut in as_completed(futures):
                fut.result()

        return out

    def _create_tree(self, token: str, base_tree_sha: str, path_to_blob_sha: dict[str, str]) -> str:
        url = f"https://api.github.com/repos/{self.owner}/{self.repo}/git/trees"
        tree_entries = [
            {"path": path, "mode": "100644", "type": "blob", "sha": blob_sha}
            for path, blob_sha in path_to_blob_sha.items()
        ]
        body = {"base_tree": base_tree_sha, "tree": tree_entries}
        j = self._api_request("POST", url, token, body=body)
        return j["sha"]

    def _create_commit(self, token: str, tree_sha: str, parent_commit_sha: str) -> str:
        url = f"https://api.github.com/repos/{self.owner}/{self.repo}/git/commits"
        body = {"message": self.message, "tree": tree_sha, "parents": [parent_commit_sha]}
        j = self._api_request("POST", url, token, body=body)
        return j["sha"]

    def _update_branch_ref(self, token: str, new_commit_sha: str) -> None:
        url = f"https://api.github.com/repos/{self.owner}/{self.repo}/git/refs/heads/{self.branch}"
        body = {"sha": new_commit_sha, "force": False}
        self._api_request("PATCH", url, token, body=body)

    def _log(self, msg: str) -> None:
        with self.lock:
            print(msg)


################################################################################
# FILE 6/42: bundle/github.py (END)
################################################################################


################################################################################
# FILE 7/42: credentials/__init__.py (START)
################################################################################

from .environ import Environ

__all__ = [
    "Environ"
]   

################################################################################
# FILE 7/42: credentials/__init__.py (END)
################################################################################


################################################################################
# FILE 8/42: credentials/environ.py (START)
################################################################################




import os



class Environ:
    githublogin = os.getenv("GITHUB_LOGIN")
    githubtoken = os.getenv("GITHUB_TOKEN")
    mailadress  = os.getenv("MAIL_ADRESS")
    phonenumber = os.getenv("PHONE_NUMBER")
    ippublic    = os.getenv("IP_PUBLIC")
    ipprivate   = os.getenv("IP_PRIVATE")
    sshkey      = os.getenv("SSH_KEY")


################################################################################
# FILE 8/42: credentials/environ.py (END)
################################################################################


################################################################################
# FILE 9/42: main.py (START)
################################################################################

from all import *





if __name__ == "__main__":
    tests(tests=[test8])

################################################################################
# FILE 9/42: main.py (END)
################################################################################


################################################################################
# FILE 10/42: tests/__init__.py (START)
################################################################################


from .test1 import test1
from .test2 import test2
from .test3 import test3
from .test4 import test4
from .test5 import test5
from .test6 import test6
from .test7 import test7
from .test8 import test8
from .test9 import test9
from .test10 import test10
from .tests import tests

__all__ = [
    "test1",
    "test2",
    "test3",
    "test4",
    "test5",
    "test6",
    "test7",
    "test8",
    "test9",
    "test10",
    "tests",
]

################################################################################
# FILE 10/42: tests/__init__.py (END)
################################################################################


################################################################################
# FILE 11/42: tests/test1.py (START)
################################################################################

# tests/test1.py

from utils import *
from world import *
from bundle import *


def test1() -> None:
    """
    test1:
    Build a dense 3D grid of STONE AABBs, then verify BVH partition integrity by:
    - random point lookups must always find a row
    - found row must CONTAIN the queried point
    Then delete a chunk of rows, rebuild a different grid, and re-run the same checks.
    """
    rows = ROWS()

    # remove the default huge row (STONE rid=0)
    rows.remove(row=rows.get(mat="STONE", rid=0))

    # STEP 1 grid
    cell = 20
    nx = 40
    ny = 40
    nz = 40

    timer.lap()
    for ix in range(nx):
        x0 = ix * cell
        x1 = x0 + cell
        for iy in range(ny):
            y0 = iy * cell
            y1 = y0 + cell
            for iz in range(nz):
                z0 = iz * cell
                z1 = z0 + cell
                rows.insert(p0=(x0, y0, z0), p1=(x1, y1, z1), mat="STONE")
    timer.print(msg="STEP 1 : 3D grid partition built")

    max_x = nx * cell - 1
    max_y = ny * cell - 1
    max_z = nz * cell - 1

    succes = 0
    fails = 0
    for _ in range(1000):
        pos = (
            random.randint(0, max_x),
            random.randint(0, max_y),
            random.randint(0, max_z),
        )
        try:
            mat, rid, row = rows.search(pos=pos)
            assert ROW.CONTAINS(row=row, pos=pos), (
                f"pos={pos} not contained (mat={mat}, rid={rid}) "
                f"p0={ROW.P0(row=row)} p1={ROW.P1(row=row)}"
            )
            succes += 1
        except Exception:
            fails += 1
            raise

    assert fails == 0, f"BVH/grid lookup failures in STEP 1: {fails} (success={succes})"
    print(f" - STEP 1 lookup checks OK: {succes} successes, {fails} fails, {succes/timer.delta[-1]:.2f} lookups/sec")
    timer.print(msg=" - STEP 1 lookups completed in")

    # delete some rows (stress BVH remove/swap)
    print(" - Now deleting 10000 rows...")
    for _ in range(10000):
        rid_last = rows.nrows(mat="STONE") - 1
        rows.remove(row=rows.get(mat="STONE", rid=rid_last))
    timer.print(msg=" - Deleted 10000 rows in")

    # STEP 2 grid â€” rebuild from scratch for clean bounds
    while rows.nrows(mat="STONE") > 0:
        rid_last = rows.nrows(mat="STONE") - 1
        rows.remove(row=rows.get(mat="STONE", rid=rid_last))

    print("STEP 2 : Rebuilding rows after deletion...")
    cell = 40
    nx = 20
    ny = 20
    nz = 20

    timer.lap()
    for ix in range(nx):
        x0 = ix * cell
        x1 = x0 + cell
        for iy in range(ny):
            y0 = iy * cell
            y1 = y0 + cell
            for iz in range(nz):
                z0 = iz * cell
                z1 = z0 + cell
                rows.insert(p0=(x0, y0, z0), p1=(x1, y1, z1), mat="STONE")
    timer.print(msg=" - STEP 2 grid partition built")

    max_x = nx * cell - 1
    max_y = ny * cell - 1
    max_z = nz * cell - 1

    succes = 0
    fails = 0
    for _ in range(1000):
        pos = (
            random.randint(0, max_x),
            random.randint(0, max_y),
            random.randint(0, max_z),
        )
        mat, rid, row = rows.search(pos=pos)
        assert ROW.CONTAINS(row=row, pos=pos), (
            f"pos={pos} not contained (mat={mat}, rid={rid}) "
            f"p0={ROW.P0(row=row)} p1={ROW.P1(row=row)}"
        )
        succes += 1

    assert fails == 0, f"BVH/grid lookup failures in STEP 2: {fails} (success={succes})"
    print(f" - STEP 2 lookup checks OK: {succes} successes, {fails} fails, {succes/timer.delta[-1]:.2f} lookups/sec")
    timer.print(msg=" - STEP 2 lookups completed in")

################################################################################
# FILE 11/42: tests/test1.py (END)
################################################################################


################################################################################
# FILE 12/42: tests/test10.py (START)
################################################################################



def test10() -> None:
    pass

################################################################################
# FILE 12/42: tests/test10.py (END)
################################################################################


################################################################################
# FILE 13/42: tests/test2.py (START)
################################################################################

# tests/test2.py

from utils import *
from world import *
from bundle import *


def test2() -> None:
    """
    test2:
    Random single-point splits into AIR inside the default big STONE row.
    Verifies:
    - world volume invariant
    - each split point becomes AIR
    - merge() does not break invariants
    """
    rows = ROWS()
    v0 = rows.volume()
    print("WORLD VOLUME BEFORE:", v0)

    points: list[POS] = []
    for i in range(10):
        x = random.randint(a=1000, b=999000)
        y = random.randint(a=1000, b=999000)
        z = random.randint(a=1000, b=64000)
        pos = (x, y, z)
        points.append(pos)
        rows.split(pos=pos, mat="AIR")
        print(f" - SPLIT test {i+1}/10 passed.")

    v1 = rows.volume()
    print("WORLD VOLUME AFTER:", v1)
    assert v1 == v0, f"volume changed after splits: before={v0}, after={v1}"

    for pos in points:
        mat, rid, row = rows.search(pos=pos)
        assert mat == "AIR", f"expected AIR at {pos}, got {mat}"

    timer.print(msg="STARTING STEP : Now testing MERGE functionality...")
    rows.merge()
    timer.print(msg=" - MERGE completed in")

    v2 = rows.volume()
    print("WORLD VOLUME AFTER MERGE:", v2)
    assert v2 == v0, f"volume changed after merge: before={v0}, after={v2}"

    for pos in points:
        mat, rid, row = rows.search(pos=pos)
        assert mat == "AIR", f"expected AIR at {pos} after merge, got {mat}"

    for mid in range(len(rows.array)):
        name = Materials.mid2name[mid]
        n = rows.nrows(mat=name)
        print(f"Material {name} has {n} rows after MERGE tests.")

################################################################################
# FILE 13/42: tests/test2.py (END)
################################################################################


################################################################################
# FILE 14/42: tests/test3.py (START)
################################################################################

# tests/test3.py

from utils import *
from world import *
from bundle import *


def test3() -> None:
    """
    test3:
    Create multiple 5x5x5 "mines" (AIR blocks) at random places and run merge attempts.
    Verifies:
    - world volume invariant
    - all mine points remain AIR
    """
    rows = ROWS()
    v0 = rows.volume()

    mines: list[POS] = []
    for _ in range(10):
        x = random.randint(a=1000, b=999000)
        y = random.randint(a=1000, b=999000)
        z = random.randint(a=1000, b=64000)
        mines.append((x, y, z))
    print(len(mines), "mines to be created at random positions.")

    mine_points: list[POS] = []
    for mine in mines:
        for dx in range(5):
            for dy in range(5):
                for dz in range(5):
                    pos = (mine[0] + dx, mine[1] + dy, mine[2] + dz)
                    mine_points.append(pos)
                    rows.split(pos=pos, mat="AIR")

    # merge attempts
    rowsbefore = rows.nrows(mat="AIR")
    for i in range(10):
        print("Performing MERGE to consolidate AIR rows... AIR rows before:", rows.nrows(mat="AIR"), "in merge iteration:", i + 1)
        rows.merge()
        rowsafter = rows.nrows(mat="AIR")
        if rowsafter == rowsbefore:
            print(" No more AIR rows could be consolidated. Stopping MERGE.")
            break
        rowsbefore = rowsafter

    v1 = rows.volume()
    assert v1 == v0, f"volume changed: before={v0}, after={v1}"

    # verify all mine points still AIR
    for pos in random.sample(mine_points, k=min(2000, len(mine_points))):
        mat, rid, row = rows.search(pos=pos)
        assert mat == "AIR", f"expected AIR at {pos}, got {mat}"

    for mid in range(len(rows.array)):
        name = Materials.mid2name[mid]
        n = rows.nrows(mat=name)
        print(f"Material {name} has {n} rows after MERGE tests.")
        if name == "AIR":
            for rid in range(n):
                r = rows.get(mat="AIR", rid=rid)
                print(f"  AIR row {rid}: p0={ROW.P0(row=r.row)}, p1={ROW.P1(row=r.row)}")

    print(f"air rows= {rows.nrows(mat='AIR')}", f"stone rows= {rows.nrows(mat='STONE')}")

################################################################################
# FILE 14/42: tests/test3.py (END)
################################################################################


################################################################################
# FILE 15/42: tests/test4.py (START)
################################################################################

# tests/test4.py

from utils import *
from world import *
from bundle import *


def test4() -> None:
    """
    test4:
    Split off multiple *single-row-contained* regions (disjoint by construction) inside default big STONE row.
    Verifies:
    - world volume invariant
    - AIR volume equals sum of carved boxes (valid because we keep them disjoint)
    - random points inside carved boxes are AIR
    - random points far away are NOT AIR
    """
    rows = ROWS()
    v0 = rows.volume()
    print("WORLD VOLUME BEFORE:", v0)

    boxes: list[tuple[POS, POS]] = []
    total_air_vol = 0

    slot = 64
    for i in range(50):
        gx = random.randint(50, 2000) * slot
        gy = random.randint(50, 2000) * slot
        gz = random.randint(10, 900) * slot

        dx = random.randint(4, 48)
        dy = random.randint(4, 48)
        dz = random.randint(4, 32)

        x0 = gx + 1
        y0 = gy + 1
        z0 = gz + 1
        p0 = (x0, y0, z0)
        p1 = (x0 + dx, y0 + dy, z0 + dz)
        p0, p1 = ROW.SORT(p0=p0, p1=p1)

        rows.split(pos=p0, pos1=p1, mat="AIR")
        boxes.append((p0, p1))
        total_air_vol += (p1[0] - p0[0]) * (p1[1] - p0[1]) * (p1[2] - p0[2])

        if (i + 1) % 10 == 0:
            print(f" - carved {i+1}/50 boxes")

    rows.merge()

    v1 = rows.volume()
    print("WORLD VOLUME AFTER:", v1)
    assert v1 == v0, f"volume changed: before={v0}, after={v1}"

    air_vol = rows.volume(mat="AIR")
    print("AIR VOLUME:", air_vol, "EXPECTED (sum boxes):", total_air_vol)
    assert air_vol == total_air_vol, f"AIR volume mismatch: got={air_vol}, expected={total_air_vol}"

    for _ in range(500):
        p0, p1 = random.choice(boxes)
        x = random.randint(p0[0], p1[0] - 1)
        y = random.randint(p0[1], p1[1] - 1)
        z = random.randint(p0[2], p1[2] - 1)
        mat, rid, row = rows.search(pos=(x, y, z))
        assert mat == "AIR", f"expected AIR at {(x,y,z)}, got {mat}"

    for _ in range(500):
        x = random.randint(10, 900)
        y = random.randint(10, 900)
        z = random.randint(10, 900)
        mat, rid, row = rows.search(pos=(x, y, z))
        assert mat != "AIR", f"unexpected AIR at {(x,y,z)}"

    print("test4 OK:", f"air_rows={rows.nrows(mat='AIR')}", f"stone_rows={rows.nrows(mat='STONE')}")

################################################################################
# FILE 15/42: tests/test4.py (END)
################################################################################


################################################################################
# FILE 16/42: tests/test5.py (START)
################################################################################

# tests/test5.py

from utils import *
from world import *
from bundle import *


def test5() -> None:
    """
    test5:
    Split off regions that span multiple rows (overlapping allowed).
    Verifies:
    - world volume invariant
    - AIR volume computed via rows.volume(mat="AIR")
    - random points inside carved regions are AIR
    """
    rows = ROWS()

    # remove default huge STONE row
    rows.remove(row=rows.get(mat="STONE", rid=0))

    cell = 64
    nx = 20
    ny = 20
    nz = 8

    for ix in range(nx):
        x0 = ix * cell
        x1 = x0 + cell
        for iy in range(ny):
            y0 = iy * cell
            y1 = y0 + cell
            for iz in range(nz):
                z0 = iz * cell
                z1 = z0 + cell
                rows.insert(p0=(x0, y0, z0), p1=(x1, y1, z1), mat="STONE")

    rows.merge()

    max_x = nx * cell
    max_y = ny * cell
    max_z = nz * cell

    v0 = rows.volume()
    print("WORLD VOLUME BEFORE:", v0)
    print("Initial rows:", f"stone_rows={rows.nrows(mat='STONE')}", f"air_rows={rows.nrows(mat='AIR')}")

    carved_boxes: list[tuple[POS, POS]] = []

    for i in range(30):
        dx = random.randint(cell + 5, cell * 3)
        dy = random.randint(cell + 5, cell * 3)
        dz = random.randint(cell + 5, cell * 2)

        ox = random.randint(1, cell - 2)
        oy = random.randint(1, cell - 2)
        oz = random.randint(1, cell - 2)

        x0_base = random.randint(0, max_x - dx - ox)
        y0_base = random.randint(0, max_y - dy - oy)
        z0_base = random.randint(0, max_z - dz - oz)

        x0 = x0_base + ox
        y0 = y0_base + oy
        z0 = z0_base + oz

        x1 = min(x0 + dx, max_x)
        y1 = min(y0 + dy, max_y)
        z1 = min(z0 + dz, max_z)

        p0, p1 = ROW.SORT(p0=(x0, y0, z0), p1=(x1, y1, z1))
        if p0[0] >= p1[0] or p0[1] >= p1[1] or p0[2] >= p1[2]:
            continue

        rows.split(pos=p0, pos1=p1, mat="AIR")
        carved_boxes.append((p0, p1))

        if (i + 1) % 10 == 0:
            print(f" - carved {i+1}/30 boxes")

    rows.merge()

    v1 = rows.volume()
    print("WORLD VOLUME AFTER:", v1)
    assert v1 == v0, f"world volume changed: before={v0}, after={v1}"

    air_vol = rows.volume(mat="AIR")
    print("AIR VOLUME:", air_vol)

    for _ in range(1000):
        p0, p1 = random.choice(carved_boxes)
        x = random.randint(p0[0], p1[0] - 1)
        y = random.randint(p0[1], p1[1] - 1)
        z = random.randint(p0[2], p1[2] - 1)
        mat, rid, row = rows.search(pos=(x, y, z))
        assert mat == "AIR", f"expected AIR at {(x,y,z)}, got {mat}"

    print("test5 OK:", f"air_rows={rows.nrows(mat='AIR')}", f"stone_rows={rows.nrows(mat='STONE')}")

################################################################################
# FILE 16/42: tests/test5.py (END)
################################################################################


################################################################################
# FILE 17/42: tests/test6.py (START)
################################################################################

# tests/test6.py

from utils import *
from world import *
from bundle import *


def test6() -> None:
    """
    test6:
    Timing benchmark: 100 calls per operation category.
    IMPORTANT: each category runs on a fresh baseline world so timings stay comparable.
    """
    print("=== TEST6: TIMING BENCHMARK (100 calls per op, fresh world per op) ===")
    ntests = 10

    def make_world() -> tuple[ROWS, int, int, int, int]:
        rows = ROWS()

        # remove default huge STONE row
        rows.remove(row=rows.get(mat="STONE", rid=0))

        cell = 64
        nx, ny, nz = 20, 20, 8
        for ix in range(nx):
            for iy in range(ny):
                for iz in range(nz):
                    x0 = ix * cell
                    y0 = iy * cell
                    z0 = iz * cell
                    rows.insert(
                        p0=(x0, y0, z0),
                        p1=(x0 + cell, y0 + cell, z0 + cell),
                        mat="STONE",
                    )

        rows.merge()
        max_x = nx * cell - 1
        max_y = ny * cell - 1
        max_z = nz * cell - 1
        return rows, cell, max_x, max_y, max_z

    # 1) SEARCH
    rows, cell, max_x, max_y, max_z = make_world()
    timer.lap()
    for _ in range(ntests):
        pos = (random.randint(0, max_x), random.randint(0, max_y), random.randint(0, max_z))
        rows.search(pos=pos)
    timer.print(msg=f"test6: search() [tests={ntests}]")

    # 2) SPLIT1
    rows, cell, max_x, max_y, max_z = make_world()
    timer.lap()
    for _ in range(ntests):
        pos = (random.randint(10, max_x - 10), random.randint(10, max_y - 10), random.randint(10, max_z - 10))
        rows.split(pos=pos, mat="AIR")
    timer.print(msg=f"test6: split1 (point split) [tests={ntests}]")

    # 3) SPLIT2
    rows, cell, max_x, max_y, max_z = make_world()
    timer.lap()
    for _ in range(ntests):
        dx = random.randint(cell + 5, cell * 3)
        dy = random.randint(cell + 5, cell * 3)
        dz = random.randint(cell + 5, cell * 2)

        x0 = random.randint(0, max_x - dx)
        y0 = random.randint(0, max_y - dy)
        z0 = random.randint(0, max_z - dz)

        p0, p1 = ROW.SORT(p0=(x0, y0, z0), p1=(x0 + dx, y0 + dy, z0 + dz))
        rows.split(pos=p0, pos1=p1, mat="AIR")
    timer.print(msg=f"test6: split2 (region split) [tests={ntests}]")

    # 4) MERGE (meaningful merge: first fragment it a bit)
    rows, cell, max_x, max_y, max_z = make_world()
    for _ in range(200):
        pos = (random.randint(10, max_x - 10), random.randint(10, max_y - 10), random.randint(10, max_z - 10))
        rows.split(pos=pos, mat="AIR")
    timer.lap()
    for _ in range(ntests):
        rows.merge()
    timer.print(msg=f"test6: merge() [tests={ntests}]")

    # 5) REMOVE (remove from STONE preferentially)
    rows, cell, max_x, max_y, max_z = make_world()
    timer.lap()
    for _ in range(ntests):
        if rows.nrows(mat="STONE") <= 0:
            break
        rid_last = rows.nrows(mat="STONE") - 1
        rows.remove(row=rows.get(mat="STONE", rid=rid_last))
    timer.print(msg=f"test6: remove() [tests={ntests}]")

    # 6) INSERT (small inserts)
    rows, cell, max_x, max_y, max_z = make_world()
    timer.lap()
    for _ in range(ntests):
        x0 = random.randint(0, max_x - 2)
        y0 = random.randint(0, max_y - 2)
        z0 = random.randint(0, max_z - 2)
        rows.insert(p0=(x0, y0, z0), p1=(x0 + 1, y0 + 1, z0 + 1), mat="STONE")
    timer.print(msg=f"test6: insert() [tests={ntests}]")

    print("=== TEST6 DONE ===")

################################################################################
# FILE 17/42: tests/test6.py (END)
################################################################################


################################################################################
# FILE 18/42: tests/test7.py (START)
################################################################################

# tests/test7.py

from utils import *
from world import *


def test7() -> None:
    """
    test7:
    Bulletproof Resource/Resources/Warehouse invariants.
    """
    print("=== TEST7: RESOURCE / WAREHOUSE INVARIANTS ===")

    # 1) Resource.split() invariants
    for _ in range(1000):
        amount = random.randint(0, 10_000)
        value = random.randint(0, 12_000)

        r = Resource(mat="STONE", amount=amount)
        original = r.copy()

        part1, leftover = r.split(value=value)  # [taken, leftover]

        assert part1.mat == original.mat
        assert leftover.mat == original.mat

        assert 0 <= part1.amount <= original.amount
        assert 0 <= leftover.amount <= original.amount

        assert part1.amount == min(value, original.amount)
        assert part1.amount + leftover.amount == original.amount

    print(" - split() invariants OK (1000 cases)")

    # 2) Resource arithmetic semantics (mutating)
    a = Resource(mat="STONE", amount=50)
    b = Resource(mat="STONE", amount=20)

    a0 = a.amount
    b0 = b.amount
    a + b
    assert a.amount == a0 + b0
    assert b.amount == b0

    a = Resource(mat="STONE", amount=50)
    b = Resource(mat="STONE", amount=20)
    a += b
    assert a.amount == 70
    assert b.amount == 0

    a = Resource(mat="STONE", amount=50)
    b = Resource(mat="STONE", amount=20)
    a0 = a.amount
    b0 = b.amount
    a - b
    assert a.amount == a0 - b0
    assert b.amount == b0

    a = Resource(mat="STONE", amount=10)
    b = Resource(mat="STONE", amount=20)
    a0 = a.amount
    b0 = b.amount
    a - b
    assert a.amount == 0
    assert b.amount == b0

    a = Resource(mat="STONE", amount=10)
    b = Resource(mat="STONE", amount=20)
    a -= b
    assert a.amount == 0
    assert b.amount == 10

    print(" - Resource +/- semantics OK")

    # 3) Resources ingest/transfer semantics
    inv = Resources(rez=[])
    r1 = Resource(mat="STONE", amount=10)
    r2 = Resource(mat="STONE", amount=5)

    inv + r1
    assert inv.get(mat="STONE").amount == 10
    assert r1.amount == 10

    inv += r2
    assert inv.get(mat="STONE").amount == 15
    assert r2.amount == 0

    print(" - Resources ingest/transfer OK")

    # 4) Warehouse.give()/take() invariants
    wh = Warehouse(rows=None, pos=(0, 0, 0), size=(2, 2, 2))  # cap = 512
    assert wh.cap == 512
    assert wh.total() == 0
    assert wh.free() == 512

    incoming = Resource(mat="STONE", amount=600)
    leftover = wh.give(incoming=incoming)

    assert wh.get(mat="STONE").amount == 512
    assert leftover.mat == "STONE"
    assert leftover.amount == 88

    req = Resource(mat="STONE", amount=200)
    taken = wh.take(requested=req)

    assert taken.mat == "STONE"
    assert taken.amount == 200
    assert wh.get(mat="STONE").amount == 312

    req2 = Resource(mat="STONE", amount=9999)
    taken2 = wh.take(requested=req2)

    assert taken2.amount == 312
    assert wh.get(mat="STONE").amount == 0

    print(" - Warehouse give/take invariants OK")
    print("=== TEST7 DONE ===")

################################################################################
# FILE 18/42: tests/test7.py (END)
################################################################################


################################################################################
# FILE 19/42: tests/test8.py (START)
################################################################################

from world.buildings.miner import Miner
import random
from world import ROWS
import time

def test8() -> None:
    miners = []
    rows = ROWS()
    for i in range(60):
        x = random.randint(a=1000, b=999000)
        y = random.randint(a=1000, b=999000)
        z = random.randint(a=1000, b=60000)
        miner = Miner(rows=rows, pos=(x, y, z), size=(5, 5, 900), seconds=1, floor=True)

        miners.append(miner)
    print(f"Created {len(miners)} miners.")

    duration = 1200  # seconds
    print(f"Simulating {duration} seconds of mining...")
    t0 = time.time()
    for frame in range(duration * 60):
        for miner in miners:
            miner: Miner = miner
            miner.update(frame=frame)
        if (frame + 1) % 60 == 0:
            print(f"  Simulated {(frame + 1) // 60} seconds...")
    t1 = time.time()
    dt = t1 - t0
    remaining = duration - dt
    print(f"Simulated {duration} seconds in {dt:.2f} seconds. Remaining time: {remaining:.2f} seconds.")

    print(rows)

################################################################################
# FILE 19/42: tests/test8.py (END)
################################################################################


################################################################################
# FILE 20/42: tests/test9.py (START)
################################################################################






def test9() -> None:
    pass

################################################################################
# FILE 20/42: tests/test9.py (END)
################################################################################


################################################################################
# FILE 21/42: tests/tests.py (START)
################################################################################

from utils import *
from world import *
from bundle import *
from tests import *



def tests(tests:list=None) -> None:
    if tests is None:
        tests = [test1, test2, test3, test4, test5, test6]

    
    with Bundle():
        try:
            for i, test in enumerate(tests):
                
                print(f"\n=== RUNNING TEST {i+1}/{len(tests)}: {test.__name__} ===")
                timer.lap()
                test()
                print(f"=== TEST {i+1}/{len(tests)}: {test.__name__} PASSED in {timer.lap():.3f} seconds ===\n")

        except Exception:
            traceback.print_exc()
        finally:
            pass

################################################################################
# FILE 21/42: tests/tests.py (END)
################################################################################


################################################################################
# FILE 22/42: TODO.md (START)
################################################################################




# ! ROWS
# TODO:

# ! UTILS
# TODO: 

# ! BUNDLE
# TODO: 

################################################################################
# FILE 22/42: TODO.md (END)
################################################################################


################################################################################
# FILE 23/42: utils/__init__.py (START)
################################################################################

from .request import Request

from .includes import *
from .includes import __all__ as inc

__all__ = [
    "Request",
]

__all__.extend(inc)

################################################################################
# FILE 23/42: utils/__init__.py (END)
################################################################################


################################################################################
# FILE 24/42: utils/bvh.py (START)
################################################################################

# utils/bvh.py
from __future__ import annotations
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from world.rows import ROWS

from world.row import ROW
from utils.types import POS, Row


class BVH:
    __slots__ = (
        "rows",
        "root",
        "x0","y0","z0","x1","y1","z1",
        "left","right","parent",
        "lmid","lrid",
        "lidx"
    )

    def __init__(self, rows: "ROWS" = None) -> None:
        self.rows = rows
        self.root = -1

        self.x0 = []
        self.y0 = []
        self.z0 = []
        self.x1 = []
        self.y1 = []
        self.z1 = []

        self.left = []
        self.right = []
        self.parent = []

        self.lmid = []
        self.lrid = []

        self.lidx: dict[tuple[int,int],int] = {}

    # ============================================================
    # node helpers
    # ============================================================

    def newnode(
        self,
        x0:int,y0:int,z0:int,
        x1:int,y1:int,z1:int,
        lmid:int=-1,lrid:int=-1,
        left:int=-1,right:int=-1,parent:int=-1
    )->int:
        idx = len(self.x0)

        self.x0.append(x0)
        self.y0.append(y0)
        self.z0.append(z0)
        self.x1.append(x1)
        self.y1.append(y1)
        self.z1.append(z1)

        self.left.append(left)
        self.right.append(right)
        self.parent.append(parent)

        self.lmid.append(lmid)
        self.lrid.append(lrid)

        return idx

    def expand(self, a:int, b:int)->None:
        self.x0[a] = min(self.x0[a], self.x0[b])
        self.y0[a] = min(self.y0[a], self.y0[b])
        self.z0[a] = min(self.z0[a], self.z0[b])
        self.x1[a] = max(self.x1[a], self.x1[b])
        self.y1[a] = max(self.y1[a], self.y1[b])
        self.z1[a] = max(self.z1[a], self.z1[b])

    def area(self, n:int)->int:
        return (
            (self.x1[n]-self.x0[n]) *
            (self.y1[n]-self.y0[n]) *
            (self.z1[n]-self.z0[n])
        )

    def insert(self, row:Row=None)->None:
        mid,rid,row = int(row.mid),int(row.rid),row.row
        x0,y0,z0 = ROW.P0(row=row)
        x1,y1,z1 = ROW.P1(row=row)

        leaf = self.newnode(
            x0,y0,z0,x1,y1,z1,
            lmid=mid,lrid=rid
        )
        self.lidx[(mid,rid)] = leaf

        if self.root == -1:
            self.root = leaf
            return

        self.root = self.insertnode(self.root, leaf)

    def insertnode(self, root:int, leaf:int)->int:
        if self.lmid[root] != -1:
            parent = self.newnode(
                min(self.x0[root], self.x0[leaf]),
                min(self.y0[root], self.y0[leaf]),
                min(self.z0[root], self.z0[leaf]),
                max(self.x1[root], self.x1[leaf]),
                max(self.y1[root], self.y1[leaf]),
                max(self.z1[root], self.z1[leaf]),
                left=root,
                right=leaf
            )
            self.parent[root] = parent
            self.parent[leaf] = parent
            return parent

        l = self.left[root]
        r = self.right[root]

        cost_l = self.area(self.merge_cost(l, leaf))
        cost_r = self.area(self.merge_cost(r, leaf))

        if cost_l <= cost_r:
            self.left[root] = self.insertnode(l, leaf)
            self.parent[self.left[root]] = root
        else:
            self.right[root] = self.insertnode(r, leaf)
            self.parent[self.right[root]] = root

        self.expand(root, leaf)
        return root

    def merge_cost(self, a:int, b:int)->int:
        return self.newnode(
            min(self.x0[a], self.x0[b]),
            min(self.y0[a], self.y0[b]),
            min(self.z0[a], self.z0[b]),
            max(self.x1[a], self.x1[b]),
            max(self.y1[a], self.y1[b]),
            max(self.z1[a], self.z1[b])
        )

    def fixupwards(self, n:int)->None:
        while n != -1:
            l = self.left[n]
            r = self.right[n]
            self.x0[n] = min(self.x0[l], self.x0[r])
            self.y0[n] = min(self.y0[l], self.y0[r])
            self.z0[n] = min(self.z0[l], self.z0[r])
            self.x1[n] = max(self.x1[l], self.x1[r])
            self.y1[n] = max(self.y1[l], self.y1[r])
            self.z1[n] = max(self.z1[l], self.z1[r])
            n = self.parent[n]

    # ============================================================
    # removal
    # ============================================================

    def remove(self, row:Row=None)->None:
        mid,rid = int(row.mid),int(row.rid)
        node = self.lidx.pop((mid,rid),None)
        if node is None:
            return

        parent = self.parent[node]
        if parent == -1:
            self.root = -1
            return

        sibling = (
            self.right[parent]
            if self.left[parent] == node
            else self.left[parent]
        )
        grand = self.parent[parent]

        if grand == -1:
            self.root = sibling
            self.parent[sibling] = -1
        else:
            if self.left[grand] == parent:
                self.left[grand] = sibling
            else:
                self.right[grand] = sibling
            self.parent[sibling] = grand
            self.fixupwards(grand)

    def search(self, pos:POS)->Row:
        if self.root == -1:
            raise LookupError("BVH empty")

        x,y,z = pos
        stack = [self.root]

        while stack:
            n = stack.pop()
            if n == -1:
                continue

            if not (
                self.x0[n] <= x < self.x1[n] and
                self.y0[n] <= y < self.y1[n] and
                self.z0[n] <= z < self.z1[n]
            ):
                continue

            if self.lmid[n] != -1:
                mid = int(self.lmid[n])
                rid = int(self.lrid[n])
                row = self.rows.array[mid][rid]
                if ROW.CONTAINS(row=row,pos=pos):
                    return Row(mid=mid,rid=rid,row=row)
                continue

            stack.append(self.left[n])
            stack.append(self.right[n])

        raise LookupError("point not found")

################################################################################
# FILE 24/42: utils/bvh.py (END)
################################################################################


################################################################################
# FILE 25/42: utils/event.py (START)
################################################################################

from __future__ import annotations
from typing import Any, Callable
from dataclasses import dataclass, field
from .event import Event
from .schedule import Schedule



@dataclass(order=True)
class Event:
    due_ns: int
    seq: int
    callback: Callable[..., Any] = field(compare=False)
    args: tuple[Any, ...] = field(default_factory=tuple, compare=False)
    kwargs: dict[str, Any] = field(default_factory=dict, compare=False)
    cancelled: bool = field(default=False, compare=False)


class Handler:
    __slots__ = ("_scheduler", "_event")

    def __init__(self, scheduler: "Schedule", event: Event) -> None:
        self._scheduler = scheduler
        self._event = event

    def cancel(self) -> bool:
        return self._scheduler.cancel(self)


################################################################################
# FILE 25/42: utils/event.py (END)
################################################################################


################################################################################
# FILE 26/42: utils/includes.py (START)
################################################################################

from __future__ import annotations  # MUST BE FIRST

# EXCEPTION IMPORTS
from .timer import Timer, time      # NON SORTED -> HERE BECAUSE Timer IS USED IMMEDIATELY
timer = Timer()

# IMPORTS FROM STANDARD LIBRARY AND THIRD-PARTY LIBRARIES
from typing import TYPE_CHECKING, Any, Iterator, TypeVar, Generic, Union, Tuple, List, Dict, Callable, Optional
from pathlib import Path
from numpy.typing import NDArray
from PIL import Image, ImageDraw, ImageFont


# SIMPLE IMPORTS
import math
import numpy as np
import torch 
import heapq
import threading
import json
import time
import pathlib
import sys
import os
import random
import shutil
import datetime
import bisect
import pygame
import moderngl
import traceback
import stat


# my own modules (utils)
from .types import POS, SIZE


# Exports
__all__ = [
    "math",
    "time",
    "np",
    "NDArray",
    "torch",
    "TYPE_CHECKING",
    "annotations",
    "Any",
    "Iterator",
    "TypeVar",
    "Generic",
    "Union",
    "Tuple",
    "List",
    "Dict",
    "Callable",
    "Optional",
    "Image",
    "ImageDraw",
    "ImageFont",
    "Timer",
    "heapq",
    "threading",
    "json",
    "Path",
    "POS",
    "SIZE",
    "pathlib",
    "sys",
    "os",
    "random",
    "shutil",
    "datetime",
    "bisect",
    "pygame",
    "moderngl",
    "timer", # include the instance timer -> can be used as utils.timer
    "traceback",
    "stat",
]

# END OF FILE

################################################################################
# FILE 26/42: utils/includes.py (END)
################################################################################


################################################################################
# FILE 27/42: utils/mdx.py (START)
################################################################################

# utils/mdx.py
from __future__ import annotations
from typing import TYPE_CHECKING, DefaultDict, Dict, Optional, Set, Tuple
from collections import defaultdict
from dataclasses import dataclass

if TYPE_CHECKING:
    from world.rows import ROWS

from world.row import ROW
from utils.types import NDARR, Row

LOC = Tuple[int, int]  # (mid, rid)
FACE = Tuple[int, int, int, int, int, int]
BUCK = DefaultDict[FACE, Set[LOC]]  # face_key -> set of LOCs
FACES = Tuple[FACE, FACE]           # (pos_face, neg_face) for search order
BUCKS = Tuple[BUCK, BUCK]           # (neg_bucket, pos_bucket)


@dataclass(slots=True)
class Faces:
    x0: FACE
    x1: FACE
    y0: FACE
    y1: FACE
    z0: FACE
    z1: FACE

    def faces_for_axis(self, ax: int) -> FACES:
        if ax == 0:
            return (self.x1, self.x0)
        if ax == 1:
            return (self.y1, self.y0)
        if ax == 2:
            return (self.z1, self.z0)
        raise ValueError("axis must be 0,1,2")


class MDX:
    AX_X = 0
    AX_Y = 1
    AX_Z = 2
    ALLAXIS = (AX_X, AX_Y, AX_Z)

    def __init__(self, rows: "ROWS" = None) -> None:
        self.rows = rows
        self.init()

    def init(self) -> None:
        self.neg: Tuple[BUCK, BUCK, BUCK] = (defaultdict(set), defaultdict(set), defaultdict(set))
        self.pos: Tuple[BUCK, BUCK, BUCK] = (defaultdict(set), defaultdict(set), defaultdict(set))
        self._faces: Dict[LOC, Faces] = {}


    def _build_faces(self, mid: int, row: NDARR) -> Faces:
        x0, y0, z0 = ROW.P0(row=row)
        x1, y1, z1 = ROW.P1(row=row)

        fx0: FACE = (mid, y0, y1, z0, z1, x0)
        fx1: FACE = (mid, y0, y1, z0, z1, x1)

        fy0: FACE = (mid, x0, x1, z0, z1, y0)
        fy1: FACE = (mid, x0, x1, z0, z1, y1)

        fz0: FACE = (mid, x0, x1, y0, y1, z0)
        fz1: FACE = (mid, x0, x1, y0, y1, z1)

        return Faces(x0=fx0, x1=fx1, y0=fy0, y1=fy1, z0=fz0, z1=fz1)


    def insert(self, row: Row=None) -> None:
        mid, rid, row = int(row.mid), int(row.rid), row.row
        loc: LOC = (mid, rid)

        faces = self._build_faces(mid=mid, row=row)
        self._faces[loc] = faces

        self.neg[self.AX_X][faces.x0].add(loc)
        self.pos[self.AX_X][faces.x1].add(loc)
        self.neg[self.AX_Y][faces.y0].add(loc)
        self.pos[self.AX_Y][faces.y1].add(loc)
        self.neg[self.AX_Z][faces.z0].add(loc)
        self.pos[self.AX_Z][faces.z1].add(loc)


    def remove(self, row: Row=None) -> None:
        mid, rid = int(row.mid), int(row.rid)
        loc: LOC = (mid, rid)

        faces = self._faces.pop(loc, None)
        if faces is None:
            return

        self._discard(self.neg[self.AX_X], faces.x0, loc)
        self._discard(self.pos[self.AX_X], faces.x1, loc)

        self._discard(self.neg[self.AX_Y], faces.y0, loc)
        self._discard(self.pos[self.AX_Y], faces.y1, loc)

        self._discard(self.neg[self.AX_Z], faces.z0, loc)
        self._discard(self.pos[self.AX_Z], faces.z1, loc)

    @staticmethod
    def _discard(m: BUCK, key: FACE, loc: LOC) -> None:
        s = m.get(key)
        if not s:
            return
        s.discard(loc)
        if not s:
            del m[key]


    def search(self, r: Row, axis: int) -> Optional[Row]:
        """
        Find ONE merge-candidate neighbor (same material) touching on `axis`.

        Returns:
            Row(mid, rid, row_view) or None
        """
        if axis not in (0, 1, 2):
            raise ValueError("axis must be 0,1,2")

        mid, rid = int(r.mid), int(r.rid)
        loc: LOC = (mid, rid)

        faces = self._faces.get(loc)
        if faces is None:
            return None

        face_pos, face_neg = faces.faces_for_axis(axis)
        bucks: BUCKS = (self.neg[axis], self.pos[axis])

        # Try +face then -face (or whatever order faces_for_axis returns)
        for face_key, bucket in ((face_pos, bucks[0]), (face_neg, bucks[1])):
            candidates = bucket.get(face_key)
            if not candidates:
                continue

            # return the first other loc
            for (pmid, prid) in candidates:
                if (pmid, prid) != loc:
                    row = self.rows.array[int(pmid)][int(prid)]
                    return Row(mid=int(pmid), rid=int(prid), row=row)

        return None

################################################################################
# FILE 27/42: utils/mdx.py (END)
################################################################################


################################################################################
# FILE 28/42: utils/request.py (START)
################################################################################

import time
import urllib.request
import urllib.error
import json


class Request:
    def __init__(self, url: str = None, timeout: int = 600, retries: int = 3, data=None, method: str = None) -> None:
        self.timeout = timeout
        self.retries = retries
        self._retries = retries
        self.url = url
        self.data = data
        self.method = method

        self.init()

    def init(self) -> None:
        self.request = urllib.request.Request(url=self.url, data=self.data, method=self.method)

    def header(self, key: str = None, value: str = None) -> None:
        self.request.add_header(key, value)

    def open(self) -> dict:
        try:
            with urllib.request.urlopen(self.request, timeout=self.timeout) as response:
                raw = response.read().decode("utf-8", errors="replace")
                try:
                    return json.loads(raw) if raw else {}
                
                except json.JSONDecodeError as e:
                    raise RuntimeError(f"[ERROR] invalid JSON response for {self.url}\n{e!r}\n---\n{raw[:200]}") from e

        except urllib.error.HTTPError as e:
            raw = e.read().decode("utf-8", errors="replace")
            retryable = (e.code == 429) or (500 <= e.code <= 599)

            if retryable and self.retries > 0:
                self.retries -= 1
                time.sleep(0.5 * (2 ** (self._retries - self.retries)))
                return self.open()
            raise RuntimeError(f"[ERROR] {e.code} for {self.url}\n{raw}") from e

        except (urllib.error.URLError, TimeoutError, OSError) as e:
            if self.retries > 0:
                self.retries -= 1
                time.sleep(0.5 * (2 ** (self._retries - self.retries)))
                return self.open()
            raise RuntimeError(f"[ERROR] request failed for {self.url}\n{e!r}") from e
        
        except Exception as e:
            raise RuntimeError(f"[ERROR] unexpected error for {self.url}\n{e!r}") from e

################################################################################
# FILE 28/42: utils/request.py (END)
################################################################################


################################################################################
# FILE 29/42: utils/schedule.py (START)
################################################################################

import threading
from typing import Any, Callable, Optional
import heapq
from .timer import Timer, now
from .event import Event, Handler



class Schedule:
    def __init__(self) -> None:
        self._timer = Timer()

        self._lock = threading.Lock()
        self._cv = threading.Condition(self._lock)
        self._pq: list[Event] = []
        self._seq = 0

        self._worker: Optional[threading.Thread] = None
        self._stop = False
        self._running = False

        self.start()

    def start(self) -> None:
        with self._lock:
            if self._running:
                return
            self._stop = False
            self._worker = threading.Thread(target=self._run, name="SchedulerWorker", daemon=True)
            self._running = True
            self._worker.start()

    def stop(self) -> None:
        with self._lock:
            if not self._running:
                return
            self._stop = True
            self._cv.notify_all()

        if self._worker:
            self._worker.join(timeout=2.0)

        with self._lock:
            self._running = False
            self._worker = None

    def schedule(self, ns: int=None, fn: Callable[..., Any]=None, *args: Any, **kwargs: Any) -> Handler:
        with self._lock:
            self._seq += 1
            ev = Event(due_ns=ns, seq=self._seq, callback=fn, args=args, kwargs=kwargs)
            heapq.heappush(self._pq, ev)
            self._cv.notify_all()
            return Handler(self, ev)

    def new(self, seconds:float=None, fn:Callable[..., Any]=None, delay=False, *args: Any, **kwargs: Any) -> Handler:
        if delay==True:
            ns = now() + int(seconds * 1e9)
        if delay==False:
            ns = int(seconds * 1e9)
        return self.schedule(ns=ns, fn=fn, *args, **kwargs)
    

    def cancel(self, handle: Handler) -> bool:
        with self._lock:
            if handle._event.cancelled:
                return False
            handle._event.cancelled = True
            self._cv.notify_all()
            return True

    def _run(self) -> None:
        while True:
            with self._lock:
                # Wait until there is work or stop requested
                while not self._pq and not self._stop:
                    self._cv.wait()

                if self._stop:
                    return

                # Drop cancelled events at head
                while self._pq and self._pq[0].cancelled:
                    heapq.heappop(self._pq)

                if not self._pq:
                    continue

                ev = self._pq[0]
                due = ev.due_ns

            # 2) Wait until deadline (no lock held)
            self._timer.waitns(due)

            # 3) Pop-and-execute if still valid
            with self._lock:
                if self._stop:
                    return

                if not self._pq:
                    continue
                if self._pq[0] is not ev:
                    continue

                heapq.heappop(self._pq)
                if ev.cancelled:
                    continue

            try:
                ev.callback(*ev.args, **ev.kwargs)
            except Exception as e:
                # Keep scheduler alive; replace with logging if desired
                print(f"[Schedule] callback error: {e!r}")






















# ============================================================
# Example usage
# ============================================================

if __name__ == "__main__":
    import time

    sched = Schedule()
    def hello(who:str=None, n:int=1) -> None:
        print(f"{time.perf_counter():.3f} hello {who} x{n}")
    def test(who:str=None,  n:int=1) -> None:
        print(who, n*n)

    h1 = sched.new(seconds=0.050, fn=test, who="A", n=2, delay=True)
    h2 = sched.new(seconds=0.120, fn=hello, who="B", n=3, delay=True)
    h3 = sched.new(seconds=0.080, fn=test, who="C", n=1, delay=True)
    h2.cancel()
    futuretime = time.perf_counter() + 0.100
    h4 = sched.new(seconds=futuretime, fn=hello, who="D", n=4, delay=False)
    h5 = sched.new(seconds=futuretime, fn=test, who="E", n=5, delay=False)
    h6 = sched.new(seconds=futuretime, fn=hello, who="F", n=6, delay=False)


    time.sleep(0.2)
    sched.stop()

################################################################################
# FILE 29/42: utils/schedule.py (END)
################################################################################


################################################################################
# FILE 30/42: utils/timer.py (START)
################################################################################

from __future__ import annotations
import time



class Timer:
    def __init__(self) -> None:
        self.coarse_ns = 2_000_000
        self.spin_ns = 1_000_000

        self.start()

    def nowns(self) -> int:  # can be used as Timer().nowns()
        return time.perf_counter_ns()
    
    @staticmethod   # can be used as Timer.now()
    def now() -> float:
        return time.perf_counter_ns()

    def start(self) -> int:
        self.started = self.nowns()
        self.t0 = self.started
        self.delta = []
        self.times = []
        return self.t0
    
    def lap(self) -> int:
        t1 = self.nowns()
        t0 = self.t0
        self.t0 = t1
        dt = round((t1 - t0) / 1e9, 6) # seconds
        self.delta.append(dt)
        self.times.append(t1)
        return dt       # time since last lap in seconds
    
    def stop(self) -> int:
        self.lap()
        first = self.started
        last = self.times[-1]
        t = round((last - first) / 1e9, 6) # seconds with 6 decimal places (microseconds) 
        return t        # total since started
    
    def print(self, msg:str=None) -> None:
        self.lap()
        txt = f"lap {len(self.delta)}: {self.delta[-1]} seconds"
        if msg is not None:
            txt = f"{msg}: {txt}"
        print(txt)

    def waitns(self, deadline_ns: int) -> None:
        coarse_ns = self.coarse_ns
        spin_ns = self.spin_ns

        while True:
            n = self.nowns()
            remaining = deadline_ns - n
            if remaining <= 0:
                return

            # FAR: sleep until within coarse_ns
            if remaining > coarse_ns:
                time.sleep((remaining - coarse_ns) / 1e9)
                continue

            # NEAR: yield until within spin_ns
            if remaining > spin_ns:
                time.sleep(0)
                continue

            # FINAL: busy-spin
            while self.nowns() < deadline_ns:
                pass
            return

    def wait(self, seconds: float) -> None:
        if seconds <= 0:
            return
        self.waitns(self.nowns() + int(seconds * 1e9))

    def reset(self) -> int:
        t = self.stop()
        self.start()
        return t  # total since started before reset


now = Timer.now # now: now() returns the current time in nanoseconds

################################################################################
# FILE 30/42: utils/timer.py (END)
################################################################################


################################################################################
# FILE 31/42: utils/types.py (START)
################################################################################

from typing import TypeAlias
from numpy.typing import NDArray
import numpy as np

POS: TypeAlias = tuple[int, int, int]
SIZE: TypeAlias = tuple[int, int, int]
NDARR = NDArray[np.uint64]
REQS = tuple[NDARR, dict[int, int]]

from dataclasses import dataclass
@dataclass(slots=True)
class Row:
    mid: int
    rid: int
    row: NDARR

__all__ = [
    "POS",
    "SIZE",
    "NDARR",
    "REQS",
    "Row",
]

################################################################################
# FILE 31/42: utils/types.py (END)
################################################################################


################################################################################
# FILE 32/42: world/__init__.py (START)
################################################################################


from .buildings import *
from .buildings import __all__ as allbuildings

from .resources import *
from .resources import __all__ as allresources

from .rows import ROWS
from .row import ROW
from .materials import MATERIALS, Materials, Material

__all__ = [
    "MATERIALS",
    "Materials",
    "Material",
    "ROW",
    "ROWS",
] 

__all__.extend(allbuildings)
__all__.extend(allresources)

################################################################################
# FILE 32/42: world/__init__.py (END)
################################################################################


################################################################################
# FILE 33/42: world/buildings/__init__.py (START)
################################################################################


from .miner import Miner
from .factory import Factory
from .warehouse import Warehouse



__all__ = [
    "Miner",    
    "Factory",
    "Warehouse",
]

################################################################################
# FILE 33/42: world/buildings/__init__.py (END)
################################################################################


################################################################################
# FILE 34/42: world/buildings/factory.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from world.rows import ROWS



from .warehouse import Warehouse
from utils.types import POS



class Recipe:
    def __init__(self, ins:dict[str,int]=None, outs:dict[str,int]=None, ticks:int=0) -> None:
        self.ins:dict[str,int] = ins if ins is not None else {}
        self.outs:dict[str,int] = outs if outs is not None else {}

        self.ticks:int = ticks

        self.init()

    def init(self) -> None:
        self.tick = 0

    def ready(self) -> Recipe|None:
        self.tick += 1
        if self.tick >= self.ticks:
            self.tick = 0
            return self
        return None    



class Factory:    
    def __init__(self, rows:ROWS=None, pos:POS=None, recipe:Recipe=None, warehouse:Warehouse=None) -> None:
        self.rows:ROWS      = rows
        self.pos:POS        = pos 
        self.recipe:Recipe  = recipe
        self.warehouse:Warehouse = warehouse

    def update(self) -> None:
        if self.canproduce():
            self.produce(self.recipe)

    def canproduce(self) -> bool:
        canproduce = False
        if self.recipe.ready():
            if self.enoughmats():
                canproduce = True
        return canproduce
    
    def enoughmats(self, mat:str=None, amount:int=None) -> bool:
        enough: bool = True
        for mat, amount in self.recipe.ins.items():
            if self.warehouse.rows.materials.get(mat, 0) < amount:
                enough = False
                break
        return enough
              
            

################################################################################
# FILE 34/42: world/buildings/factory.py (END)
################################################################################


################################################################################
# FILE 35/42: world/buildings/miner.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from world.rows import ROWS


from utils.types import POS, SIZE









class Miner:
    id = 0
    def __init__(self, rows:ROWS=None, pos:POS=None, size:SIZE=None, seconds:int=1, floor:bool=True) -> None:
        self.rows:ROWS      = rows
        self.pos:POS        = pos
        self.size:SIZE      = size
        self.seconds:int    = seconds
        self.floor:bool     = floor
        print(f"Creating Miner id={Miner.id} at pos={self.pos} size={self.size} seconds={self.seconds} floor={self.floor}")

        self.init()

    def init(self) -> None:
        self.id:int         = self.getid()
        self.nframes:int    = self.seconds * 60 if not self.floor else self.seconds * 60 * (self.size[0] * self.size[1])
        self.frame:int      = self.getframe()

        self.minepos0:POS    = self.pos
        self.minepos1:POS    = (self.pos[0]+self.size[0]-1, self.pos[1]+self.size[1]-1, self.pos[2]+self.size[2]-1)
        self.minepos:POS     = self.minepos0

    def getid(self) -> int:
        id: int = Miner.id
        Miner.id += 1
        return id
    
    def getframe(self) -> int:
        frame:int = self.id % self.nframes
        return frame
    
    def getnext(self) -> tuple[POS, POS]:
        x0, y0, z0 = self.minepos0
        x1, y1, z1 = self.minepos1
        x, y, z = self.minepos

        pos:POS = (x, y, z) # will be returned to be mined
        if self.floor==False:
            x += 1
            if x > x1: 
                x, y = x0, y + 1
                if y > y1: 
                    y, z = y0, z + 1
                    if z > z1: 
                        z = z0

            self.minepos = (x, y, z)    # update to next position
            pos1 = (pos[0] + 1, pos[1] + 1, pos[2] + 1)
            return pos, pos1
        else:
            boxpos0:POS = (x0, y0, z)
            boxpos1:POS = (x1, y1, z + 1)

            z += 1
            if z > z1:
                z = z0

            self.minepos = (x, y, z)    # update to next position
            return (boxpos0, boxpos1)
    
    def update(self, frame:int) -> None:
        self.mine(frame=frame)
    
    def mine(self, frame:int=None) -> None:
        if frame is None:
            raise ValueError("frame must be specified")
        if frame % self.nframes == self.frame:  # every nframes frames
            pos0, pos1 = self.getnext()
            self.rows.split(pos=pos0, pos1=pos1, mat="AIR")
        else:
            pass

    

################################################################################
# FILE 35/42: world/buildings/miner.py (END)
################################################################################


################################################################################
# FILE 36/42: world/buildings/warehouse.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING, TypeAlias

if TYPE_CHECKING:
    from world.rows import ROWS
    from utils.types import SIZE, POS



from world.resources import Resource, Resources


class Warehouse:
    def __init__(self, rows:ROWS=None, pos:POS=None, size:SIZE=None) -> None:
        self.rows:ROWS = rows
        self.pos:POS = pos
        self.size:SIZE = size
        self.init()

    def init(self) -> None:
        self.cap:int = self.size[0] * self.size[1] * self.size[2] * 64
        self.rez: Resources = Resources()

    def total(self) -> int:
        return self.rez.total()

    def free(self) -> int:
        return self.cap - self.total()

    def fits(self, res:Resource=None) -> bool:
        if res is None:
            raise ValueError("[VALUE ERROR] Warehouse.fits(): res is None")
        res.validate()
        return self.free() >= res.amount
    
    def get(self, mat:str=None) -> Resource:
        if mat is None:
            raise ValueError("[VALUE ERROR] Warehouse.get(): mat is None")
        return self.rez.get(mat=mat)

    def has(self, res:Resource=None) -> tuple[Resource, Resource]:
        if res is None:
            raise ValueError("[VALUE ERROR] Warehouse.has(): res is None")
        res.validate()
        available = self.rez.rez.get(res.mat, Resource(mat=res.mat, amount=0)).copy()
        want = res.copy()
        return available, want
    
    def split(self, request:Resource=None) -> tuple[Resource, Resource]:
        if request is None:
            raise ValueError("[VALUE ERROR] Warehouse.split(): request is None")
        request.validate()
        requested, stock = self.get(mat=request.mat).split(value=request.amount) # part1 is what we give, part2 is what remains
        return requested, stock

    def give(self, incoming:Resource=None) -> Resource:
        if incoming is None:
            raise ValueError("[VALUE ERROR] Warehouse.give(): incoming is None")
        incoming.validate()
        give, notgive = incoming.split(value=self.free() if self.free() > 0 else 0)  # <-- unpack order matters!
        self.rez += give   # transfer stored into warehouse (stored becomes 0)
        return notgive      # what could NOT be stored

    def take(self, requested:Resource=None) -> Resource:
        if requested is None:
            raise ValueError("[VALUE ERROR] Warehouse.take(): requested is None")
        requested.validate()
        return self.split(request=requested)[0] # what we can provide

################################################################################
# FILE 36/42: world/buildings/warehouse.py (END)
################################################################################


################################################################################
# FILE 37/42: world/materials.py (START)
################################################################################
















class MATERIALS:
    """
    PRIVATE:
    -> Use the Materials class for lookups.
    """
    TYPES = {
        "INVIS": 0,     # start at 16384                # invisible
        "TRANS": 1,     # start at 32768                # transparent
        "SOLID": 2,     # start at 65536                # solid
        "ROCKS": 3,     # start at 4294967296           # indestructible
    }

    DATA  = {
        "AIR":      (16384+0,     TYPES["INVIS"]),    

        "WATER":    (32768+0,     TYPES["TRANS"]), 
        "LAVA":     (32768+1,     TYPES["TRANS"]),
        "GLASS":    (32768+2,     TYPES["TRANS"]),

        "STONE":    (65536+0,     TYPES["SOLID"]),
        "OBSIDIAN": (65536+1,     TYPES["SOLID"]),

        "BEDROCK":  (4294967296+0,TYPES["ROCKS"]),
    }

    MID = {name: i for i, name in enumerate(DATA.keys())}
    NUM = len(DATA)

class Material:
    """
    PRIVATE:
    -> Use the Materials class for lookups.
    """
    def __init__(self, name:str=None) -> None:
        self.idx, self.type = MATERIALS.DATA.get(name, (None, None)) 
        self.mid = MATERIALS.MID.get(name, None) 
        if self.mid is None or self.type is None or self.idx is None:
            raise ValueError(f"Invalid material name: {name}")

    def isrocks(self) -> bool:
        return self.type == MATERIALS.TYPES["ROCKS"]

    def issolid(self) -> bool:
        return self.type == MATERIALS.TYPES["SOLID"]
    
    def istrans(self) -> bool:
        return self.type == MATERIALS.TYPES["TRANS"]
    
    def isinvisible(self) -> bool:
        return self.type == MATERIALS.TYPES["INVIS"]
    
    def isindestructible(self) -> bool:
        return self.type == MATERIALS.TYPES["ROCKS"]

class Materials:
    """
    PRIVATE:
    -> Various material lookup dictionaries for name, mid, and idx.
    """
    mid2name = {idx: name for name, idx in MATERIALS.MID.items()}
    name2mid = MATERIALS.MID
    name2idx  = {name: pair[0] for name, pair in MATERIALS.DATA.items()}
    idx2name  = {pair[0]: name for name, pair in MATERIALS.DATA.items()}
    idx2mid   = {pair[0]: MATERIALS.MID[name] for name, pair in MATERIALS.DATA.items()}
    mid2idx   = {MATERIALS.MID[name]: pair[0] for name, pair in MATERIALS.DATA.items()}
    """
    PRIVATE END
    """

    def __init__(self) -> None:
        for name in MATERIALS.DATA.keys():
            setattr(self, name.lower(), Material(name=name))

    def idx(self, name:str=None, mid:int=None) -> int:
        """
        PUBLIC:
        -> Get the material index (idx) given either the material name or mid.
        -> Provide exactly one of name or mid.
        """
        if (name is None) == (mid is None):
            raise ValueError("Provide exactly one of name or mid")
        return self.name2idx[name] if name is not None else self.mid2idx[mid]

    def mid(self, name:str=None, idx:int=None) -> int:
        """
        PUBLIC:
        -> Get the material ID (mid) given either the material name or idx.
        -> Provide exactly one of name or idx.
        """
        if (name is None) == (idx is None):
            raise ValueError("Provide exactly one of name or idx")
        return self.name2mid[name] if name is not None else self.idx2mid[idx]

    def name(self, mid:int=None, idx:int=None) -> str:
        """
        PUBLIC:
        -> Get the material name given either the material ID (mid) or idx.
        -> Provide exactly one of mid or idx.
        """
        if (mid is None) == (idx is None):
            raise ValueError("Provide exactly one of mid or idx")
        return self.mid2name[mid] if mid is not None else self.idx2name[idx]
    
    def mat(self, mat:str=None, mid:int=None, idx:int=None) -> Material:
        """
        PUBLIC:
        -> Get the Material object given either the material name, mid, or idx.
        -> Provide exactly one of mat, mid, or idx.
        """
        if mid is not None:
            mat: str = self.mid2name.get(mid)
        if idx is not None:
            mat: str = self.idx2name.get(idx)
        return getattr(self, mat.lower())
        
        if name is not None:
            return Material(name=name)
        elif mid is not None:
            name = self.mid2name.get(mid, None)
            if name is None:
                raise ValueError(f"Invalid material mid: {mid}")
            return Material(name=name)
        else:  # idx is not None
            name = self.idx2name.get(idx, None)
            if name is None:
                raise ValueError(f"Invalid material idx: {idx}")
            return Material(name=name)
    
    def names(self) -> list[str]:
        """
        PUBLIC:
        -> Get a list of all material names.
        """
        return list(MATERIALS.DATA.keys())
    
    def idxs(self) -> list[int]:
        """
        PUBLIC:
        -> Get a list of all material indices (idx).
        """
        return [pair[0] for pair in MATERIALS.DATA.values()]
    
    def mids(self) -> list[int]:
        """
        PUBLIC:
        -> Get a list of all material IDs (mid).
        """
        return list(MATERIALS.MID.values())

################################################################################
# FILE 37/42: world/materials.py (END)
################################################################################


################################################################################
# FILE 38/42: world/resources/__init__.py (START)
################################################################################

from .resource import Resource, RESOURCELIKE
from .resources import Resources

__all__ = [
    "Resource",
    "Resources",
    "RESOURCELIKE",
]

################################################################################
# FILE 38/42: world/resources/__init__.py (END)
################################################################################


################################################################################
# FILE 39/42: world/resources/resource.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING, TypeAlias
if TYPE_CHECKING:
    from.resources import Resources





RESOURCELIKE: TypeAlias = "Resource | Resources | list[Resource] | tuple[Resource, ...] | set[Resource] | dict[str, Resource] | None"


class Resource:
    def __init__(self, mat:str=None, amount:int=0) -> None:
        self.mat:str = mat
        self.amount:int = amount
        self.validate()

    def validate(self) -> Resource:
        if self.mat is None:
            raise ValueError("[VALUE ERROR] Resource.validate(): mat is None")
        if self.amount < 0:
            raise ValueError(f"[VALUE ERROR] Resource.validate(): amount out of bounds: {self.amount}")
        return self

    def compatible(self, other:Resource=None) -> bool:
        if isinstance(other, Resource):
            self.validate()
            other.validate()
            if self.mat == other.mat:
                return True
        raise ValueError(f"[VALUE ERROR] Resource.compatible(): incompatible resources: {self} vs {other}")

    def copy(self) -> Resource:
        return Resource(mat=self.mat, amount=self.amount)

    def __copy__(self) -> Resource:
        return self.copy()

    def __deepcopy__(self, memo) -> Resource:
        return self.copy()

    # ------------------------------------------------------------
    # Semantics requested:
    #
    # a + b  : b does NOT mutate, a DOES mutate (adds b.amount)
    # a += b : transfer; a increases, b becomes 0
    #
    # a - b  : b does NOT mutate, a DOES mutate (subtract up to b.amount)
    # a -= b : transfer-like; a decreases, b becomes "remaining" demand
    #          (b ends up 0 if a had enough, else b keeps leftover)
    # ------------------------------------------------------------

    def __add__(self, other:Resource=None) -> Resource:
        if self.compatible(other=other):
            self.amount += other.amount
        return self.validate()

    def __iadd__(self, other:Resource=None) -> Resource:
        if self.compatible(other=other):
            self.amount += other.amount
            other.amount = 0
            other.validate()
        return self.validate()

    def __sub__(self, other:Resource=None) -> Resource:
        if self.compatible(other=other):
            take = other.amount
            if self.amount < take:
                take = self.amount
            self.amount -= take
        return self.validate()

    def __isub__(self, other:Resource=None) -> Resource:
        if self.compatible(other=other):
            take = other.amount
            if self.amount < take:
                take = self.amount
            self.amount -= take
            other.amount -= take
            other.validate()
        return self.validate()

    # ---------------- comparisons (same-material only) ----------------

    def __lt__(self, other:Resource=None) -> bool:
        if self.compatible(other=other):
            return self.amount < other.amount
        return False

    def __le__(self, other:Resource=None) -> bool:
        if self.compatible(other=other):
            return self.amount <= other.amount
        return False

    def __gt__(self, other:Resource=None) -> bool:
        if self.compatible(other=other):
            return self.amount > other.amount
        return False

    def __ge__(self, other:Resource=None) -> bool:
        if self.compatible(other=other):
            return self.amount >= other.amount
        return False

    def __eq__(self, other:object=None) -> bool:
        if not isinstance(other, Resource):
            return False
        if self.mat != other.mat:
            return False
        return self.amount == other.amount

    def __ne__(self, other:object=None) -> bool:
        return not self.__eq__(other)

    # ---------------- misc ----------------

    def __int__(self) -> int:
        return self.amount

    def __bool__(self) -> bool:
        self.validate()
        return True

    def __repr__(self) -> str:
        return f"Resource(mat={self.mat}, amount={self.amount})"

    def __str__(self) -> str:
        return self.__repr__()

    def sort(self, others:list[Resource]=None, reverse:bool=False) -> list[Resource]:
        if others is None:
            others = []
        for o in others:
            self.compatible(other=o)
        return sorted([self] + others, reverse=reverse)

    def split(self, value:int=None) -> list[Resource]:
        self.validate()
        if value is None or value < 0:
            raise ValueError(f"[VALUE ERROR] Resource.split(): invalid split value: {value}")

        take = min(value, self.amount)
        part1 = Resource(mat=self.mat, amount=take)
        self = self - part1
        return [part1, self]   # [before split, after split]
    

################################################################################
# FILE 39/42: world/resources/resource.py (END)
################################################################################


################################################################################
# FILE 40/42: world/resources/resources.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING, TypeAlias
if TYPE_CHECKING:
    pass

from .resource import Resource, RESOURCELIKE    


class Resources:
    def __init__(self, rez:RESOURCELIKE=None) -> None:
        self.rez: dict[str, Resource] = {}
        self.ingest(rez=rez)

    def tolist(self, rez:RESOURCELIKE=None) -> list[Resource]:
        if rez is None:
            return self.list()

        if isinstance(rez, Resource):
            return [rez]

        if isinstance(rez, Resources):
            return rez.list()

        if isinstance(rez, list):
            return rez

        if isinstance(rez, tuple):
            return list(rez)

        if isinstance(rez, set):
            return list(rez)

        if isinstance(rez, dict):
            # copy values into new Resources (do NOT mutate originals)
            return [Resource(mat=r.mat, amount=r.amount) for r in rez.values()]

        raise ValueError(f"[VALUE ERROR] Resources.tolist(): invalid type: {type(rez)}")

    def get(self, mat:str=None) -> Resource:
        if mat is None:
            raise ValueError("[VALUE ERROR] Resources.get(): mat is None")
        if mat not in self.rez:
            self.rez[mat] = Resource(mat=mat, amount=0)
        return self.rez[mat]

    def ingest(self, rez:RESOURCELIKE=None) -> None:
        for r in self.tolist(rez=rez):
            r.validate()
            cur = self.get(mat=r.mat)
            cur + r  # mutates cur only; r unchanged

    def transfer(self, rez:RESOURCELIKE=None) -> None:
        for r in self.tolist(rez=rez):
            r.validate()
            cur = self.get(mat=r.mat)
            cur += r  # transfer; r becomes 0

    def total(self) -> int:
        total = 0
        for r in self.tolist():
            total += r.amount
        return total

    def list(self) -> list[Resource]:
        return list(self.rez.values())

    def copy(self) -> Resources:
        return Resources(rez=[r.copy() for r in self.tolist()])

    def __copy__(self) -> Resources:
        return self.copy()

    def __deepcopy__(self, memo) -> Resources:
        return self.copy()

    # ------------------------------------------------------------
    # Semantics requested (for containers):
    #
    # a + b  : b does NOT mutate, a DOES mutate (adds)
    # a += b : transfer; a increases, b becomes 0 (per material)
    #
    # a - b  : b does NOT mutate, a DOES mutate (subtract up to b.amount)
    # a -= b : transfer-like; a decreases, b becomes remaining demand
    # ------------------------------------------------------------

    def __add__(self, other:RESOURCELIKE=None) -> Resources:
        self.ingest(rez=other)
        return self

    def __iadd__(self, other:RESOURCELIKE=None) -> Resources:
        self.transfer(rez=other)
        return self

    def __sub__(self, other:RESOURCELIKE=None) -> Resources:
        for r in self.tolist(rez=other):
            r.validate()
            cur = self.get(mat=r.mat)
            cur - r  # mutates cur only; r unchanged
        return self

    def __isub__(self, other:RESOURCELIKE=None) -> Resources:
        for r in self.tolist(rez=other):
            r.validate()
            cur = self.get(mat=r.mat)
            cur -= r  # mutates both: cur decreases, r becomes remaining demand
        return self

    def __bool__(self) -> bool:
        for r in self.list():
            bool(r)
        return True

    def __repr__(self) -> str:
        return f"Resources({self.list()})"

    def __str__(self) -> str:
        return self.__repr__()

################################################################################
# FILE 40/42: world/resources/resources.py (END)
################################################################################


################################################################################
# FILE 41/42: world/row.py (START)
################################################################################

from __future__ import annotations
import stat
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    pass

from utils.types import NDARR

import numpy as np


from utils.types import SIZE, POS
from world.materials import Material, Materials



mats = Materials()

class ROW:
    """
    PRIVATE VARIABLES!
    NOTES:
        - use the static methods to get stuff done!
        - do not acces these variables directly!
    PURPOSE:
        - defines the keys and structure of a ROW in the world ROWS array
    STRUCTURE:
        - each ROW is a 4x4 numpy uint64 array
        - row 0: min positions (x0, y0, z0)
        - row 1: max positions (x1, y1, z1)
        - row 2: dimensions (dx, dy, dz)
        - row 3: metadata (id, mid, flags)
    USAGE:
        - use the static methods to create, read, and manipulate ROWs
    """
    DTYPE = np.uint64
    SHAPE = (4, 4)
    NBITS = DTYPE(0).nbytes * 8                      # -> 64 bits

    XBITS = 20
    YBITS = 20
    ZBITS = 16
    if XBITS + YBITS + ZBITS + 1 > NBITS:
        raise ValueError("bit allocation error")

    XMIN = 0
    YMIN = 0
    ZMIN = 0
    XMAX = 2**XBITS
    YMAX = 2**YBITS
    ZMAX = 2**ZBITS
    NMAX = XMAX * YMAX * ZMAX


    # POSITIONS (MIN) â€” stored in row 0 (NOT FOR DIRECT USE)
    IDS_X0 = (0, 0)
    IDS_Y0 = (0, 1)
    IDS_Z0 = (0, 2)

    # POSITIONS (MAX) â€” stored in row 1 (NOT FOR DIRECT USE)
    IDS_X1 = (1, 0)
    IDS_Y1 = (1, 1)
    IDS_Z1 = (1, 2)

    # DIMENSIONS â€” stored in row 2 (NOT FOR DIRECT USE)
    IDS_DX = (2, 0)
    IDS_DY = (2, 1)
    IDS_DZ = (2, 2)

    # METADATA â€” stored in row 3 (NOT FOR DIRECT USE)
    IDS_RID    = (3, 0)
    IDS_MID   = (3, 1)
    IDS_FLAGS = (3, 2)

    # ENCODED FLAGS (NOT FOR DIRECT USE)
    ENCODE_DIRTY        = DTYPE(1 << 0)
    ENCODE_ALIVE        = DTYPE(1 << 1)
    ENCODE_SOLID        = DTYPE(1 << 2)
    ENCODE_DESTRUCTABLE = DTYPE(1 << 3)
    ENCODE_VISIBLE      = DTYPE(1 << 4)

    SENTINEL = np.iinfo(DTYPE).max
    ARRAY: NDARR = np.zeros(SHAPE, dtype=DTYPE)
    for i in range(4):
        for j in range(4):
            ARRAY[i, j] = SENTINEL  # initialize all to -1 -> invalid
    _ID = 0

    """
    PRIVATE VARIABLES END 
    """

    @staticmethod
    def X0(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: x0 position
        """
        return row[*ROW.IDS_X0]
    
    @staticmethod
    def Y0(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: y0 position
        """
        return row[*ROW.IDS_Y0]
    
    @staticmethod
    def Z0(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: z0 position
        """
        return row[*ROW.IDS_Z0]
    
    @staticmethod
    def X1(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: x1 position
        """
        return row[*ROW.IDS_X1]
    
    @staticmethod
    def Y1(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: y1 position
        """
        return row[*ROW.IDS_Y1]
    
    @staticmethod
    def Z1(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: z1 position
        """
        return row[*ROW.IDS_Z1]
    
    @staticmethod
    def DX(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: dx size
        """
        return row[*ROW.IDS_DX]
    
    @staticmethod
    def DY(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: dy size
        """
        return row[*ROW.IDS_DY]
    
    @staticmethod
    def DZ(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: dz size
        """
        return row[*ROW.IDS_DZ]
    
    @staticmethod # get min position (x0, y0, z0)  
    def P0(row:NDARR=None) -> POS:
        """
        PUBLIC!
        RETURN: (x0, y0, z0) == p0
        """
        return (ROW.X0(row=row), ROW.Y0(row=row), ROW.Z0(row=row))
    @staticmethod # get max position (x1, y1, z1)
    def P1(row:NDARR=None) -> POS:
        """
        PUBLIC!
        RETURN: (x1, y1, z1) == p1
        """
        return (ROW.X1(row=row), ROW.Y1(row=row), ROW.Z1(row=row))
    
    @staticmethod # get size (dx, dy, dz)
    def SIZE(row:NDARR=None) -> SIZE:
        """
        PUBLIC!
        RETURN: (dx, dy, dz) == size
        """
        return (ROW.DX(row=row), ROW.DY(row=row), ROW.DZ(row=row))
    
    @staticmethod # get material id
    def MID(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: material id integer (Material ID)
        """
        return row[*ROW.IDS_MID]
    
    @staticmethod # get material string name
    def MAT(row:NDARR=None) -> str:
        """
        PUBLIC!
        RETURN: material name string (Material Name)
        """
        return mats.name(mid=ROW.MID(row=row))
    
    @staticmethod # get row id
    def RID(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: row unique id integer (Row ID)
        """
        return row[*ROW.IDS_RID]
    
    @staticmethod # get flags
    def FLAGS(row:NDARR=None) -> tuple[bool, bool, bool, bool, bool]:
        """
        PUBLIC!
        RETURN: tuple of flags (dirty, alive, solid, destructable, visible)
        """
        flags: int = row[*ROW.IDS_FLAGS]
        dirty, alive, solid, destr, visib = ROW.DECODE(flags=flags)
        return (dirty, alive, solid, destr, visib)
    
    @staticmethod # get volume (dx * dy * dz)
    def VOLUME(row:NDARR=None) -> int:
        """
        PUBLIC!
        RETURN: volume (dx * dy * dz)
        """
        dx, dy, dz = ROW.SIZE(row=row)
        return dx * dy * dz

    @staticmethod
    def COPY() -> NDARR:
        """
        PUBLIC!
        RETURN: a copy of the ROW.ARRAY template
        USAGE: use this to create new rows
        """
        return np.copy(ROW.ARRAY)
    
    @staticmethod
    def CLIP(pos:POS=None) -> POS:
        """
        PUBLIC!
        RETURN: clipped position within world bounds
        USAGE: use this to ensure positions are within valid world limits
        """
        x, y, z = pos
        cx = min(max(x, ROW.XMIN), ROW.XMAX - 1)
        cy = min(max(y, ROW.YMIN), ROW.YMAX - 1)
        cz = min(max(z, ROW.ZMIN), ROW.ZMAX - 1)
        pos: POS = (cx, cy, cz)
        return pos
    
    @staticmethod
    def SORT(p0:POS=None, p1:POS=None) -> tuple[POS, POS]:
        """
        PUBLIC!
        RETURN: sorted positions (p0, p1) with p0 <= p1 for each coordinate
        """
        x0, y0, z0 = p0
        x1, y1, z1 = p1
        sx0, sx1 = (min(x0, x1), max(x0, x1))
        sy0, sy1 = (min(y0, y1), max(y0, y1))
        sz0, sz1 = (min(z0, z1), max(z0, z1))
        p0: POS = (sx0, sy0, sz0)
        p1: POS = (sx1, sy1, sz1)
        return (p0, p1)
    
    @staticmethod
    def CONTAINS(row: NDARR, pos: POS) -> bool:
        """
        PUBLIC!
        RETURN: whether the row contains the given position
        """
        x, y, z = pos
        x0, y0, z0 = ROW.P0(row=row)
        x1, y1, z1 = ROW.P1(row=row)
        return ((x0 <= x < x1) and (y0 <= y < y1) and (z0 <= z < z1))
    

    @staticmethod
    def MERGE(row0: NDARR=None, row1: NDARR=None) -> tuple[bool, bool, bool]:
        """
        PUBLIC!
        RETURN: tuple indicating if rows can be merged along each axis (x, y, z)
        """
        if row0[*ROW.IDS_MID] != row1[*ROW.IDS_MID]:
            return (False, False, False)

        x0a, y0a, z0a = ROW.P0(row=row0)
        x1a, y1a, z1a = ROW.P1(row=row0)
        x0b, y0b, z0b = ROW.P0(row=row1)
        x1b, y1b, z1b = ROW.P1(row=row1)
        p00 = (x0a, y0a, z0a)
        p01 = (x1a, y1a, z1a)
        p10 = (x0b, y0b, z0b)
        p11 = (x1b, y1b, z1b)

        def overlap(a0:int=None, a1:int=None, b0:int=None, b1:int=None) -> bool: return a0 < b1 and b0 < a1
        def touches(a0:int=None, a1:int=None, b0:int=None, b1:int=None) -> bool: return a1 == b0 or b1 == a0

        touching = [False, False, False]
        overlaps = [False, False, False]

        for i in range(3):
            if overlap(a0=p00[i], a1=p01[i], b0=p10[i], b1=p11[i]):
                overlaps[i] = True
            elif touches(a0=p00[i], a1=p01[i], b0=p10[i], b1=p11[i]):
                touching[i] = True
            else:
                return (False, False, False)  # separated on this axis
            
        if sum(touching) == 1 and sum(overlaps) == 2:
            return tuple(touching)  # (x_touch, y_touch, z_touch)

        return (False, False, False)
    

    @staticmethod
    def ENCODE(dirty:bool=None, alive:bool=None, solid:bool=None, destructable:bool=None, visible:bool=None) -> int:
        """
        PUBLIC!
        RETURN: encoded flags integer
        """
        f: int = 0
        if dirty:
            f |= int(ROW.ENCODE_DIRTY)
        if alive:
            f |= int(ROW.ENCODE_ALIVE)
        if solid:
            f |= int(ROW.ENCODE_SOLID)
        if destructable:
            f |= int(ROW.ENCODE_DESTRUCTABLE)
        if visible:
            f |= int(ROW.ENCODE_VISIBLE)
        return f
    

    @staticmethod
    def DECODE(flags) -> tuple[bool, bool, bool, bool, bool]:
        """
        PUBLIC!
        RETURN: tuple of flags (dirty, alive, solid, destructable, visible)
        """
        f: int = int(flags)

        dirty = (f & int(ROW.ENCODE_DIRTY)) != 0
        alive = (f & int(ROW.ENCODE_ALIVE)) != 0
        solid = (f & int(ROW.ENCODE_SOLID)) != 0
        destr = (f & int(ROW.ENCODE_DESTRUCTABLE)) != 0
        visib = (f & int(ROW.ENCODE_VISIBLE)) != 0
        return dirty, alive, solid, destr, visib


    @staticmethod
    def new(p0:POS=None, p1:POS=None, mat:str=None, rid:int=None, dirty:bool=True, alive:bool=True) -> NDARR:
        """
        PUBLIC!
        RETURN: a new ROW with given parameters
        """
        p0, p1 = ROW.SORT(p0=ROW.CLIP(pos=p0), p1=ROW.CLIP(pos=p1))
        
        mat: Material = mats.mat(mat=mat)
        flags: int = ROW.ENCODE(dirty=dirty, alive=alive, solid=mat.issolid(), destructable=not mat.isindestructible(), visible=not mat.isinvisible())
        copy: NDARR = ROW.COPY()

        # POS0
        copy[*ROW.IDS_X0]    = np.uint64(p0[0])
        copy[*ROW.IDS_Y0]    = np.uint64(p0[1])
        copy[*ROW.IDS_Z0]    = np.uint64(p0[2])
        # POS1
        copy[*ROW.IDS_X1]    = np.uint64(p1[0])
        copy[*ROW.IDS_Y1]    = np.uint64(p1[1])
        copy[*ROW.IDS_Z1]    = np.uint64(p1[2])
        # SIZE
        copy[*ROW.IDS_DX]    = np.uint64(p1[0] - p0[0])
        copy[*ROW.IDS_DY]    = np.uint64(p1[1] - p0[1])
        copy[*ROW.IDS_DZ]    = np.uint64(p1[2] - p0[2])
        # METADATA
        copy[*ROW.IDS_RID]    = np.uint64(rid)       # stores now the row index within material array instead of global unique id
        copy[*ROW.IDS_MID]   = np.uint64(mat.mid)  # material id
        copy[*ROW.IDS_FLAGS] = np.uint64(flags)

        if any(v < 0 for v in (copy[*ROW.IDS_DX], copy[*ROW.IDS_DY], copy[*ROW.IDS_DZ])):
            raise ValueError("p1 must be greater than or equal to p0 on all axes")
        if any(v < 0 for v in (copy[*ROW.IDS_X0], copy[*ROW.IDS_Y0], copy[*ROW.IDS_Z0])):
            raise ValueError("positions must be non-negative")
        return copy
    
    

################################################################################
# FILE 41/42: world/row.py (END)
################################################################################


################################################################################
# FILE 42/42: world/rows.py (START)
################################################################################

from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    pass

import numpy as np

from world.materials import Materials, MATERIALS
from world.row import ROW
from utils.bvh import BVH
from utils.mdx import MDX
from utils.types import POS, SIZE, NDARR, REQS, Row


class ROWS:
    """
    PUBLIC (human interface):
    - insert(p0:POS, p1:POS, mat:str, dirty:bool=True, alive:bool=True) -> Row
    - split(pos:POS, pos1:POS=None, mat:str=None) -> REQS
    - merge(rows:NDARR=None) -> REQS
    - volume(mat:str=None) -> int
    - get(mat:str, rid:int) -> Row
    - search(pos:POS) -> tuple[str,int,NDARR]   <-- matches tests

    INTERNAL:
    - remove(row:Row) -> None
    - merge2(row0:Row, row1:Row) -> REQS
    """

    SIZE = 65536

    def __init__(self)->None:
        self.mat = Materials()
        self.bvh = BVH(rows=self)
        self.mdx = MDX(rows=self)

        self.total = 0
        self.array, self.arids = self.reqs(n=ROWS.SIZE)

        self.shape = self.array.shape
        self.nbytes = self.array.nbytes
        self.gbytes = self.nbytes / (1024**3)

        self.p0 = (ROW.XMIN, ROW.YMIN, ROW.ZMIN)
        self.p1 = (ROW.XMAX, ROW.YMAX, ROW.ZMAX)

        # default world row
        self.insert(p0=self.p0, p1=self.p1, mat="STONE")

    # ============================================================
    # allocation / counters
    # ============================================================

    def reqs(self, n:int=None)->REQS:
        n = int(n) if n is not None else 0
        array = np.full(
            (MATERIALS.NUM, n, *ROW.SHAPE),
            fill_value=ROW.SENTINEL,
            dtype=ROW.DTYPE
        )
        arids:dict[int,int] = {mid: 0 for mid in range(MATERIALS.NUM)}
        return (array, arids)

    def newn(self, mat:str=None)->int:
        if mat is None:
            raise ValueError("newn requires mat")
        mid = int(self.mat.mid(name=mat))
        rid = int(self.arids[mid])
        self.arids[mid] += 1
        self.total += 1
        return rid

    def deln(self, mat:str=None)->int:
        if mat is None:
            raise ValueError("deln requires mat")
        mid = int(self.mat.mid(name=mat))
        if self.arids[mid] <= 0:
            raise ValueError("no rows to free")
        self.arids[mid] -= 1
        self.total -= 1
        return int(self.arids[mid])

    def nrows(self, mat:str=None, mid:int=None)->int:
        if mid is None:
            if mat is None:
                raise ValueError("nrows requires mat or mid")
            mid = int(self.mat.mid(name=mat))
        return int(self.arids[int(mid)])

    # ============================================================
    # Row helpers
    # ============================================================

    def get(self, mat:str=None, rid:int=None)->Row:
        if mat is None or rid is None:
            raise ValueError("get requires mat and rid")
        mid = int(self.mat.mid(name=mat))
        rid = int(rid)
        return Row(mid=mid, rid=rid, row=self.array[mid][rid])

    # ============================================================
    # core ops
    # ============================================================

    def insert(self, p0:POS=None, p1:POS=None, mat:str=None,
               dirty:bool=True, alive:bool=True)->Row:
        if mat is None:
            raise ValueError("insert requires mat")

        rid = self.newn(mat=mat)
        raw:NDARR = ROW.new(p0=p0, p1=p1, mat=mat, rid=rid, dirty=dirty, alive=alive)

        mid = int(ROW.MID(row=raw))
        rid = int(ROW.RID(row=raw))

        # IMPORTANT FIX: actually write RAW into the storage slot
        slot = self.array[mid][rid]
        slot[:] = raw

        stored = Row(mid=mid, rid=rid, row=slot)

        # index the stored row
        self.bvh.insert(row=stored)
        self.mdx.insert(row=stored)
        return stored

    def remove(self, row:Row=None)->None:
        if row is None:
            raise ValueError("remove requires row")

        mid = int(row.mid)
        rid = int(row.rid)
        mat_name = self.mat.name(mid=mid)

        n = self.nrows(mid=mid)
        last = n - 1

        # remove target from indices
        self.bvh.remove(row=row)
        self.mdx.remove(row=row)

        if rid != last:
            # remove moved's old identity from indices
            moved_old = Row(mid=mid, rid=last, row=self.array[mid][last])
            self.bvh.remove(row=moved_old)
            self.mdx.remove(row=moved_old)

            # move data
            moved_data = self.array[mid][last].copy()
            moved_data[*ROW.IDS_RID] = np.uint64(rid)   # fix payload rid
            self.array[mid][rid][:] = moved_data

            moved_new = Row(mid=mid, rid=rid, row=self.array[mid][rid])
            self.bvh.insert(row=moved_new)
            self.mdx.insert(row=moved_new)

        # invalidate last
        self.array[mid][last][:] = ROW.ARRAY
        self.deln(mat=mat_name)

    # ============================================================
    # queries
    # ============================================================

    def size(self)->SIZE:
        return (self.p1[0]-self.p0[0], self.p1[1]-self.p0[1], self.p1[2]-self.p0[2])

    def volume(self, mat:str=None)->int:
        if mat is None:
            total = 0
            for mid in range(MATERIALS.NUM):
                total += self.volume(mat=self.mat.name(mid=mid))
            return int(total)

        mid = int(self.mat.mid(name=mat))
        total = 0
        n = self.nrows(mid=mid)
        for rid in range(n):
            # cast to int so Python doesn't keep uint64 overflow semantics
            total += int(ROW.VOLUME(row=self.array[mid][rid]))
        return int(total)

    def search(self, pos:POS=None)->tuple[str,int,NDARR]:
        if pos is None:
            raise ValueError("search requires pos")
        hit:Row = self.bvh.search(pos=pos)               # BVH returns Row(mid,rid,row)
        mat = self.mat.name(mid=int(hit.mid))
        return (mat, int(hit.rid), hit.row)

    # ============================================================
    # split
    # ============================================================

    def splitrow(self, pos:POS=None, p2:POS=None, mat:str=None)->REQS:
        if pos is None or p2 is None or mat is None:
            raise ValueError("splitrow requires pos,p2,mat")

        mat0, _, hitrow = self.search(pos=pos)

        r0 = ROW.P0(row=hitrow)
        r1 = ROW.P1(row=hitrow)

        x0,y0,z0 = r0
        x3,y3,z3 = r1
        x1,y1,z1 = pos
        x2,y2,z2 = p2

        x1=max(x0,min(x1,x3)); x2=max(x0,min(x2,x3))
        y1=max(y0,min(y1,y3)); y2=max(y0,min(y2,y3))
        z1=max(z0,min(z1,z3)); z2=max(z0,min(z2,z3))

        xs=((x0,x1),(x1,x2),(x2,x3))
        ys=((y0,y1),(y1,y2),(y2,y3))
        zs=((z0,z1),(z1,z2),(z2,z3))

        array, arids = self.reqs(n=27)

        for i,(X0,X1) in enumerate(xs):
            for j,(Y0,Y1) in enumerate(ys):
                for k,(Z0,Z1) in enumerate(zs):
                    if (X1-X0)<=0 or (Y1-Y0)<=0 or (Z1-Z0)<=0:
                        continue

                    center = (i==1 and j==1 and k==1)
                    use_mat = mat if center else mat0

                    newrow = self.insert(p0=(X0,Y0,Z0), p1=(X1,Y1,Z1), mat=use_mat)
                    mid_new = int(newrow.mid)

                    array[mid_new][arids[mid_new]] = newrow.row
                    arids[mid_new] += 1

        # remove the hit row (need Row object for indices)
        hit_mid = int(ROW.MID(row=hitrow))
        hit_rid = int(ROW.RID(row=hitrow))
        self.remove(row=Row(mid=hit_mid, rid=hit_rid, row=hitrow))

        return (array, arids)

    def split1(self, pos:POS=None, mat:str=None)->REQS:
        if pos is None or mat is None:
            raise ValueError("split1 requires pos,mat")
        p2 = (pos[0]+1, pos[1]+1, pos[2]+1)
        batch, _ = self.splitrow(pos=pos, p2=p2, mat=mat)
        merged, marids = self.merge(rows=batch)
        return (merged, marids)

    def split2(self, p0:POS=None, p1:POS=None, mat:str=None)->REQS:
        def intersect(a0:POS=None,a1:POS=None,b0:POS=None,b1:POS=None)->tuple[POS,POS]|None:
            q0 = (max(a0[0],b0[0]), max(a0[1],b0[1]), max(a0[2],b0[2]))
            q1 = (min(a1[0],b1[0]), min(a1[1],b1[1]), min(a1[2],b1[2]))
            if q0[0]>=q1[0] or q0[1]>=q1[1] or q0[2]>=q1[2]:
                return None
            return (q0,q1)

        if p0 is None or p1 is None or mat is None:
            raise ValueError("split2 requires p0,p1,mat")

        p0,p1 = ROW.SORT(p0=p0, p1=p1)
        if p0[0]>=p1[0] or p0[1]>=p1[1] or p0[2]>=p1[2]:
            return self.reqs(n=0)

        acc:list[list[NDARR]] = [[] for _ in range(MATERIALS.NUM)]

        _, _, hitrow = self.search(pos=p0)
        r0 = ROW.P0(row=hitrow)
        r1 = ROW.P1(row=hitrow)

        hit = intersect(a0=p0, a1=p1, b0=r0, b1=r1)
        if hit is None:
            return self.reqs(n=0)

        q0,q1 = hit
        batch,_ = self.splitrow(pos=q0, p2=q1, mat=mat)
        merged,marids = self.merge(rows=batch)

        for mid in range(MATERIALS.NUM):
            for i in range(marids[mid]):
                acc[mid].append(merged[mid][i])

        if q1[0]<p1[0]:
            b,a = self.split2(p0=(q1[0],p0[1],p0[2]), p1=p1, mat=mat)
            for mid in range(MATERIALS.NUM):
                for i in range(a[mid]):
                    acc[mid].append(b[mid][i])

        if q1[1]<p1[1]:
            b,a = self.split2(p0=(p0[0],q1[1],p0[2]), p1=(q1[0],p1[1],p1[2]), mat=mat)
            for mid in range(MATERIALS.NUM):
                for i in range(a[mid]):
                    acc[mid].append(b[mid][i])

        if q1[2]<p1[2]:
            b,a = self.split2(p0=(p0[0],p0[1],q1[2]), p1=(q1[0],q1[1],p1[2]), mat=mat)
            for mid in range(MATERIALS.NUM):
                for i in range(a[mid]):
                    acc[mid].append(b[mid][i])

        out_arids = {mid: len(acc[mid]) for mid in range(MATERIALS.NUM)}
        n = max(out_arids.values()) if out_arids else 0
        array, arids = self.reqs(n=n)

        for mid in range(MATERIALS.NUM):
            arids[mid] = out_arids[mid]
            for i,r in enumerate(acc[mid]):
                array[mid][i] = r

        return (array, arids)

    def split(self, pos:POS=None, pos1:POS=None, mat:str=None)->REQS:
        if mat is None:
            raise ValueError("material must be specified")
        if pos is None and pos1 is None:
            raise ValueError("either pos or pos1 must be provided")

        if pos is not None and pos1 is not None:
            return self.split2(p0=pos, p1=pos1, mat=mat)
        if pos is not None:
            return self.split1(pos=pos, mat=mat)
        return self.split1(pos=pos1, mat=mat)

    # ============================================================
    # merge (FIXED to match MDX.search signature)
    # ============================================================

    def merge2(self, row0:Row=None, row1:Row=None)->REQS:
        if row0 is None or row1 is None:
            return self.reqs(n=0)

        if int(row0.mid) != int(row1.mid):
            return self.reqs(n=0)

        touch = ROW.MERGE(row0=row0.row, row1=row1.row)
        if touch == (False, False, False):
            return self.reqs(n=0)

        p0 = ROW.SORT(p0=ROW.P0(row=row0.row), p1=ROW.P0(row=row1.row))[0]
        p1 = ROW.SORT(p0=ROW.P1(row=row0.row), p1=ROW.P1(row=row1.row))[1]

        # remove bigger rid first
        if int(row0.rid) > int(row1.rid):
            hi, lo = row0, row1
        else:
            hi, lo = row1, row0

        self.remove(row=hi)
        self.remove(row=lo)

        mat_name = self.mat.name(mid=int(row0.mid))
        newrow = self.insert(p0=p0, p1=p1, mat=mat_name)

        array, arids = self.reqs(n=1)
        array[int(newrow.mid)][0] = newrow.row
        arids[int(newrow.mid)] = 1
        return (array, arids)

    def mergeax(self, mat:str=None, axis:int=None)->REQS:
        if mat is None:
            raise ValueError("mergeax requires mat")
        if axis is None:
            raise ValueError("mergeax requires axis")

        mid = int(self.mat.mid(name=mat))
        start_n = self.nrows(mid=mid)
        array, arids = self.reqs(n=start_n)

        extra = list(range(self.arids[mid]-1, -1, -1))
        seen:set[int] = set()

        while extra:
            rid = int(extra.pop())
            if rid < 0 or rid >= self.arids[mid]:
                continue
            if rid in seen:
                continue
            seen.add(rid)

            row0 = Row(mid=mid, rid=rid, row=self.array[mid][rid])
            row1 = self.mdx.search(r=row0, axis=axis)   # FIXED call
            if row1 is None:
                continue

            created, carids = self.merge2(row0=row0, row1=row1)
            if carids[mid] > 0:
                array[mid][arids[mid]] = created[mid][0]
                arids[mid] += 1

                new_rid = self.arids[mid] - 1
                extra.append(int(new_rid))
                seen.discard(rid)
                extra.append(rid)

        return (array, arids)

    def mergemat(self, mat:str=None)->REQS:
        if mat is None:
            raise ValueError("mergemat requires mat")

        mid = int(self.mat.mid(name=mat))
        array, arids = self.reqs(n=self.nrows(mid=mid))

        for ax in (0,1,2):
            while True:
                created, carids = self.mergeax(mat=mat, axis=ax)
                if carids[mid] <= 0:
                    break
                for i in range(carids[mid]):
                    array[mid][arids[mid]] = created[mid][i]
                    arids[mid] += 1

        return (array, arids)

    def mergerows(self, rows:NDARR=None)->REQS:
        if rows is None:
            return self.reqs(n=0)

        mids_present:set[int] = set()
        for mid in range(rows.shape[0]):
            for i in range(rows.shape[1]):
                if rows[mid][i][*ROW.IDS_RID] != ROW.SENTINEL:
                    mids_present.add(mid)
                    break

        worst = 0
        for mid in mids_present:
            worst += self.nrows(mid=mid)

        array, arids = self.reqs(n=worst)

        while True:
            merged_this_round = 0

            for ax in (0,1,2):
                extra:list[tuple[int,int]] = []
                for mid in mids_present:
                    for rid in range(self.arids[mid]-1, -1, -1):
                        extra.append((mid,rid))

                seen:set[tuple[int,int]] = set()

                while extra:
                    mid,rid = extra.pop()
                    if rid < 0 or rid >= self.arids[mid]:
                        continue

                    key = (mid,rid)
                    if key in seen:
                        continue
                    seen.add(key)

                    row0 = Row(mid=mid, rid=rid, row=self.array[mid][rid])
                    row1 = self.mdx.search(r=row0, axis=ax)   # FIXED call
                    if row1 is None:
                        continue

                    created, carids = self.merge2(row0=row0, row1=row1)
                    if carids[mid] > 0:
                        array[mid][arids[mid]] = created[mid][0]
                        arids[mid] += 1
                        merged_this_round += 1

                        new_rid = self.arids[mid] - 1
                        extra.append((mid, int(new_rid)))
                        seen.discard((mid,rid))
                        extra.append((mid,rid))

            if merged_this_round == 0:
                break

        return (array, arids)

    def mergeall(self)->REQS:
        array, arids = self.reqs(n=self.total)
        for mat in self.mat.names():
            created, carids = self.mergemat(mat=mat)
            for mid in range(MATERIALS.NUM):
                for i in range(carids[mid]):
                    array[mid][arids[mid]] = created[mid][i]
                    arids[mid] += 1
        return (array, arids)

    def merge(self, rows:NDARR=None)->REQS:
        if rows is None:
            return self.mergeall()
        return self.mergerows(rows=rows)

    def stats(self)->dict[str,int|float]:
        sizes = []
        for mid in range(MATERIALS.NUM):
            mat = self.mat.name(mid=mid)
            rows = self.nrows(mid=mid)
            for rid in range(self.arids[mid]):
                sizes.append((rows, mat, ROW.VOLUME(row=self.array[mid][rid])))
        volume = self.volume()
        stats = []
        for r, m, s in sizes:
            stats.append({
                "mat": m,
                "rows": r,
                "vol": int(s),
                "perc": (s / volume * 100) if volume > 0 else 0.0,
            })
        string = "ROWS STATS:\n"
        string += f"  TOTAL VOLUME: {volume}\n"
        for entry in stats:
            string += f"  MAT={entry['mat']:10s} ROWS={entry['rows']:6d} VOL={entry['vol']:12d} PERC={entry['perc']:6.2f}%\n"
        return string

    def __repr__(self)->str:
        return self.stats()

    def __str__(self)->str:
        return self.stats()

################################################################################
# FILE 42/42: world/rows.py (END)
################################################################################


################################################################################
### CAPTURED OUTPUT (STDOUT/STDERR) ###
################################################################################


=== RUNNING TEST 1/1: test8 ===
Creating Miner id=0 at pos=(587180, 181435, 56392) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=1 at pos=(556199, 645451, 46595) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=2 at pos=(961909, 993164, 40319) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=3 at pos=(153063, 456777, 47008) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=4 at pos=(268985, 878529, 46388) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=5 at pos=(639599, 417672, 36117) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=6 at pos=(440706, 239488, 31182) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=7 at pos=(745384, 352714, 56728) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=8 at pos=(263452, 487036, 54226) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=9 at pos=(212460, 535126, 35242) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=10 at pos=(63742, 523100, 6990) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=11 at pos=(175147, 913868, 11593) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=12 at pos=(909613, 447878, 15472) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=13 at pos=(132912, 668463, 39490) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=14 at pos=(262150, 902611, 41584) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=15 at pos=(953177, 115534, 26583) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=16 at pos=(654948, 150634, 55136) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=17 at pos=(913708, 760045, 55304) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=18 at pos=(721734, 495020, 17414) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=19 at pos=(813513, 926680, 2957) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=20 at pos=(657118, 106200, 24463) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=21 at pos=(570703, 120311, 46894) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=22 at pos=(745132, 948393, 42820) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=23 at pos=(434141, 802820, 3370) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=24 at pos=(671814, 616596, 18708) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=25 at pos=(739758, 502007, 35049) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=26 at pos=(686042, 664656, 32155) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=27 at pos=(887975, 493592, 31876) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=28 at pos=(248226, 55247, 8470) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=29 at pos=(927950, 904840, 31682) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=30 at pos=(686311, 144994, 58545) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=31 at pos=(263898, 883418, 2614) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=32 at pos=(505993, 970727, 40391) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=33 at pos=(427696, 747376, 33327) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=34 at pos=(594172, 407431, 11447) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=35 at pos=(906870, 681785, 40474) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=36 at pos=(243497, 672660, 52948) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=37 at pos=(346823, 439635, 42557) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=38 at pos=(820913, 404789, 51730) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=39 at pos=(465414, 865897, 45218) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=40 at pos=(982539, 332239, 19110) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=41 at pos=(213611, 949891, 10762) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=42 at pos=(612618, 722118, 48798) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=43 at pos=(859485, 557280, 25671) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=44 at pos=(528312, 671635, 59413) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=45 at pos=(231749, 332902, 18120) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=46 at pos=(567687, 803182, 32998) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=47 at pos=(544581, 124917, 24148) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=48 at pos=(603712, 883605, 24487) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=49 at pos=(459088, 872871, 3318) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=50 at pos=(200337, 985950, 54629) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=51 at pos=(251114, 961608, 50801) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=52 at pos=(142353, 281113, 44254) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=53 at pos=(884627, 326761, 29454) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=54 at pos=(568787, 542457, 16498) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=55 at pos=(673918, 156992, 23645) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=56 at pos=(646242, 420742, 22532) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=57 at pos=(601363, 440039, 10138) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=58 at pos=(913480, 305404, 54982) size=(5, 5, 900) seconds=1 floor=True
Creating Miner id=59 at pos=(800793, 831445, 10598) size=(5, 5, 900) seconds=1 floor=True
Created 60 miners.
Simulating 1200 seconds of mining...
  Simulated 1 seconds...
  Simulated 2 seconds...
  Simulated 3 seconds...
  Simulated 4 seconds...
  Simulated 5 seconds...
  Simulated 6 seconds...
  Simulated 7 seconds...
  Simulated 8 seconds...
  Simulated 9 seconds...
  Simulated 10 seconds...
  Simulated 11 seconds...
  Simulated 12 seconds...
  Simulated 13 seconds...
  Simulated 14 seconds...
  Simulated 15 seconds...
  Simulated 16 seconds...
  Simulated 17 seconds...
  Simulated 18 seconds...
  Simulated 19 seconds...
  Simulated 20 seconds...
  Simulated 21 seconds...
  Simulated 22 seconds...
  Simulated 23 seconds...
  Simulated 24 seconds...
  Simulated 25 seconds...
  Simulated 26 seconds...
  Simulated 27 seconds...
  Simulated 28 seconds...
  Simulated 29 seconds...
  Simulated 30 seconds...
  Simulated 31 seconds...
  Simulated 32 seconds...
  Simulated 33 seconds...
  Simulated 34 seconds...
  Simulated 35 seconds...
  Simulated 36 seconds...
  Simulated 37 seconds...
  Simulated 38 seconds...
  Simulated 39 seconds...
  Simulated 40 seconds...
  Simulated 41 seconds...
  Simulated 42 seconds...
  Simulated 43 seconds...
  Simulated 44 seconds...
  Simulated 45 seconds...
  Simulated 46 seconds...
  Simulated 47 seconds...
  Simulated 48 seconds...
  Simulated 49 seconds...
  Simulated 50 seconds...
  Simulated 51 seconds...
  Simulated 52 seconds...
  Simulated 53 seconds...
  Simulated 54 seconds...
  Simulated 55 seconds...
  Simulated 56 seconds...
  Simulated 57 seconds...
  Simulated 58 seconds...
  Simulated 59 seconds...
  Simulated 60 seconds...
  Simulated 61 seconds...
  Simulated 62 seconds...
  Simulated 63 seconds...
  Simulated 64 seconds...
  Simulated 65 seconds...
  Simulated 66 seconds...
  Simulated 67 seconds...
  Simulated 68 seconds...
  Simulated 69 seconds...
  Simulated 70 seconds...
  Simulated 71 seconds...
  Simulated 72 seconds...
  Simulated 73 seconds...
  Simulated 74 seconds...
  Simulated 75 seconds...
  Simulated 76 seconds...
  Simulated 77 seconds...
  Simulated 78 seconds...
  Simulated 79 seconds...
  Simulated 80 seconds...
  Simulated 81 seconds...
  Simulated 82 seconds...
  Simulated 83 seconds...
  Simulated 84 seconds...
  Simulated 85 seconds...
  Simulated 86 seconds...
  Simulated 87 seconds...
  Simulated 88 seconds...
  Simulated 89 seconds...
  Simulated 90 seconds...
  Simulated 91 seconds...
  Simulated 92 seconds...
  Simulated 93 seconds...
  Simulated 94 seconds...
  Simulated 95 seconds...
  Simulated 96 seconds...
  Simulated 97 seconds...
  Simulated 98 seconds...
  Simulated 99 seconds...
  Simulated 100 seconds...
  Simulated 101 seconds...
  Simulated 102 seconds...
  Simulated 103 seconds...
  Simulated 104 seconds...
  Simulated 105 seconds...
  Simulated 106 seconds...
  Simulated 107 seconds...
  Simulated 108 seconds...
  Simulated 109 seconds...
  Simulated 110 seconds...
  Simulated 111 seconds...
  Simulated 112 seconds...
  Simulated 113 seconds...
  Simulated 114 seconds...
  Simulated 115 seconds...
  Simulated 116 seconds...
  Simulated 117 seconds...
  Simulated 118 seconds...
  Simulated 119 seconds...
  Simulated 120 seconds...
  Simulated 121 seconds...
  Simulated 122 seconds...
  Simulated 123 seconds...
  Simulated 124 seconds...
  Simulated 125 seconds...
  Simulated 126 seconds...
  Simulated 127 seconds...
  Simulated 128 seconds...
  Simulated 129 seconds...
  Simulated 130 seconds...
  Simulated 131 seconds...
  Simulated 132 seconds...
  Simulated 133 seconds...
  Simulated 134 seconds...
  Simulated 135 seconds...
  Simulated 136 seconds...
  Simulated 137 seconds...
  Simulated 138 seconds...
  Simulated 139 seconds...
  Simulated 140 seconds...
  Simulated 141 seconds...
  Simulated 142 seconds...
  Simulated 143 seconds...
  Simulated 144 seconds...
  Simulated 145 seconds...
  Simulated 146 seconds...
  Simulated 147 seconds...
  Simulated 148 seconds...
  Simulated 149 seconds...
  Simulated 150 seconds...
  Simulated 151 seconds...
  Simulated 152 seconds...
  Simulated 153 seconds...
  Simulated 154 seconds...
  Simulated 155 seconds...
  Simulated 156 seconds...
  Simulated 157 seconds...
  Simulated 158 seconds...
  Simulated 159 seconds...
  Simulated 160 seconds...
  Simulated 161 seconds...
  Simulated 162 seconds...
  Simulated 163 seconds...
  Simulated 164 seconds...
  Simulated 165 seconds...
  Simulated 166 seconds...
  Simulated 167 seconds...
  Simulated 168 seconds...
  Simulated 169 seconds...
  Simulated 170 seconds...
  Simulated 171 seconds...
  Simulated 172 seconds...
  Simulated 173 seconds...
  Simulated 174 seconds...
  Simulated 175 seconds...
  Simulated 176 seconds...
  Simulated 177 seconds...
  Simulated 178 seconds...
  Simulated 179 seconds...
  Simulated 180 seconds...
  Simulated 181 seconds...
  Simulated 182 seconds...
  Simulated 183 seconds...
  Simulated 184 seconds...
  Simulated 185 seconds...
  Simulated 186 seconds...
  Simulated 187 seconds...
  Simulated 188 seconds...
  Simulated 189 seconds...
  Simulated 190 seconds...
  Simulated 191 seconds...
  Simulated 192 seconds...
  Simulated 193 seconds...
  Simulated 194 seconds...
  Simulated 195 seconds...
  Simulated 196 seconds...
  Simulated 197 seconds...
  Simulated 198 seconds...
  Simulated 199 seconds...
  Simulated 200 seconds...
  Simulated 201 seconds...
  Simulated 202 seconds...
  Simulated 203 seconds...
  Simulated 204 seconds...
  Simulated 205 seconds...
  Simulated 206 seconds...
  Simulated 207 seconds...
  Simulated 208 seconds...
  Simulated 209 seconds...
  Simulated 210 seconds...
  Simulated 211 seconds...
  Simulated 212 seconds...
  Simulated 213 seconds...
  Simulated 214 seconds...
  Simulated 215 seconds...
  Simulated 216 seconds...
  Simulated 217 seconds...
  Simulated 218 seconds...
  Simulated 219 seconds...
  Simulated 220 seconds...
  Simulated 221 seconds...
  Simulated 222 seconds...
  Simulated 223 seconds...
  Simulated 224 seconds...
  Simulated 225 seconds...
  Simulated 226 seconds...
  Simulated 227 seconds...
  Simulated 228 seconds...
  Simulated 229 seconds...
  Simulated 230 seconds...
  Simulated 231 seconds...
  Simulated 232 seconds...
  Simulated 233 seconds...
  Simulated 234 seconds...
  Simulated 235 seconds...
  Simulated 236 seconds...
  Simulated 237 seconds...
  Simulated 238 seconds...
  Simulated 239 seconds...
  Simulated 240 seconds...
  Simulated 241 seconds...
  Simulated 242 seconds...
  Simulated 243 seconds...
  Simulated 244 seconds...
  Simulated 245 seconds...
  Simulated 246 seconds...
  Simulated 247 seconds...
  Simulated 248 seconds...
  Simulated 249 seconds...
  Simulated 250 seconds...
  Simulated 251 seconds...
  Simulated 252 seconds...
  Simulated 253 seconds...
  Simulated 254 seconds...
  Simulated 255 seconds...
  Simulated 256 seconds...
  Simulated 257 seconds...
  Simulated 258 seconds...
  Simulated 259 seconds...
  Simulated 260 seconds...
  Simulated 261 seconds...
  Simulated 262 seconds...
  Simulated 263 seconds...
  Simulated 264 seconds...
  Simulated 265 seconds...
  Simulated 266 seconds...
  Simulated 267 seconds...
  Simulated 268 seconds...
  Simulated 269 seconds...
  Simulated 270 seconds...
  Simulated 271 seconds...
  Simulated 272 seconds...
  Simulated 273 seconds...
  Simulated 274 seconds...
  Simulated 275 seconds...
  Simulated 276 seconds...
  Simulated 277 seconds...
  Simulated 278 seconds...
  Simulated 279 seconds...
  Simulated 280 seconds...
  Simulated 281 seconds...
  Simulated 282 seconds...
  Simulated 283 seconds...
  Simulated 284 seconds...
  Simulated 285 seconds...
  Simulated 286 seconds...
  Simulated 287 seconds...
  Simulated 288 seconds...
  Simulated 289 seconds...
  Simulated 290 seconds...
  Simulated 291 seconds...
  Simulated 292 seconds...
  Simulated 293 seconds...
  Simulated 294 seconds...
  Simulated 295 seconds...
  Simulated 296 seconds...
  Simulated 297 seconds...
  Simulated 298 seconds...
  Simulated 299 seconds...
  Simulated 300 seconds...
  Simulated 301 seconds...
  Simulated 302 seconds...
  Simulated 303 seconds...
  Simulated 304 seconds...
  Simulated 305 seconds...
  Simulated 306 seconds...
  Simulated 307 seconds...
  Simulated 308 seconds...
  Simulated 309 seconds...
  Simulated 310 seconds...
  Simulated 311 seconds...
  Simulated 312 seconds...
  Simulated 313 seconds...
  Simulated 314 seconds...
  Simulated 315 seconds...
  Simulated 316 seconds...
  Simulated 317 seconds...
  Simulated 318 seconds...
  Simulated 319 seconds...
  Simulated 320 seconds...
  Simulated 321 seconds...
  Simulated 322 seconds...
  Simulated 323 seconds...
  Simulated 324 seconds...
  Simulated 325 seconds...
  Simulated 326 seconds...
  Simulated 327 seconds...
  Simulated 328 seconds...
  Simulated 329 seconds...
  Simulated 330 seconds...
  Simulated 331 seconds...
  Simulated 332 seconds...
  Simulated 333 seconds...
  Simulated 334 seconds...
  Simulated 335 seconds...
  Simulated 336 seconds...
  Simulated 337 seconds...
  Simulated 338 seconds...
  Simulated 339 seconds...
  Simulated 340 seconds...
  Simulated 341 seconds...
  Simulated 342 seconds...
  Simulated 343 seconds...
  Simulated 344 seconds...
  Simulated 345 seconds...
  Simulated 346 seconds...
  Simulated 347 seconds...
  Simulated 348 seconds...
  Simulated 349 seconds...
  Simulated 350 seconds...
  Simulated 351 seconds...
  Simulated 352 seconds...
  Simulated 353 seconds...
  Simulated 354 seconds...
  Simulated 355 seconds...
  Simulated 356 seconds...
  Simulated 357 seconds...
  Simulated 358 seconds...
  Simulated 359 seconds...
  Simulated 360 seconds...
  Simulated 361 seconds...
  Simulated 362 seconds...
  Simulated 363 seconds...
  Simulated 364 seconds...
  Simulated 365 seconds...
  Simulated 366 seconds...
  Simulated 367 seconds...
  Simulated 368 seconds...
  Simulated 369 seconds...
  Simulated 370 seconds...
  Simulated 371 seconds...
  Simulated 372 seconds...
  Simulated 373 seconds...
  Simulated 374 seconds...
  Simulated 375 seconds...
  Simulated 376 seconds...
  Simulated 377 seconds...
  Simulated 378 seconds...
  Simulated 379 seconds...
  Simulated 380 seconds...
  Simulated 381 seconds...
  Simulated 382 seconds...
  Simulated 383 seconds...
  Simulated 384 seconds...
  Simulated 385 seconds...
  Simulated 386 seconds...
  Simulated 387 seconds...
  Simulated 388 seconds...
  Simulated 389 seconds...
  Simulated 390 seconds...
  Simulated 391 seconds...
  Simulated 392 seconds...
  Simulated 393 seconds...
  Simulated 394 seconds...
  Simulated 395 seconds...
  Simulated 396 seconds...
  Simulated 397 seconds...
  Simulated 398 seconds...
  Simulated 399 seconds...
  Simulated 400 seconds...
  Simulated 401 seconds...
  Simulated 402 seconds...
  Simulated 403 seconds...
  Simulated 404 seconds...
  Simulated 405 seconds...
  Simulated 406 seconds...
  Simulated 407 seconds...
  Simulated 408 seconds...
  Simulated 409 seconds...
  Simulated 410 seconds...
  Simulated 411 seconds...
  Simulated 412 seconds...
  Simulated 413 seconds...
  Simulated 414 seconds...
  Simulated 415 seconds...
  Simulated 416 seconds...
  Simulated 417 seconds...
  Simulated 418 seconds...
  Simulated 419 seconds...
  Simulated 420 seconds...
  Simulated 421 seconds...
  Simulated 422 seconds...
  Simulated 423 seconds...
  Simulated 424 seconds...
  Simulated 425 seconds...
  Simulated 426 seconds...
  Simulated 427 seconds...
  Simulated 428 seconds...
  Simulated 429 seconds...
  Simulated 430 seconds...
  Simulated 431 seconds...
  Simulated 432 seconds...
  Simulated 433 seconds...
  Simulated 434 seconds...
  Simulated 435 seconds...
  Simulated 436 seconds...
  Simulated 437 seconds...
  Simulated 438 seconds...
  Simulated 439 seconds...
  Simulated 440 seconds...
  Simulated 441 seconds...
  Simulated 442 seconds...
  Simulated 443 seconds...
  Simulated 444 seconds...
  Simulated 445 seconds...
  Simulated 446 seconds...
  Simulated 447 seconds...
  Simulated 448 seconds...
  Simulated 449 seconds...
  Simulated 450 seconds...
  Simulated 451 seconds...
  Simulated 452 seconds...
  Simulated 453 seconds...
  Simulated 454 seconds...
  Simulated 455 seconds...
  Simulated 456 seconds...
  Simulated 457 seconds...
  Simulated 458 seconds...
  Simulated 459 seconds...
  Simulated 460 seconds...
  Simulated 461 seconds...
  Simulated 462 seconds...
  Simulated 463 seconds...
  Simulated 464 seconds...
  Simulated 465 seconds...
  Simulated 466 seconds...
  Simulated 467 seconds...
  Simulated 468 seconds...
  Simulated 469 seconds...
  Simulated 470 seconds...
  Simulated 471 seconds...
  Simulated 472 seconds...
  Simulated 473 seconds...
  Simulated 474 seconds...
  Simulated 475 seconds...
  Simulated 476 seconds...
  Simulated 477 seconds...
  Simulated 478 seconds...
  Simulated 479 seconds...
  Simulated 480 seconds...
  Simulated 481 seconds...
  Simulated 482 seconds...
  Simulated 483 seconds...
  Simulated 484 seconds...
  Simulated 485 seconds...
  Simulated 486 seconds...
  Simulated 487 seconds...
  Simulated 488 seconds...
  Simulated 489 seconds...
  Simulated 490 seconds...
  Simulated 491 seconds...
  Simulated 492 seconds...
  Simulated 493 seconds...
  Simulated 494 seconds...
  Simulated 495 seconds...
  Simulated 496 seconds...
  Simulated 497 seconds...
  Simulated 498 seconds...
  Simulated 499 seconds...
  Simulated 500 seconds...
  Simulated 501 seconds...
  Simulated 502 seconds...
  Simulated 503 seconds...
  Simulated 504 seconds...
  Simulated 505 seconds...
  Simulated 506 seconds...
  Simulated 507 seconds...
  Simulated 508 seconds...
  Simulated 509 seconds...
  Simulated 510 seconds...
  Simulated 511 seconds...
  Simulated 512 seconds...
  Simulated 513 seconds...
  Simulated 514 seconds...
  Simulated 515 seconds...
  Simulated 516 seconds...
  Simulated 517 seconds...
  Simulated 518 seconds...
  Simulated 519 seconds...
  Simulated 520 seconds...
  Simulated 521 seconds...
  Simulated 522 seconds...
  Simulated 523 seconds...
  Simulated 524 seconds...
  Simulated 525 seconds...
  Simulated 526 seconds...
  Simulated 527 seconds...
  Simulated 528 seconds...
  Simulated 529 seconds...
  Simulated 530 seconds...
  Simulated 531 seconds...
  Simulated 532 seconds...
  Simulated 533 seconds...
  Simulated 534 seconds...
  Simulated 535 seconds...
  Simulated 536 seconds...
  Simulated 537 seconds...
  Simulated 538 seconds...
  Simulated 539 seconds...
  Simulated 540 seconds...
  Simulated 541 seconds...
  Simulated 542 seconds...
  Simulated 543 seconds...
  Simulated 544 seconds...
  Simulated 545 seconds...
  Simulated 546 seconds...
  Simulated 547 seconds...
  Simulated 548 seconds...
  Simulated 549 seconds...
  Simulated 550 seconds...
  Simulated 551 seconds...
  Simulated 552 seconds...
  Simulated 553 seconds...
  Simulated 554 seconds...
  Simulated 555 seconds...
  Simulated 556 seconds...
  Simulated 557 seconds...
  Simulated 558 seconds...
  Simulated 559 seconds...
  Simulated 560 seconds...
  Simulated 561 seconds...
  Simulated 562 seconds...
  Simulated 563 seconds...
  Simulated 564 seconds...
  Simulated 565 seconds...
  Simulated 566 seconds...
  Simulated 567 seconds...
  Simulated 568 seconds...
  Simulated 569 seconds...
  Simulated 570 seconds...
  Simulated 571 seconds...
  Simulated 572 seconds...
  Simulated 573 seconds...
  Simulated 574 seconds...
  Simulated 575 seconds...
  Simulated 576 seconds...
  Simulated 577 seconds...
  Simulated 578 seconds...
  Simulated 579 seconds...
  Simulated 580 seconds...
  Simulated 581 seconds...
  Simulated 582 seconds...
  Simulated 583 seconds...
  Simulated 584 seconds...
  Simulated 585 seconds...
  Simulated 586 seconds...
  Simulated 587 seconds...
  Simulated 588 seconds...
  Simulated 589 seconds...
  Simulated 590 seconds...
  Simulated 591 seconds...
  Simulated 592 seconds...
  Simulated 593 seconds...
  Simulated 594 seconds...
  Simulated 595 seconds...
  Simulated 596 seconds...
  Simulated 597 seconds...
  Simulated 598 seconds...
  Simulated 599 seconds...
  Simulated 600 seconds...
  Simulated 601 seconds...
  Simulated 602 seconds...
  Simulated 603 seconds...
  Simulated 604 seconds...
  Simulated 605 seconds...
  Simulated 606 seconds...
  Simulated 607 seconds...
  Simulated 608 seconds...
  Simulated 609 seconds...
  Simulated 610 seconds...
  Simulated 611 seconds...
  Simulated 612 seconds...
  Simulated 613 seconds...
  Simulated 614 seconds...
  Simulated 615 seconds...
  Simulated 616 seconds...
  Simulated 617 seconds...
  Simulated 618 seconds...
  Simulated 619 seconds...
  Simulated 620 seconds...
  Simulated 621 seconds...
  Simulated 622 seconds...
  Simulated 623 seconds...
  Simulated 624 seconds...
  Simulated 625 seconds...
  Simulated 626 seconds...
  Simulated 627 seconds...
  Simulated 628 seconds...
  Simulated 629 seconds...
  Simulated 630 seconds...
  Simulated 631 seconds...
  Simulated 632 seconds...
  Simulated 633 seconds...
  Simulated 634 seconds...
  Simulated 635 seconds...
  Simulated 636 seconds...
  Simulated 637 seconds...
  Simulated 638 seconds...
  Simulated 639 seconds...
  Simulated 640 seconds...
  Simulated 641 seconds...
  Simulated 642 seconds...
  Simulated 643 seconds...
  Simulated 644 seconds...
  Simulated 645 seconds...
  Simulated 646 seconds...
  Simulated 647 seconds...
  Simulated 648 seconds...
  Simulated 649 seconds...
  Simulated 650 seconds...
  Simulated 651 seconds...
  Simulated 652 seconds...
  Simulated 653 seconds...
  Simulated 654 seconds...
  Simulated 655 seconds...
  Simulated 656 seconds...
  Simulated 657 seconds...
  Simulated 658 seconds...
  Simulated 659 seconds...
  Simulated 660 seconds...
  Simulated 661 seconds...
  Simulated 662 seconds...
  Simulated 663 seconds...
  Simulated 664 seconds...
  Simulated 665 seconds...
  Simulated 666 seconds...
  Simulated 667 seconds...
  Simulated 668 seconds...
  Simulated 669 seconds...
  Simulated 670 seconds...
  Simulated 671 seconds...
  Simulated 672 seconds...
  Simulated 673 seconds...
  Simulated 674 seconds...
  Simulated 675 seconds...
  Simulated 676 seconds...
  Simulated 677 seconds...
  Simulated 678 seconds...
  Simulated 679 seconds...
  Simulated 680 seconds...
  Simulated 681 seconds...
  Simulated 682 seconds...
  Simulated 683 seconds...
  Simulated 684 seconds...
  Simulated 685 seconds...
  Simulated 686 seconds...
  Simulated 687 seconds...
  Simulated 688 seconds...
  Simulated 689 seconds...
  Simulated 690 seconds...
  Simulated 691 seconds...
  Simulated 692 seconds...
  Simulated 693 seconds...
  Simulated 694 seconds...
  Simulated 695 seconds...
  Simulated 696 seconds...
  Simulated 697 seconds...
  Simulated 698 seconds...
  Simulated 699 seconds...
  Simulated 700 seconds...
  Simulated 701 seconds...
  Simulated 702 seconds...
  Simulated 703 seconds...
  Simulated 704 seconds...
  Simulated 705 seconds...
  Simulated 706 seconds...
  Simulated 707 seconds...
  Simulated 708 seconds...
  Simulated 709 seconds...
  Simulated 710 seconds...
  Simulated 711 seconds...
  Simulated 712 seconds...
  Simulated 713 seconds...
  Simulated 714 seconds...
  Simulated 715 seconds...
  Simulated 716 seconds...
  Simulated 717 seconds...
  Simulated 718 seconds...
  Simulated 719 seconds...
  Simulated 720 seconds...
  Simulated 721 seconds...
  Simulated 722 seconds...
  Simulated 723 seconds...
  Simulated 724 seconds...
  Simulated 725 seconds...
  Simulated 726 seconds...
  Simulated 727 seconds...
  Simulated 728 seconds...
  Simulated 729 seconds...
  Simulated 730 seconds...
  Simulated 731 seconds...
  Simulated 732 seconds...
  Simulated 733 seconds...
  Simulated 734 seconds...
  Simulated 735 seconds...
  Simulated 736 seconds...
  Simulated 737 seconds...
  Simulated 738 seconds...
  Simulated 739 seconds...
  Simulated 740 seconds...
  Simulated 741 seconds...
  Simulated 742 seconds...
  Simulated 743 seconds...
  Simulated 744 seconds...
  Simulated 745 seconds...
  Simulated 746 seconds...
  Simulated 747 seconds...
  Simulated 748 seconds...
  Simulated 749 seconds...
  Simulated 750 seconds...
  Simulated 751 seconds...
  Simulated 752 seconds...
  Simulated 753 seconds...
  Simulated 754 seconds...
  Simulated 755 seconds...
  Simulated 756 seconds...
  Simulated 757 seconds...
  Simulated 758 seconds...
  Simulated 759 seconds...
  Simulated 760 seconds...
  Simulated 761 seconds...
  Simulated 762 seconds...
  Simulated 763 seconds...
  Simulated 764 seconds...
  Simulated 765 seconds...
  Simulated 766 seconds...
  Simulated 767 seconds...
  Simulated 768 seconds...
  Simulated 769 seconds...
  Simulated 770 seconds...
  Simulated 771 seconds...
  Simulated 772 seconds...
  Simulated 773 seconds...
  Simulated 774 seconds...
  Simulated 775 seconds...
  Simulated 776 seconds...
  Simulated 777 seconds...
  Simulated 778 seconds...
  Simulated 779 seconds...
  Simulated 780 seconds...
  Simulated 781 seconds...
  Simulated 782 seconds...
  Simulated 783 seconds...
  Simulated 784 seconds...
  Simulated 785 seconds...
  Simulated 786 seconds...
  Simulated 787 seconds...
  Simulated 788 seconds...
  Simulated 789 seconds...
  Simulated 790 seconds...
  Simulated 791 seconds...
  Simulated 792 seconds...
  Simulated 793 seconds...
  Simulated 794 seconds...
  Simulated 795 seconds...
  Simulated 796 seconds...
  Simulated 797 seconds...
  Simulated 798 seconds...
  Simulated 799 seconds...
  Simulated 800 seconds...
  Simulated 801 seconds...
  Simulated 802 seconds...
  Simulated 803 seconds...
  Simulated 804 seconds...
  Simulated 805 seconds...
  Simulated 806 seconds...
  Simulated 807 seconds...
  Simulated 808 seconds...
  Simulated 809 seconds...
  Simulated 810 seconds...
  Simulated 811 seconds...
  Simulated 812 seconds...
  Simulated 813 seconds...
  Simulated 814 seconds...
  Simulated 815 seconds...
  Simulated 816 seconds...
  Simulated 817 seconds...
  Simulated 818 seconds...
  Simulated 819 seconds...
  Simulated 820 seconds...
  Simulated 821 seconds...
  Simulated 822 seconds...
  Simulated 823 seconds...
  Simulated 824 seconds...
  Simulated 825 seconds...
  Simulated 826 seconds...
  Simulated 827 seconds...
  Simulated 828 seconds...
  Simulated 829 seconds...
  Simulated 830 seconds...
  Simulated 831 seconds...
  Simulated 832 seconds...
  Simulated 833 seconds...
  Simulated 834 seconds...
  Simulated 835 seconds...
  Simulated 836 seconds...
  Simulated 837 seconds...
  Simulated 838 seconds...
  Simulated 839 seconds...
  Simulated 840 seconds...
  Simulated 841 seconds...
  Simulated 842 seconds...
  Simulated 843 seconds...
  Simulated 844 seconds...
  Simulated 845 seconds...
  Simulated 846 seconds...
  Simulated 847 seconds...
  Simulated 848 seconds...
  Simulated 849 seconds...
  Simulated 850 seconds...
  Simulated 851 seconds...
  Simulated 852 seconds...
  Simulated 853 seconds...
  Simulated 854 seconds...
  Simulated 855 seconds...
  Simulated 856 seconds...
  Simulated 857 seconds...
  Simulated 858 seconds...
  Simulated 859 seconds...
  Simulated 860 seconds...
  Simulated 861 seconds...
  Simulated 862 seconds...
  Simulated 863 seconds...
  Simulated 864 seconds...
  Simulated 865 seconds...
  Simulated 866 seconds...
  Simulated 867 seconds...
  Simulated 868 seconds...
  Simulated 869 seconds...
  Simulated 870 seconds...
  Simulated 871 seconds...
  Simulated 872 seconds...
  Simulated 873 seconds...
  Simulated 874 seconds...
  Simulated 875 seconds...
  Simulated 876 seconds...
  Simulated 877 seconds...
  Simulated 878 seconds...
  Simulated 879 seconds...
  Simulated 880 seconds...
  Simulated 881 seconds...
  Simulated 882 seconds...
  Simulated 883 seconds...
  Simulated 884 seconds...
  Simulated 885 seconds...
  Simulated 886 seconds...
  Simulated 887 seconds...
  Simulated 888 seconds...
  Simulated 889 seconds...
  Simulated 890 seconds...
  Simulated 891 seconds...
  Simulated 892 seconds...
  Simulated 893 seconds...
  Simulated 894 seconds...
  Simulated 895 seconds...
  Simulated 896 seconds...
  Simulated 897 seconds...
  Simulated 898 seconds...
  Simulated 899 seconds...
  Simulated 900 seconds...
  Simulated 901 seconds...
  Simulated 902 seconds...
  Simulated 903 seconds...
  Simulated 904 seconds...
  Simulated 905 seconds...
  Simulated 906 seconds...
  Simulated 907 seconds...
  Simulated 908 seconds...
  Simulated 909 seconds...
  Simulated 910 seconds...
  Simulated 911 seconds...
  Simulated 912 seconds...
  Simulated 913 seconds...
  Simulated 914 seconds...
  Simulated 915 seconds...
  Simulated 916 seconds...
  Simulated 917 seconds...
  Simulated 918 seconds...
  Simulated 919 seconds...
  Simulated 920 seconds...
  Simulated 921 seconds...
  Simulated 922 seconds...
  Simulated 923 seconds...
  Simulated 924 seconds...
  Simulated 925 seconds...
  Simulated 926 seconds...
  Simulated 927 seconds...
  Simulated 928 seconds...
  Simulated 929 seconds...
  Simulated 930 seconds...
  Simulated 931 seconds...
  Simulated 932 seconds...
  Simulated 933 seconds...
  Simulated 934 seconds...
  Simulated 935 seconds...
  Simulated 936 seconds...
  Simulated 937 seconds...
  Simulated 938 seconds...
  Simulated 939 seconds...
  Simulated 940 seconds...
  Simulated 941 seconds...
  Simulated 942 seconds...
  Simulated 943 seconds...
  Simulated 944 seconds...
  Simulated 945 seconds...
  Simulated 946 seconds...
  Simulated 947 seconds...
  Simulated 948 seconds...
  Simulated 949 seconds...
  Simulated 950 seconds...
  Simulated 951 seconds...
  Simulated 952 seconds...
  Simulated 953 seconds...
  Simulated 954 seconds...
  Simulated 955 seconds...
  Simulated 956 seconds...
  Simulated 957 seconds...
  Simulated 958 seconds...
  Simulated 959 seconds...
  Simulated 960 seconds...
  Simulated 961 seconds...
  Simulated 962 seconds...
  Simulated 963 seconds...
  Simulated 964 seconds...
  Simulated 965 seconds...
  Simulated 966 seconds...
  Simulated 967 seconds...
  Simulated 968 seconds...
  Simulated 969 seconds...
  Simulated 970 seconds...
  Simulated 971 seconds...
  Simulated 972 seconds...
  Simulated 973 seconds...
  Simulated 974 seconds...
  Simulated 975 seconds...
  Simulated 976 seconds...
  Simulated 977 seconds...
  Simulated 978 seconds...
  Simulated 979 seconds...
  Simulated 980 seconds...
  Simulated 981 seconds...
  Simulated 982 seconds...
  Simulated 983 seconds...
  Simulated 984 seconds...
  Simulated 985 seconds...
  Simulated 986 seconds...
  Simulated 987 seconds...
  Simulated 988 seconds...
  Simulated 989 seconds...
  Simulated 990 seconds...
  Simulated 991 seconds...
  Simulated 992 seconds...
  Simulated 993 seconds...
  Simulated 994 seconds...
  Simulated 995 seconds...
  Simulated 996 seconds...
  Simulated 997 seconds...
  Simulated 998 seconds...
  Simulated 999 seconds...
  Simulated 1000 seconds...
  Simulated 1001 seconds...
  Simulated 1002 seconds...
  Simulated 1003 seconds...
  Simulated 1004 seconds...
  Simulated 1005 seconds...
  Simulated 1006 seconds...
  Simulated 1007 seconds...
  Simulated 1008 seconds...
  Simulated 1009 seconds...
  Simulated 1010 seconds...
  Simulated 1011 seconds...
  Simulated 1012 seconds...
  Simulated 1013 seconds...
  Simulated 1014 seconds...
  Simulated 1015 seconds...
  Simulated 1016 seconds...
  Simulated 1017 seconds...
  Simulated 1018 seconds...
  Simulated 1019 seconds...
  Simulated 1020 seconds...
  Simulated 1021 seconds...
  Simulated 1022 seconds...
  Simulated 1023 seconds...
  Simulated 1024 seconds...
  Simulated 1025 seconds...
  Simulated 1026 seconds...
  Simulated 1027 seconds...
  Simulated 1028 seconds...
  Simulated 1029 seconds...
  Simulated 1030 seconds...
  Simulated 1031 seconds...
  Simulated 1032 seconds...
  Simulated 1033 seconds...
  Simulated 1034 seconds...
  Simulated 1035 seconds...
  Simulated 1036 seconds...
  Simulated 1037 seconds...
  Simulated 1038 seconds...
  Simulated 1039 seconds...
  Simulated 1040 seconds...
  Simulated 1041 seconds...
  Simulated 1042 seconds...
  Simulated 1043 seconds...
  Simulated 1044 seconds...
  Simulated 1045 seconds...
  Simulated 1046 seconds...
  Simulated 1047 seconds...
  Simulated 1048 seconds...
  Simulated 1049 seconds...
  Simulated 1050 seconds...
  Simulated 1051 seconds...
  Simulated 1052 seconds...
  Simulated 1053 seconds...
  Simulated 1054 seconds...
  Simulated 1055 seconds...
  Simulated 1056 seconds...
  Simulated 1057 seconds...
  Simulated 1058 seconds...
  Simulated 1059 seconds...
  Simulated 1060 seconds...
  Simulated 1061 seconds...
  Simulated 1062 seconds...
  Simulated 1063 seconds...
  Simulated 1064 seconds...
  Simulated 1065 seconds...
  Simulated 1066 seconds...
  Simulated 1067 seconds...
  Simulated 1068 seconds...
  Simulated 1069 seconds...
  Simulated 1070 seconds...
  Simulated 1071 seconds...
  Simulated 1072 seconds...
  Simulated 1073 seconds...
  Simulated 1074 seconds...
  Simulated 1075 seconds...
  Simulated 1076 seconds...
  Simulated 1077 seconds...
  Simulated 1078 seconds...
  Simulated 1079 seconds...
  Simulated 1080 seconds...
  Simulated 1081 seconds...
  Simulated 1082 seconds...
  Simulated 1083 seconds...
  Simulated 1084 seconds...
  Simulated 1085 seconds...
  Simulated 1086 seconds...
  Simulated 1087 seconds...
  Simulated 1088 seconds...
  Simulated 1089 seconds...
  Simulated 1090 seconds...
  Simulated 1091 seconds...
  Simulated 1092 seconds...
  Simulated 1093 seconds...
  Simulated 1094 seconds...
  Simulated 1095 seconds...
  Simulated 1096 seconds...
  Simulated 1097 seconds...
  Simulated 1098 seconds...
  Simulated 1099 seconds...
  Simulated 1100 seconds...
  Simulated 1101 seconds...
  Simulated 1102 seconds...
  Simulated 1103 seconds...
  Simulated 1104 seconds...
  Simulated 1105 seconds...
  Simulated 1106 seconds...
  Simulated 1107 seconds...
  Simulated 1108 seconds...
  Simulated 1109 seconds...
  Simulated 1110 seconds...
  Simulated 1111 seconds...
  Simulated 1112 seconds...
  Simulated 1113 seconds...
  Simulated 1114 seconds...
  Simulated 1115 seconds...
  Simulated 1116 seconds...
  Simulated 1117 seconds...
  Simulated 1118 seconds...
  Simulated 1119 seconds...
  Simulated 1120 seconds...
  Simulated 1121 seconds...
  Simulated 1122 seconds...
  Simulated 1123 seconds...
  Simulated 1124 seconds...
  Simulated 1125 seconds...
  Simulated 1126 seconds...
  Simulated 1127 seconds...
  Simulated 1128 seconds...
  Simulated 1129 seconds...
  Simulated 1130 seconds...
  Simulated 1131 seconds...
  Simulated 1132 seconds...
  Simulated 1133 seconds...
  Simulated 1134 seconds...
  Simulated 1135 seconds...
  Simulated 1136 seconds...
  Simulated 1137 seconds...
  Simulated 1138 seconds...
  Simulated 1139 seconds...
  Simulated 1140 seconds...
  Simulated 1141 seconds...
  Simulated 1142 seconds...
  Simulated 1143 seconds...
  Simulated 1144 seconds...
  Simulated 1145 seconds...
  Simulated 1146 seconds...
  Simulated 1147 seconds...
  Simulated 1148 seconds...
  Simulated 1149 seconds...
  Simulated 1150 seconds...
  Simulated 1151 seconds...
  Simulated 1152 seconds...
  Simulated 1153 seconds...
  Simulated 1154 seconds...
  Simulated 1155 seconds...
  Simulated 1156 seconds...
  Simulated 1157 seconds...
  Simulated 1158 seconds...
  Simulated 1159 seconds...
  Simulated 1160 seconds...
  Simulated 1161 seconds...
  Simulated 1162 seconds...
  Simulated 1163 seconds...
  Simulated 1164 seconds...
  Simulated 1165 seconds...
  Simulated 1166 seconds...
  Simulated 1167 seconds...
  Simulated 1168 seconds...
  Simulated 1169 seconds...
  Simulated 1170 seconds...
  Simulated 1171 seconds...
  Simulated 1172 seconds...
  Simulated 1173 seconds...
  Simulated 1174 seconds...
  Simulated 1175 seconds...
  Simulated 1176 seconds...
  Simulated 1177 seconds...
  Simulated 1178 seconds...
  Simulated 1179 seconds...
  Simulated 1180 seconds...
  Simulated 1181 seconds...
  Simulated 1182 seconds...
  Simulated 1183 seconds...
  Simulated 1184 seconds...
  Simulated 1185 seconds...
  Simulated 1186 seconds...
  Simulated 1187 seconds...
  Simulated 1188 seconds...
  Simulated 1189 seconds...
  Simulated 1190 seconds...
  Simulated 1191 seconds...
  Simulated 1192 seconds...
  Simulated 1193 seconds...
  Simulated 1194 seconds...
  Simulated 1195 seconds...
  Simulated 1196 seconds...
  Simulated 1197 seconds...
  Simulated 1198 seconds...
  Simulated 1199 seconds...
  Simulated 1200 seconds...
Simulated 1200 seconds in 26.85 seconds. Remaining time: 1173.15 seconds.
ROWS STATS:
  TOTAL VOLUME: 72056357089509375
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=AIR        ROWS=    60 VOL=         768 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=37616629881600 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=1352396722668750 PERC=  1.88%
  MAT=STONE      ROWS=   301 VOL=236394549084375 PERC=  0.33%
  MAT=STONE      ROWS=   301 VOL=24513301137600 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=858716943418125 PERC=  1.19%
  MAT=STONE      ROWS=   301 VOL=26933747781600 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=4212221011824375 PERC=  5.85%
  MAT=STONE      ROWS=   301 VOL=   167697408 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=3709745156328750 PERC=  5.15%
  MAT=STONE      ROWS=   301 VOL=1017046315828125 PERC=  1.41%
  MAT=STONE      ROWS=   301 VOL=949976234460000 PERC=  1.32%
  MAT=STONE      ROWS=   301 VOL=6678420889016250 PERC=  9.27%
  MAT=STONE      ROWS=   301 VOL=131941143675000 PERC=  0.18%
  MAT=STONE      ROWS=   301 VOL=38254280922000 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=24915148632000 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=344146483085625 PERC=  0.48%
  MAT=STONE      ROWS=   301 VOL=    85412928 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=43932994023600 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=335350406840625 PERC=  0.47%
  MAT=STONE      ROWS=   301 VOL=968667896480625 PERC=  1.34%
  MAT=STONE      ROWS=   301 VOL=21176618047200 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=1007150730052500 PERC=  1.40%
  MAT=STONE      ROWS=   301 VOL=   173993856 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=1847176011450000 PERC=  2.56%
  MAT=STONE      ROWS=   301 VOL=16446403947600 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=    92118528 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=954374272582500 PERC=  1.32%
  MAT=STONE      ROWS=   301 VOL=25473527402400 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=27302728741200 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=   129392256 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    71933376 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=44874597596400 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=7901658547200 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=    77247168 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   124078464 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=31599638096400 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=30628389211200 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=    85863936 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=452997926617500 PERC=  0.63%
  MAT=STONE      ROWS=   301 VOL=   116710080 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=116548010246250 PERC=  0.16%
  MAT=STONE      ROWS=   301 VOL=   175388160 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=22147866932400 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=15371471966400 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=    25937472 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=700387571008125 PERC=  0.97%
  MAT=STONE      ROWS=   301 VOL=   153752256 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=127543105552500 PERC=  0.18%
  MAT=STONE      ROWS=   301 VOL=10928298981600 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=    88587072 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=32486581551600 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=316658744820000 PERC=  0.44%
  MAT=STONE      ROWS=   301 VOL=43644342297600 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=   112738560 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=9131913846000 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=    94535424 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   106790208 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=2788722961200 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=20289674592000 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=    16639104 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=44217770216400 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=49987533182400 PERC=  0.07%
  MAT=STONE      ROWS=   301 VOL=26388228735000 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=1915345602348750 PERC=  2.66%
  MAT=STONE      ROWS=   301 VOL=22990317253200 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=29785938890400 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=   171937536 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   149680512 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=174822015369375 PERC=  0.24%
  MAT=STONE      ROWS=   301 VOL=8558485927200 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=    51645120 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    78522624 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   122803008 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=31754156108400 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=3655869189328125 PERC=  5.07%
  MAT=STONE      ROWS=   301 VOL=23715520111800 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=496978307842500 PERC=  0.69%
  MAT=STONE      ROWS=   301 VOL=    84615552 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=40722441922800 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=45542044944000 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=21022100035200 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=35023596181200 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=   143113728 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=17752659962400 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=   150742848 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=33453199929600 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=1945032359675625 PERC=  2.70%
  MAT=STONE      ROWS=   301 VOL=25842508362000 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=390325883371875 PERC=  0.54%
  MAT=STONE      ROWS=   301 VOL=    50582784 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    40792320 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   160533312 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=1574497647855000 PERC=  2.19%
  MAT=STONE      ROWS=   301 VOL=26447796183600 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=909294381826875 PERC=  1.26%
  MAT=STONE      ROWS=   301 VOL=7297780010400 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=26328459960000 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=    12238464 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=1075320320951250 PERC=  1.49%
  MAT=STONE      ROWS=   301 VOL=6779817514800 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=    33628224 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=45996438628800 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=30233839798800 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=    26679936 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=1249042826790000 PERC=  1.73%
  MAT=STONE      ROWS=   301 VOL=22542416344800 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=33644812330800 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=    50332800 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=19131443812800 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=   175806528 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=275976892186875 PERC=  0.38%
  MAT=STONE      ROWS=   301 VOL=   150992832 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=7346400336000 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=3103915404954375 PERC=  4.31%
  MAT=STONE      ROWS=   301 VOL=    99889728 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    18315648 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    25519104 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=5815011074400 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=1286426150831250 PERC=  1.79%
  MAT=STONE      ROWS=   301 VOL=46961245069200 PERC=  0.07%
  MAT=STONE      ROWS=   301 VOL=25266815521200 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=45194605909200 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=1233649693361250 PERC=  1.71%
  MAT=STONE      ROWS=   301 VOL=    47573376 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    75575616 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=72567629021250 PERC=  0.10%
  MAT=STONE      ROWS=   301 VOL=7581650234400 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=   125750016 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    12678144 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   175431936 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=2149541132371875 PERC=  2.98%
  MAT=STONE      ROWS=   301 VOL=1143489911850000 PERC=  1.59%
  MAT=STONE      ROWS=   301 VOL=27861107511600 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=16755490303200 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=    45131136 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=14521975221600 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=40425435151200 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=723477271151250 PERC=  1.00%
  MAT=STONE      ROWS=   301 VOL=    62752704 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    96766080 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=46641287088000 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=6287272477200 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=19563918085800 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=5345215920000 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=    75158976 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   189087168 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=46720811016000 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=   109574976 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=6055445127600 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=    91750656 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=12053814220800 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=   143065344 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=5042119024800 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=47734137118800 PERC=  0.07%
  MAT=STONE      ROWS=   301 VOL=1523920209446250 PERC=  2.11%
  MAT=STONE      ROWS=   301 VOL=    58211904 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=3927448043392500 PERC=  5.45%
  MAT=STONE      ROWS=   301 VOL=   117970560 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    83355072 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=40407215112000 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=2874117913053750 PERC=  3.99%
  MAT=STONE      ROWS=   301 VOL=12369041031600 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=389226373841250 PERC=  0.54%
  MAT=STONE      ROWS=   301 VOL=   128988288 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=21741992910000 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=   184686528 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=31034263233600 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=    59292096 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   142033536 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=159428881940625 PERC=  0.22%
  MAT=STONE      ROWS=   301 VOL=27509440622400 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=    69605568 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=19323056214000 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=    30834432 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=874110076846875 PERC=  1.21%
  MAT=STONE      ROWS=   301 VOL=27932981036400 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=24843275107200 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=   170491200 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   153666240 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    47659392 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=253986701574375 PERC=  0.35%
  MAT=STONE      ROWS=   301 VOL=1781205439612500 PERC=  2.47%
  MAT=STONE      ROWS=   301 VOL=2780669905200 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    23159232 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=160528391471250 PERC=  0.22%
  MAT=STONE      ROWS=   301 VOL=   178166400 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=7234211199600 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=    69553920 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=45478476133200 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=8312414734800 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=45429855807600 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=   150657216 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=901597815112500 PERC=  1.25%
  MAT=STONE      ROWS=   301 VOL=44463841408800 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=    50668416 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=324355311534375 PERC=  0.45%
  MAT=STONE      ROWS=   301 VOL=   104174976 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    97150656 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=3918013070400 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=38482833571875 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=48858243073200 PERC=  0.07%
  MAT=STONE      ROWS=   301 VOL=1840578954266250 PERC=  2.55%
  MAT=STONE      ROWS=   301 VOL=   119208000 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    82117632 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=15159626262000 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=    72337344 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   114081024 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=32269602024000 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=    87244608 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=20506654119600 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=107751934001250 PERC=  0.15%
  MAT=STONE      ROWS=   301 VOL=1167679121523750 PERC=  1.62%
  MAT=STONE      ROWS=   301 VOL=    27206592 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   174119040 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=18460926237600 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=    29388096 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=34315329906000 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=18920202087600 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=33856054056000 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=    46751424 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    66590016 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=22127532966000 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=   154574208 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   134735616 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=30648723177600 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=   131771712 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   157615296 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    43710336 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=32402578111200 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=20373678032400 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=    25893696 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    89359488 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=9194274698400 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=43581981445200 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=16722120452400 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=   131720064 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   111966144 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=4966722288000 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=36054135691200 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=36345354328800 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=    41013312 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=47809533855600 PERC=  0.07%
  MAT=STONE      ROWS=   301 VOL=   160312320 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   165021120 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   117622656 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    36304512 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=28048794048000 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=    83702976 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=18971791977600 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=   156829824 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   138572928 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=24727462095600 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=   101435904 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=593735146537500 PERC=  0.82%
  MAT=STONE      ROWS=   301 VOL=33804464166000 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=28262955006000 PERC=  0.04%
  MAT=STONE      ROWS=   301 VOL=36020765840400 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=    92329728 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    44495808 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   108995904 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=16430901814800 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=308962178105625 PERC=  0.43%
  MAT=STONE      ROWS=   301 VOL=   156194496 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=12350820992400 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=46488983666400 PERC=  0.06%
  MAT=STONE      ROWS=   301 VOL=    58260288 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   115912704 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   104559552 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=22236626709000 PERC=  0.03%
  MAT=STONE      ROWS=   301 VOL=293569044676875 PERC=  0.41%
  MAT=STONE      ROWS=   301 VOL=   183009984 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=8843262120000 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=8303002725600 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=   126166656 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    88144896 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   174645696 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=   113180736 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=49624441020000 PERC=  0.07%
  MAT=STONE      ROWS=   301 VOL=3151815123600 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    48213888 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=4398038122500 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=48399269212800 PERC=  0.07%
  MAT=STONE      ROWS=   301 VOL=   153111744 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    38464704 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=4376986930800 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=   188647488 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=    27331776 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=38627389072800 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=    31477248 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=14148867070800 PERC=  0.02%
  MAT=STONE      ROWS=   301 VOL=49995586238400 PERC=  0.07%
  MAT=STONE      ROWS=   301 VOL=   169848384 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=36329852196000 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=   109207104 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=500276836434375 PERC=  0.69%
  MAT=STONE      ROWS=   301 VOL=   162860928 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=1170977650115625 PERC=  1.63%
  MAT=STONE      ROWS=   301 VOL=   115461696 PERC=  0.00%
  MAT=STONE      ROWS=   301 VOL=37404784177200 PERC=  0.05%
  MAT=STONE      ROWS=   301 VOL=6134969055600 PERC=  0.01%
  MAT=STONE      ROWS=   301 VOL=41847957162000 PERC=  0.06%

=== TEST 1/1: test8 PASSED in 26.867 seconds ===


################################################################################
### END OF CAPTURED OUTPUT ###
################################################################################
# Total lines in bundle: 5724
# Total files in bundle: 42
# Generated at the time: 2026-01-31T07:43:54
--- END OF FILE ---
